# Руководство по стилю кода проекта Battler

Этот документ описывает принятые стандарты кодирования для проекта Battler. Следование этим правилам помогает обеспечить согласованность, читаемость и поддерживаемость кода.

## 1. Общие принципы

* **Язык:** Весь код, комментарии и docstrings пишутся на русском языке.
* **PEP 8:** Соблюдаем рекомендации [PEP 8](https://peps.python.org/pep-0008/) по оформлению кода Python.
* **Аннотации типов:** Используем аннотации типов (`typing`) для всех параметров функций, методов и возвращаемых значений.
* **Именование:**
  * Переменные, функции, методы: `snake_case`.
  * Классы: `PascalCase`.
  * Константы: `UPPER_CASE_WITH_UNDERSCORES`.
* **Пустые строки:** Используем пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
* **Константы:** Именуем константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.
* Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.

## 2. Структура файла

Файлы должны следовать этой структуре сверху вниз:

1. **Комментарий модуля (Docstring):** Первая строка файла. Подробно описывает назначение модуля.
2. **Импорты:**
   * Стандартная библиотека (например, `os`, `json`, `typing`).
   * Сторонние библиотеки (например, `curses`, `dataclasses`).
   * Локальные импорты (например, `from game.protocols import ...`).
   * Импорты внутри `if TYPE_CHECKING:` располагаются после основных импортов.
3. **Константы модуля:** Если используются.
4. **Классы и функции:** Основное содержимое модуля.

## 3. Комментарии и Docstrings

* **Язык:** Все комментарии и docstrings на русском языке.
* **Docstrings:** Используем docstrings для всех модулей, классов, функций и методов.
* **Стиль:** Docstring следует стилю Google, описывая `Args` для каждого параметра конструктора.
* При длинных списках параметров допускается перенос аргументов `__init__` на новые строки с выравниванием.

## 4. Функции и методы

* **Именование:** Использовать `snake_case`.
* **Docstrings:** Все публичные (не начинающиеся с `_`) функции и методы должны иметь docstring в стиле Google.
* **Аннотации типов:** Использовать аннотации типов для всех параметров и возвращаемых значений (см. `typing`).
* **Длина:** Функции и методы должны быть компактными и выполнять одну задачу. Избегать чрезмерной длины.

## 5. Классы

* **Именование:** Использовать `PascalCase`.
* **Docstrings:** Классы должны иметь docstring, описывающий их назначение и основные атрибуты/методы.
* **Атрибуты:** Атрибуты класса, если не очевидны из контекста, должны быть задокументированы в docstring класса или аннотированы типами.
* **Методы:** См. раздел "Функции и методы".

## 6. Обработка ошибок

* **Исключения:** Использовать встроенные исключения Python (`ValueError`, `TypeError`, `FileNotFoundError` и т.д.) при возможности. Создавать собственные исключения только при необходимости.
* **Блоки try/except:** Использовать для обработки ожидаемых ошибок. Не подавлять исключения без логгирования или обработки.
* **finally:** Использовать для кода, который должен выполниться в любом случае (например, закрытие файлов).

Пример обработки ошибок:

```python
try:
    with open("config.json", 'r', encoding='utf-8') as f:
        data = json.load(f)
    # ... обработка данных ...
except FileNotFoundError:
    # Обработка отсутствия файла
    print("Файл конфигурации не найден, используются значения по умолчанию.")
    data = {}
except json.JSONDecodeError as e:
    # Обработка ошибки парсинга JSON
    print(f"Ошибка чтения конфигурации: Некорректный JSON. {e}")
    data = {}
except Exception as e:
    # Логирование или обработка других исключений
    # Пока просто выходим
    print(f"Критическая ошибка: {e}")
    exit()
```
## 7. Написание тестов

Тесты обеспечивают надежность и корректность кода. Для проекта Battler установлены следующие правила написания тестов с использованием `pytest`:

* **Фреймворк:** Использовать `pytest` для написания тестов. Все тесты должны находиться в директории `tests/`. Тесты должны быть простыми - и выдавать максимальное покрытие
* **Структура файлов тестов:**
  * Файлы тестов должны называться `test_<имя_модуля>.py`, где `<имя_модуля>` соответствует тестируемому файлу в основном коде (например, тесты для `game/entities/character.py` находятся в `tests/test_character.py`).
  * Внутри файлов тестов классы тестов именуются как `Test<ИмяКласса>` или `Test<ОписаниеФункционала>`.
  * Отдельные тестовые методы именуются как `test_<описание_теста>`.
* **Покрытие:**
  * Стремиться к высокому покрытию кода тестами, особенно для бизнес-логики.
  * Тестировать как нормальные сценарии, так и граничные условия и возможные ошибки.
* **Читаемость тестов:**
  * Тесты должны быть легко читаемыми и понятными.
  * Использовать понятные имена для переменных внутри тестов.
  * Комментарии в тестах допустимы для пояснения сложных сценариев подготовки данных.
* **Фикстуры:**
  * Использовать фикстуры `pytest` (`@pytest.fixture`) для подготовки и очистки общих ресурсов, объектов или данных, используемых в нескольких тестах.
  * Использовать декоратор `@pytest.mark.parametrize` для запуска одного и того же теста с разными наборами входных данных и ожидаемых результатов.
* **Маркировка тестов:**
  * Использовать марки (`@pytest.mark.slow`, `@pytest.mark.integration`) для классификации тестов и возможности выборочного запуска.
* **Docstrings для тестов:** Docstrings для тестов не обязательны, но могут быть полезны для сложных сценариев. Если используются, следовать стилю Google.

## 8. Прочее

* **Отступы:** 4 пробела.
* **Пробелы:** Следовать PEP 8 (пробелы вокруг операторов, после запятых и т.д.).
* **Пустые строки:** Использовать пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
* **Константы:** Именовать константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.
* Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.
* Не допускать магических чисел. Магические числа должны быть на именованные константы.

## 9. Принципы проектирования

* **SOLID и DRY:**
  * Следовать принципам [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) для объектно-ориентированного проектирования.
    * **S** - Принцип единственной ответственности (Single Responsibility Principle).
    * **O** - Принцип открытости/закрытости (Open/Closed Principle).
    * **L** - Принцип подстановки Барбары Лисков (Liskov Substitution Principle).
    * **I** - Принцип разделения интерфейса (Interface Segregation Principle).
    * **D** - Принцип инверсии зависимостей (Dependency Inversion Principle).
  * Следовать принципу [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself) (Don't Repeat Yourself) - избегать дублирования кода. Повторяющуюся логику следует выносить в функции, классы или модули.

## 10. Рабочий процесс

* **Работа с TODO:**
  * **Перед началом работы:** Всегда уточнять, над какой конкретной задачей вы работаете.
  * **Поиск задачи:** Найти эту задачу в файле `PROJECT_TODO.md` в корне проекта.
  * **Если задачи нет:** Добавить новую задачу в секцию `## TODO` файла `PROJECT_TODO.md`, используя формат `<!-- TODO: Краткое описание задачи. -->`.
  * **Если задача есть:** Перед началом работы изменить тег задачи с `TODO` на `WIP` (Work In Progress) в файле `PROJECT_TODO.md`.
  * **После завершения:** Изменить тег задачи с `WIP` (или `TODO`, если забыли поменять) на `DONE` в файле `PROJECT_TODO.md`.