# Руководство по стилю кода проекта Battler

Это руководство описывает стандарты кодирования для проекта Battler. Основной целью является обеспечение единообразия, читаемости и поддерживаемости кода.

## 1. Общие принципы

*   **PEP 8:** Следовать рекомендациям [PEP 8](https://pep8.org/) для Python кода.
*   **Единообразие:** Все файлы проекта должны следовать единому стилю, установленному этим руководством и примерами из `game/entities/character.py`.
*   **Читаемость:** Код должен быть понятным и легко читаемым. Приоритет читаемости выше краткости, если это не противоречит эффективности.
*   **Проверка стиля (flake8):** Весь код должен проходить проверку с помощью инструмента `flake8`. Конфигурация `flake8` определена в файле `setup.cfg` или `.flake8` в корне проекта. Перед коммитом убедитесь, что `flake8` не выдает ошибок или предупреждений. Основные проверки включают:
    *   Соблюдение PEP 8 (E, W ошибки).
    *   Отсутствие неиспользуемых импортов (F401).
    *   Отсутствие неопределенных переменных (F821).
    *   Максимальная длина строки — 88 символов (настройка `max-line-length`).
    *   Игнорируемые ошибки определены в конфигурации (например, `E203`, `W503` — см. ниже).
*   **Конфигурация flake8:** Проект использует следующую конфигурацию `flake8` (пример для `setup.cfg`):
    ```ini
    [flake8]
    max-line-length = 88
    extend-ignore = E203, W503
    # E203: whitespace before ':' (конфликтует с PEP 8, рекомендуемым black)
    # W503: line break before binary operator (конфликтует с PEP 8, рекомендуемым black)
    ```
    Эта конфигурация позволяет использовать более современные стандарты форматирования, совместимые с `black` (если используется) и рекомендациями PEP 8 относительно разрыва строк вокруг бинарных операторов.

## 2. Структура файла

Файлы должны следовать этой структуре сверху вниз:

1.  **Комментарий модуля (Docstring):** Первая строка файла. Подробно описывает назначение модуля.
2.  **Импорты:**
    *   Стандартная библиотека (например, `os`, `json`, `typing`).
    *   Сторонние библиотеки (например, `curses`, `dataclasses`).
    *   Локальные импорты (например, `from game.protocols import ...`).
    *   Импорты внутри `if TYPE_CHECKING:` располагаются после основных импортов.
3.  **Константы модуля:** Если используются.
4.  **Классы и функции:** Основное содержимое модуля.

## 3. Комментарии и Docstrings

*   **Язык:** Все комментарии и docstrings на русском языке.
*   **Docstrings стиле Google:** Используется стиль Google для docstrings функций, методов и классов.
*   **Формат docstrings:**
    *   Начинается с краткого описания (предложения) на одной строке.
    *   Если требуется, следует более подробное описание.
    *   Используются секции `Args:`, `Returns:`, `Raises:` при необходимости.
    *   Завершается точкой `.`.
    *   Первая буква заглавная.
    *   Пример:
        ```python
        def example_function(param1: int, param2: str) -> bool:
            """Выполняет примерное действие.

            Подробное описание того, что делает функция, если необходимо.
            Может занимать несколько строк.

            Args:
                param1: Описание первого параметра.
                param2: Описание второго параметра.

            Returns:
                Описание возвращаемого значения.

            Raises:
                ValueError: Если param1 отрицательный.
            """
            ...
        ```
*   **Комментарии в коде:** Используются для пояснения сложной логики. Должны быть краткими и по делу. Не злоупотреблять.

## 4. Импорты

*   **Порядок:** Стандартная библиотека → Сторонние библиотеки → Локальные импорты.
*   **Форматирование:** Каждый импорт на отдельной строке (если не импортируется несколько элементов из одного модуля).
*   **`from ... import ...`:** Предпочтительно использовать `from module import class_or_function`, если это улучшает читаемость.
*   **`TYPE_CHECKING`:** Использовать `from typing import TYPE_CHECKING` и `if TYPE_CHECKING:` для импортов, используемых только в аннотациях типов, чтобы избежать циклических импортов.
*   **Избегать `import *`:** Не использовать `from module import *`.

## 5. Классы

*   **Именование:** Использовать `CapWords` (PascalCase).
*   **Docstrings:** Каждый класс должен иметь docstring, описывающий его назначение.
*   **Атрибуты:** Если атрибуты класса важны для понимания API, описывать их в docstring класса или в docstring `__init__`.
*   **`__init__` метод:**
    *   Docstring следует стилю Google, описывая `Args` для каждого параметра конструктора.
    *   При длинных списках параметров допускается перенос аргументов `__init__` на новые строки с выравниванием.

## 6. Функции и методы

*   **Именование:** Использовать `snake_case`.
*   **Docstrings:** Все публичные (не начинающиеся с `_`) функции и методы должны иметь docstring в стиле Google.
*   **Аннотации типов:** Использовать аннотации типов для всех параметров и возвращаемых значений (см. `typing`).
*   **Длина:** Функции и методы должны быть компактными и выполнять одну задачу. Избегать чрезмерной длины.

## 7. Написание тестов

Тесты обеспечивают надежность и корректность кода. Для проекта Battler установлены следующие правила написания тестов с использованием `pytest`:

*   **Фреймворк:** Использовать `pytest` для написания тестов. Все тесты должны находиться в директории `tests/`.
*   **Структура файлов тестов:**
    *   Файлы тестов должны называться `test_<имя_модуля>.py`, где `<имя_модуля>` соответствует тестируемому файлу в основном коде (например, тесты для `game/entities/character.py` находятся в `tests/test_character.py`).
    *   Каждый тестовый файл может содержать несколько классов тестов или отдельных тестовых функций, соответствующих тестируемому классу или группе функций.
*   **Классы тестов:**
    *   Именовать классы тестов как `Test<ИмяКласса>` или `Test<ИмяФункции>` (например, `TestCharacter`, `TestGameLogic`). Использование классов не обязательно, если тесты логически не требуют группировки.
    *   Наследовать от `unittest.TestCase` не нужно. Классы тестов в `pytest` обычно используются только для логической группировки.
*   **Тестовые функции:**
    *   Именовать функции тестов как `test_<описание_тестируемого_поведения>` (например, `test_initial_health_is_100`, `test_take_damage_reduces_health`).
    *   Каждая тестовая функция должна проверять одно конкретное поведение или сценарий.
    *   Использовать `def` для определения тестовых функций.
*   **Структура теста (AAA):**
    *   **Arrange (Подготовка):** Настройка необходимых данных и объектов для теста.
    *   **Act (Действие):** Вызов тестируемой функции или метода.
    *   **Assert (Проверка):** Проверка результата с помощью `assert` утверждений Python (например, `assert result == expected`, `assert obj.health == 90`).
*   **Покрытие:**
    *   Стремиться к высокому покрытию кода тестами, особенно для бизнес-логики.
    *   Тестировать как нормальные сценарии, так и граничные условия и возможные ошибки.
*   **Читаемость тестов:**
    *   Тесты должны быть легко читаемыми и понятными.
    *   Использовать понятные имена для переменных внутри тестов.
    *   Комментарии в тестах допустимы для пояснения сложных сценариев подготовки данных.
*   **Фикстуры:**
    *   Использовать фикстуры `pytest` (`@pytest.fixture`) для подготовки и очистки общих ресурсов, объектов или данных, используемых в нескольких тестах.
    *   Фикстуры позволяют избежать дублирования кода и упрощают управление зависимостями тестов.
    *   Фикстуры могут иметь разные области действия (`scope`): `function` (по умолчанию), `class`, `module`, `package`, `session`.
*   **Mock-объекты:**
    *   Использовать `unittest.mock` или `pytest-mock` (через фикстуру `mocker`) для создания mock- и patch-объектов, чтобы изолировать тестируемый код от внешних зависимостей (например, файловая система, сеть, другие модули).
*   **Параметризованные тесты:**
    *   Использовать декоратор `@pytest.mark.parametrize` для запуска одного и того же теста с разными наборами входных данных и ожидаемых результатов.
*   **Маркировка тестов:**
    *   Использовать марки (`@pytest.mark.slow`, `@pytest.mark.integration`) для классификации тестов и возможности выборочного запуска.
*   **Docstrings для тестов:** Docstrings для тестов не обязательны, но могут быть полезны для сложных сценариев. Если используются, следовать стилю Google.

## 8. Прочее

*   **Отступы:** 4 пробела.
*   **Пробелы:** Следовать PEP 8 (пробелы вокруг операторов, после запятых и т.д.).
*   **Пустые строки:** Использовать пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
*   **Константы:** Именовать константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.

Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.