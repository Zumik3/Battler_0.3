Сборник исходных кодов и конфигурационных файлов
Дата создания: 2025-08-17 14:23:17
================================================================================

================================================================================
Файл: PROJECT_TODO.md
================================================================================

# PROJECT TODO LIST

## Общее

<!-- DONE: Создать этот файл PROJECT_TODO.md и поместить в корень проекта -->
<!-- DONE: Настроить в IDE отображение TODO из этого файла (если необходимо, добавить паттерн в настройки TODO) -->

## Игровая логика & Менеджеры

<!-- DONE: Создать масштабируемую систему имен монстров -->
<!-- DONE: Интегрировать реальные данные монстров в BattleScreen. Связать EnemyGroupPanel с GameManager, чтобы панели отображали состояние объектов Character (монстров), созданных фабрикой. -->
<!-- DONE: Добавить загрузку стартовых монстров в GameManager._initialize_game_entities (или аналогичный метод), используя monster_factory. -->
<!-- DONE: Реализовать механизм обновления UI (HP/MP) в BattleScreen на основе текущего состояния объектов Player/Character. -->
<!-- DONE: Добавить в GameManager методы для управления текущими врагами (`get_current_enemies`, `set_current_enemies` и т.д.). -->
<!-- TODO: Создать JSON-файлы для классов монстров в `game/data/characters/monster_classes/`, если они еще не существуют. -->
<!-- TODO: GameManager должен отвечать за хранение и предоставление данных о текущих игроках и монстрах для экранов UI. -->
<!-- DONE: Описание задачи -->
<!-- TODO: Сделать централихованный обработчик ошибок -->


## Пользовательский Интерфейс

<!-- TODO: Доработать BattleScreen.render, чтобы он обновлял содержимое UnitPanel (имя, HP, MP) на основе данных из GameManager перед отрисовкой панелей. -->
<!-- TODO: Проверить/доработать логику `_update_component_sizes` в `BattleScreen` для корректного изменения размеров компонентов при ресайзе окна терминала. -->
<!-- TODO: Реализовать отображение имен монстров/игроков в UnitPanel (сейчас в EnemyUnitPanel имя передается вручную, нужно брать из объекта Character). -->
<!-- DONE: Улучшить визуал BattleScreen: корректное расположение игроков/монстров, настройка лога, порядок обрамления. -->

## Компоненты UI

<!-- TODO: Проверить корректность работы прокрутки BattleLog (scroll_up, scroll_down) и отображения большого количества сообщений. -->
<!-- TODO: Добавить отображение дополнительной информации в UnitPanel (например, уровень, статусные эффекты, если будут). -->
<!-- TODO: Убедиться, что отрисовка (render) всех компонентов корректно обрабатывает выход за границы экрана (curses.error). -->

## Данные

<!-- TODO: Убедиться, что все необходимые JSON-файлы (игроки, монстры) существуют и корректны. -->
<!-- TODO: Проверить/доработать character_loader.py для корректной обработки всех полей из JSON (например, abilities, если структура сложнее). -->

## Система Команд

<!-- TODO: Завершить рефакторинг системы команд (Command System) согласно ранее обсужденным идеям (регистрация, контекст). -->
<!-- TODO: Добавить команды для BattleScreen (например, выбор цели, использование атаки/зелья). -->

## Тестирование

<!-- TODO: Добавить тесты для BattleScreen (особенно логику обновления данных и отрисовки). -->
<!-- TODO: Добавить тесты для интеграции GameManager с фабриками и UI. -->
<!-- TODO: Проверить и дополнить существующие тесты для компонентов UI (UnitPanel, GroupPanel, BattleLog). -->

## Документация/Кодстайл

<!-- TODO: Добавить/проверить docstrings для новых/измененных классов и методов. -->
<!-- TODO: Убедиться, что весь код соответствует PEP 8 и проходит flake8. -->

## DONE (переносить сюда выполненные задачи)

<!-- DONE: Реализовать фабрики для создания игроков и монстров. -->
<!-- DONE: Создать базовую структуру BattleScreen с компонентами (UnitPanel, GroupPanel, BattleLog). -->
<!-- DONE: Настроить базовую отрисовку BattleScreen с использованием Renderer. -->
<!-- DONE: Реализовать базовую прокрутку BattleLog. -->

================================================================================
Файл: game/__init__.py
================================================================================



================================================================================
Файл: game/config.py
================================================================================

# game/config.py
"""Основные настройки игры."""

from dataclasses import dataclass, field
from pathlib import Path
import json
import os
from typing import Any, Dict


@dataclass
class ExperienceSettings:
    """Настройки системы опыта."""

    formula_base: int = 100
    formula_multiplier: float = 1.5


@dataclass
class CombatSettings:
    """Настройки боевой системы."""

    min_damage: int = 1
    defense_reduction_factor: float = 0.5


@dataclass
class CharacterSettings:
    """Настройки персонажей."""

    base_max_hp: int = 50
    base_max_energy: int = 20
    hp_per_vitality: int = 5
    energy_per_intelligence: int = 3
    attack_per_strength: int = 2
    defense_per_agility: float = 1.5


@dataclass
class UISettings:
    """Настройки пользовательского интерфейса."""

    screen_width: int = 80
    screen_height: int = 24


@dataclass
class SystemSettings:
    """Системные настройки."""

    enable_debug_logging: bool = False
    log_file: str = "game.log"
    save_directory: str = "saves"
    autosave_interval: int = 300
    data_directory: str = "game/data"
    characters_data_directory: str = "game/data/characters"
    player_classes_directory: str = "game/data/characters/player_classes"
    monster_classes_directory: str = "game/data/characters/monster_classes"


@dataclass
class GameConfig:
    """Основной класс конфигурации игры."""

    experience: ExperienceSettings = field(default_factory=ExperienceSettings)
    combat: CombatSettings = field(default_factory=CombatSettings)
    character: CharacterSettings = field(default_factory=CharacterSettings)
    ui: UISettings = field(default_factory=UISettings)
    system: SystemSettings = field(default_factory=SystemSettings)

    config_file: str = "config.json"

    def load_from_file(self, config_file: str = "") -> None:
        """
        Загрузить конфигурацию из файла.

        Args:
            config_file: Путь к файлу конфигурации. Если не указан, используется self.config_file.
        """
        file_path = config_file or self.config_file
        try:
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self._update_from_dict(data)
        except Exception as e:
            print(f"Ошибка загрузки конфигурации: {e}")

    def save_to_file(self, config_file: str = "") -> None:
        """
        Сохранить конфигурацию в файл.

        Args:
            config_file: Путь к файлу конфигурации. Если не указан, используется self.config_file.
        """
        file_path = config_file or self.config_file
        try:
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self._to_dict(), f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Ошибка сохранения конфигурации: {e}")

    def _to_dict(self) -> Dict[str, Any]:
        """Преобразовать конфигурацию в словарь."""
        return {
            'experience': {
                'formula_base': self.experience.formula_base,
                'formula_multiplier': self.experience.formula_multiplier,
            },
            'combat': {
                'min_damage': self.combat.min_damage,
                'defense_reduction_factor': self.combat.defense_reduction_factor,
            },
            'character': {
                'base_max_hp': self.character.base_max_hp,
                'base_max_energy': self.character.base_max_energy,
                'hp_per_vitality': self.character.hp_per_vitality,
                'energy_per_intelligence': self.character.energy_per_intelligence,
                'attack_per_strength': self.character.attack_per_strength,
                'defense_per_agility': self.character.defense_per_agility,
            },
            'ui': {
                'screen_width': self.ui.screen_width,
                'screen_height': self.ui.screen_height,
            },
            'system': {
                'enable_debug_logging': self.system.enable_debug_logging,
                'log_file': self.system.log_file,
                'save_directory': self.system.save_directory,
                'autosave_interval': self.system.autosave_interval,
                'data_directory': self.system.data_directory,
                'characters_data_directory': self.system.characters_data_directory,
                'player_classes_directory': self.system.player_classes_directory,
            }
        }

    def _update_from_dict(self, data: Dict[str, Any]) -> None:
        """
        Обновить конфигурацию из словаря.

        Args:
            data: Словарь с данными конфигурации.
        """
        if 'experience' in data:
            for key, value in data['experience'].items():
                if hasattr(self.experience, key):
                    setattr(self.experience, key, value)

        if 'combat' in data:
            for key, value in data['combat'].items():
                if hasattr(self.combat, key):
                    setattr(self.combat, key, value)

        if 'character' in data:
            for key, value in data['character'].items():
                if hasattr(self.character, key):
                    setattr(self.character, key, value)

        if 'ui' in data:
            for key, value in data['ui'].items():
                if hasattr(self.ui, key):
                    setattr(self.ui, key, value)

        if 'system' in data:
            for key, value in data['system'].items():
                if hasattr(self.system, key):
                    setattr(self.system, key, value)


# Глобальный экземпляр конфигурации
game_config = GameConfig()


def get_config() -> GameConfig:
    """Получить глобальный экземпляр конфигурации."""
    return game_config


================================================================================
Файл: game/protocols.py
================================================================================

# game/protocols.py
"""Протоколы, определяющие интерфейсы для различных компонентов игры."""

from collections.abc import Callable
import traceback
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Protocol, Optional

# Импорты с TYPE_CHECKING для избежания циклических импортов
# в аннотациях типов на уровне модуля
# (импортируем только при аннотации типов, а не во время выполнения)
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType


class Stats(Protocol):
    """Протокол для базовых характеристик персонажа."""
    strength: int
    agility: int
    intelligence: int
    vitality: int


class Attributes(Protocol):
    """Протокол для производных атрибутов персонажа."""
    max_hp: int
    max_energy: int
    attack_power: int
    defense: int

    def recalculate(self, stats: Stats) -> None:
        """Пересчитать атрибуты на основе базовых характеристик."""
        ...


class AbilityManagerProtocol(Protocol):
    """Протокол для менеджера способностей."""
    def use_ability(self, ability_name: str, target: 'CharacterType') -> List[Dict[str, Any]]:
        """Использовать способность на цель."""
        ...

    def get_available_abilities(self) -> List[str]:
        """Получить список доступных способностей."""
        ...


class StatusEffectManagerProtocol(Protocol):
    """Протокол для менеджера статус-эффектов."""
    def apply_effect(self, effect: 'StatusEffect') -> List[Dict[str, Any]]:
        """Применить эффект к персонажу."""
        ...

    def remove_effect(self, effect_name: str) -> List[Dict[str, Any]]:
        """Удалить эффект по имени."""
        ...

    def get_effect(self, effect_name: str) -> Optional['StatusEffect']:
        """Получить эффект по имени."""
        ...

    def get_all_effects(self) -> List['StatusEffect']:
        """Получить список всех активных эффектов."""
        ...

    def clear_all_effects(self) -> List[Dict[str, Any]]:
        """Очистить все эффекты и вернуть список результатов."""
        ...


# Протоколы для системы уровней/опыта
# Эти протоколы позволят нам в будущем легко подменить систему роста
class ExperienceCalculatorProtocol(Protocol):
    """Протокол для калькулятора опыта."""
    def calculate_exp_for_next_level(self, current_level: int) -> int:
        """Рассчитать опыт, необходимый для следующего уровня."""
        ...

    def calculate_stat_increase(self, base_stat: int, growth_rate: float, level: int) -> int:
        """Рассчитать увеличение характеристики."""
        ...


class LevelUpHandlerProtocol(Protocol):
    """Протокол для обработчика повышения уровня."""
    def handle_level_up(self, character: 'CharacterType') -> List[Dict[str, Any]]:
        """Обработать повышение уровня и вернуть список результатов."""
        ...


# Базовые абстрактные классы
class Character(ABC):
    """Абстрактный базовый класс, представляющий персонажа в игре."""
    # (Определение класса находится в game/entities/character.py)
    pass # fallback если абстрактные методы не реализованы корректно


class Ability(ABC):
    """Абстрактный базовый класс для способностей."""
    def __init__(self, name: str, energy_cost: int, description: str = ""):
        self.name = name
        self.energy_cost = energy_cost
        self.description = description

    @abstractmethod
    def activate(self, caster: 'CharacterType', target: 'CharacterType') -> List[Dict[str, Any]]:
        """Активировать способность."""
        ...


class StatusEffect(ABC):
    """Абстрактный базовый класс для статус-эффектов."""
    def __init__(self, name: str, duration: int, description: str = ""):
        self.name = name
        self.duration = duration
        self.description = description

    @abstractmethod
    def apply(self, target: 'CharacterType') -> List[Dict[str, Any]]:
        """Применить эффект к цели."""
        ...

    @abstractmethod
    def remove(self, target: 'CharacterType') -> List[Dict[str, Any]]:
        """Удалить эффект с цели."""
        ...

    def tick(self, target: 'CharacterType') -> List[Dict[str, Any]]:
        """Выполнить действие эффекта за ход (если применимо)."""
        # По умолчанию эффект просто уменьшает свою длительность
        self.duration -= 1
        if self.duration <= 0:
            return target.status_manager.remove_effect(self.name) # type: ignore
        return []

# --- Протокол для генератора имен монстров ---
class MonsterNamerProtocol(Protocol):
    """Протокол для генератора имен монстров."""
    
    def generate_name(self, monster_role: str) -> str:
        """
        Генерирует имя для монстра на основе его роли.

        Args:
            monster_role: Роль/тип монстра (например, 'goblin', 'dragon').

        Returns:
            Сгенерированное имя.
        """
        ... # Тело метода в протоколе пустое, описывает интерфейс


================================================================================
Файл: game/game_manager.py
================================================================================

# game/game_manager.py
"""Менеджер игрового состояния.
Отвечает за инициализацию и хранение основных сущностей игры:
игроков, глобального состояния, текущих врагов, инвентаря и т.д.
Реализует паттерн Singleton для обеспечения единственного экземпляра менеджера."""

from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union

from game.factories.player_factory import create_player
from game.config import get_config

if TYPE_CHECKING:
    from game.entities.player import Player
    from game.entities.monster import Monster
    # from game.inventory import Inventory # и т.д.


class GameManager:
    """Менеджер игрового состояния."""
    _instance: Optional['GameManager'] = None # Для реализации Singleton

    def __new__(cls) -> 'GameManager':
        """Реализация паттерна Singleton."""
        if cls._instance is None:
            cls._instance = super(GameManager, cls).__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        """Инициализирует менеджер игры и загружает начальное состояние."""
        # Проверка, инициализирован ли уже объект, чтобы избежать повторной инициализации
        # при повторном вызове __init__ на том же экземпляре из-за Singleton
        if hasattr(self, 'initialized'):
            return

        self.config = get_config() # Получаем глобальную конфигурацию

        # --- Инициализация основных сущностей ---
        self.player_group: List['Player'] = []
        self.current_enemies: List['Monster'] = []
        # self.global_inventory: 'Inventory' = ... # Для будущего использования

        self._initialize_game_entities()

        self.initialized = True # Флаг, что инициализация прошла

    def _initialize_game_entities(self) -> None:
        """Создает и инициализирует стартовые сущности игры."""
        # Получаем пути из конфигурации
        player_data_dir = self.config.system.player_classes_directory
        # monster_data_dir = self.config.system.monster_classes_directory # Если понадобится напрямую

        # --- Инициализация игроков ---
        # В будущем это может загружаться из файла сохранения или профиля
        
        # Словарь с именами и ролями стартовых игроков
        starting_players = {
            "Роланд": "berserker",
            "Стайлс": "rogue",
            "Морган": "mage",
            "Дамиан": "healer"
        }
        
        # Создаем каждого игрока из словаря
        for name, role in starting_players.items():
            player = create_player(
                role=role,
                name=name,
                level=1,
                data_directory=player_data_dir
            )
            if player:
                self.player_group.append(player)

        # --- Инициализация стартовых врагов ---
        # Создаем начальную группу врагов для первого боя
        # Пример данных для создания монстров
        initial_enemy_data = [
            {'role': 'goblin', 'level': 1}, # Имя будет сгенерировано
            {'role': 'orc', 'name': 'Громозека', 'level': 2},
            # Можно добавить больше стартовых монстров
        ]
        
        # Создаем монстров, используя существующий метод create_enemies
        # Это заполнит self.current_enemies
        self.create_enemies(initial_enemy_data)
        
        # Альтернатива: можно вызвать create_monster напрямую в цикле,
        # но использование create_enemies более консистентно и переиспользует логику
        
        # --- Инициализация других сущностей ---
        # TODO: Инициализация инвентаря, глобального состояния и т.д.


    def get_player_group(self) -> List['Player']:
        """Получить текущую группу игроков."""
        return self.player_group

    # TODO: Добавить методы для управления другими сущностями
    # def get_global_inventory(self) -> 'Inventory': ...
    # def start_new_battle(self, enemies: List['Monster']) -> None: ...
    # и т.д.


    def get_current_enemies(self) -> List['Monster']:
        """
        Получение списка текущих врагов (монстров) в бою.

        Returns:
            List[Monster]: Список объектов Monster, представляющих текущих врагов.
                           Если врагов нет, возвращается пустой список.
        """
        return self.current_enemies.copy() # Возвращаем копию, чтобы предотвратить случайное изменение внутреннего списка извне


    def create_enemies(self, enemy_data_list: List[Dict[str, Any]]) -> bool:
        """
        Создание новой группы врагов (монстров) и сохранение их в current_enemies.

        Args:
            enemy_data_list (List[Dict[str, Any]]): Список словарей с данными для создания монстров.
                Каждый словарь может содержать ключи:
                - 'role' (str, обязательный): Роль/тип монстра (например, 'goblin', 'dragon').
                - 'level' (int, опциональный): Уровень монстра. По умолчанию 1.
                - 'name' (str, опциональный): Имя монстра. Если не указано,
                                             будет сгенерировано фабрикой.

        Returns:
            bool: Монстры созданы.

        Example:
            enemy_data = [
                {'role': 'goblin', 'level': 2},
                {'role': 'orc', 'name': 'Громила'},
                {'role': 'dragon'} # Будет уровень 1
            ]
            new_enemies = game_manager.create_enemies(enemy_data)
        """
        # Очищаем список текущих врагов перед созданием новых
        self.current_enemies.clear()
        
        # Импортируем фабрику внутри метода, чтобы избежать циклических импортов
        from game.factories.monster_factory import create_monster

        for enemy_data in enemy_data_list:
            role = enemy_data.get('role')
            if not role:
                # Можно логировать ошибку или пропустить
                print(f"Предупреждение: Пропущен монстр без 'role': {enemy_data}")
                continue

            level = enemy_data.get('level', 1) # Уровень по умолчанию 1
            name = enemy_data.get('name') # Имя может быть None, тогда сгенерируется
            
            # Создаем монстра с помощью фабрики
            monster = create_monster(name=name, role=role, level=level)
            if monster:
                self.current_enemies.append(monster)
        
        return True # Возвращаем список только что созданных врагов

# Функция для удобного получения экземпляра GameManager
def get_game_manager() -> GameManager:
    """Получить глобальный экземпляр GameManager."""
    # Это гарантирует, что экземпляр будет создан при первом вызове
    return GameManager()


================================================================================
Файл: game/ui/base_screen.py
================================================================================

# game/ui/base_screen.py
import curses
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, List
from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.command_system import CommandRegistry
from game.ui.command_system.screen_command_registry import get_screen_commands

if TYPE_CHECKING:
    from game.ui.screen_manager import ScreenManager
    from game.ui.command_system.command import Command # Импортируем Command для аннотаций

class BaseScreen(ABC):
    """Абстрактный базовый класс для всех экранов."""
    def __init__(self, manager: 'ScreenManager'):
        self.manager = manager
        self.elements: List[Renderable] = []
        self.renderer: Renderer = manager.renderer
        self.command_registry = CommandRegistry()
        self._setup_elements()
        self._setup_commands()
        self._setup_auto_commands()

    @abstractmethod
    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        pass

    @abstractmethod
    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        pass

    def _setup_auto_commands(self) -> None:
        """Автоматическая регистрация команд из реестра."""
        # Явно аннотируем тип возвращаемого значения get_screen_commands
        commands: List['Command'] = get_screen_commands(self.__class__)
        # Явно аннотируем тип переменной command в цикле
        command: 'Command'
        for command in commands:
            self.add_command(command) # <-- Эта строка вызывала ошибку mypy

    def add_command(self, command: 'Command') -> None: # <-- Убедитесь, что тип команды аннотирован здесь
        """
        Добавление команды на экран.
        Args:
            command: Команда для добавления
        """
        self.command_registry.register_command(command)

    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
        # Базовый класс НЕ отрисовывает команды.
        # Это responsibility конкретных экранов или миксинов.
        # Отрисовка команд убрана отсюда.

    def handle_input(self, key: int) -> None:
        """
        Обработка ввода пользователя.
        Args:
            key: Нажатая клавиша
        """
        # Пытаемся выполнить команду, если не удалось - вызываем обработчик по умолчанию
        if not self.command_registry.execute_command(key, self):
            self._handle_unregistered_key(key)

    def _handle_unregistered_key(self, key: int) -> None:
        """
        Обработка назарегистрированных клавиш.
        Может быть переопределен в подклассах.
        """
        pass

================================================================================
Файл: game/ui/main_screen.py
================================================================================

# game/ui/main_screen.py
"""
Главный экран игры.
Отображает главное меню с возможностью перехода в бой или инвентарь,
а также выход из игры.
"""
import curses
# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.ui.mixins import StandardLayoutMixin
# --------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class MainScreen(BaseScreen, StandardLayoutMixin):
    """Главный экран игры."""

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель, так как они теперь в миксине
        self.elements = [
            # Основные кнопки (визуальное отображение)
            # Смещаем Y на +2, так как шапка занимает первые 2 строки
            Text("[1] Начать бой", 5, 2, color=Color.GREEN, bold=True),
            Text("[2] Инвентарь", 5, 3, color=Color.YELLOW),
            Text("[3] Настройки", 5, 4, color=Color.MAGENTA, dim=True),
            # Separator(6, color=Color.BLUE), # Убираем старый разделитель
            # Кнопка выхода
            Text("[q] Выйти из игры", 20, 6, color=Color.RED, dim=True),
            # Информационное сообщение
            Text("Используйте клавиши 1, 2, 3 для навигации", 2, 8, dim=True),
            Text("Нажмите 'q' для выхода", 2, 9, dim=True)
            # Нижний разделитель и команды теперь тоже из миксина
        ]

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Все команды добавятся автоматически из реестра!
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        
        # Отрисовка стандартного макета (шапка + подвал)
        self.render_standard_layout("=== ГЛАВНОЕ МЕНЮ ===")
        
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
            
        self.renderer.refresh() # Не забываем refresh в конце конкретного render

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        pass


================================================================================
Файл: game/ui/__init__.py
================================================================================

# game/ui/__init__.py
"""
Пакет пользовательского интерфейса игры.

Содержит все компоненты для отображения и взаимодействия с пользователем.
"""

# Импортируем основные компоненты для удобства
from .screen_manager import ScreenManager
from .base_screen import BaseScreen

__all__ = [
    'ScreenManager',
    'BaseScreen'
]

================================================================================
Файл: game/ui/inventory_screen.py
================================================================================

# game/ui/inventory_screen.py
"""
Экран инвентаря.
Отображает содержимое инвентаря игрока.
"""
import curses
# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.ui.mixins import StandardLayoutMixin
# --------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class InventoryScreen(BaseScreen, StandardLayoutMixin):
    """Экран инвентаря."""

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель
        self.elements = [
            # Предметы инвентаря (смещаем Y на +2)
            Text("• Меч (+10 ATK)", 2, 2, color=Color.WHITE),           # Смещаем Y
            Text("• Зелье лечения", 2, 3, color=Color.GREEN, dim=True), # Смещаем Y
            Text("• Ключ от сундука", 2, 4, color=Color.CYAN, dim=True), # Смещаем Y
            Text("• Свиток телепортации", 2, 5, color=Color.MAGENTA, dim=True), # Смещаем Y
            # Separator(7, "-", 40, Color.WHITE, dim=True), # Убираем старый разделитель
            # Статистика (смещаем Y)
            Text("Всего предметов: 4", 2, 7, dim=True), # Смещаем Y
            Text("Занято: 4/20", 2, 8, dim=True),       # Смещаем Y
            # Separator(10, color=Color.YELLOW), # Убираем старый разделитель
        ]

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Команды из реестра добавятся автоматически!
        # Здесь можно добавить специфичные для этого экрана команды
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        
        # Отрисовка стандартного макета
        self.render_standard_layout("=== ИНВЕНТАРЬ ===")
        
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
            
        self.renderer.refresh() # Не забываем refresh

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        pass


================================================================================
Файл: game/ui/mixins.py
================================================================================

# game/ui/mixins.py
"""Миксины для повторно используемой функциональности экранов."""

from typing import TYPE_CHECKING, Protocol

from game.ui.command_system import CommandRenderer
from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Separator, Text

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen
    from game.ui.command_system.command import CommandRegistry
    from game.ui.rendering.renderer import Renderer


# Протокол, описывающий интерфейс для классов, использующих миксины
class LayoutProtocol(Protocol):
    """Протокол для классов с методами отрисовки шапки и подвала."""

    renderer: 'Renderer'  # type: ignore # Будет определен в BaseScreen
    command_registry: 'CommandRegistry'  # type: ignore # Будет определен в BaseScreen

    def render_header(self, title: str) -> None: ...
    def render_footer(self) -> None: ...


class HeaderMixin:
    """Миксин для отрисовки стандартной шапки экрана."""

    def render_header(self: LayoutProtocol, title: str) -> None:
        """
        Отрисовка стандартной шапки экрана.

        Args:
            title: Текст заголовка.
        """
        # Центрируем заголовок
        # Используем getattr для доступа к атрибутам через протокол
        renderer = getattr(self, 'renderer')
        title_x = max(0, (renderer.width - len(title)) // 2)
        header_text = Text(title, title_x, 0, bold=True, color=Color.CYAN)
        header_text.render(renderer)

        # Рисуем разделитель под заголовком
        header_separator = Separator(1, color=Color.DEFAULT)
        header_separator.render(renderer)


class FooterMixin:
    """Миксин для отрисовки стандартного подвала экрана."""

    def render_footer(self: LayoutProtocol) -> None:
        """
        Отрисовка стандартного подвала экрана.
        Получает команды из command_registry и отрисовывает их.
        """
        # Получаем команды для отрисовки
        command_registry = getattr(self, 'command_registry')
        renderer = getattr(self, 'renderer')
        commands = command_registry.get_all_commands()

        # Рассчитываем позиции подвала
        footer_separator_y = max(0, renderer.height - 2)
        commands_y = max(0, renderer.height - 1)

        # Отрисовка разделителя подвала
        footer_separator = Separator(footer_separator_y, color=Color.GRAY)
        footer_separator.render(renderer)

        # Отрисовка команд в последней строке
        footer_command_renderer = CommandRenderer(y=commands_y)
        command_elements = footer_command_renderer.render_commands(commands)
        for element in command_elements:
            element.render(renderer)


# Можно также создать комбинированный миксин для удобства
class StandardLayoutMixin(HeaderMixin, FooterMixin):
    """Миксин, объединяющий стандартную шапку и подвал."""

    def render_standard_layout(self: LayoutProtocol, title: str) -> None:
        """
        Отрисовка стандартного макета экрана (шапка + подвал).

        Args:
            title: Текст заголовка.
        """
        # Теперь mypy знает, что у self есть эти методы благодаря LayoutProtocol
        self.render_header(title)
        self.render_footer()


================================================================================
Файл: game/ui/screen_manager.py
================================================================================

# game/ui/screen_manager.py
"""Управление экранами игры.
Реализует паттерн Состояние для переключения между экранами."""

import curses
from typing import Dict, Type, List, TYPE_CHECKING

from game.ui.base_screen import BaseScreen
from game.ui.battle_screen import BattleScreen
from game.ui.inventory_screen import InventoryScreen
from game.ui.main_screen import MainScreen
from game.ui.rendering.color_manager import ColorManager
from game.ui.rendering.renderer import Renderer

# Импортируем GameManager только для аннотаций типов, чтобы избежать циклических импортов
if TYPE_CHECKING:
    from game.game_manager import GameManager


class ScreenManager:
    """Управление экранами игры с использованием паттерна состояние."""

    def __init__(self, stdscr: curses.window, game_manager: 'GameManager') -> None:
        """
        Инициализация менеджера экранов.

        Args:
            stdscr: Окно curses.
            game_manager: Экземпляр GameManager, содержащий все игровые сущности.
        """
        self.stdscr = stdscr
        self.game_manager = game_manager # Сохраняем ссылку на GameManager

        self.color_manager = ColorManager()
        self.color_manager.initialize(stdscr)

        # Инициализируем renderer, он получит начальный размер
        self.renderer = Renderer(stdscr, self.color_manager)

        # Словарь доступных экранов (имя -> класс)
        self.screens: Dict[str, Type[BaseScreen]] = {
            "main": MainScreen,
            "battle": BattleScreen,
            "inventory": InventoryScreen,
        }

        # Стек экранов для управления историей переходов
        self.screen_stack: List[BaseScreen] = []

        # Начинаем с главного экрана, передаем ему ссылку на себя (manager)
        initial_screen = self.screens["main"](self)
        self.screen_stack.append(initial_screen)

    @property
    def current_screen(self) -> BaseScreen:
        """Текущий экран - верхний элемент стека."""
        return self.screen_stack[-1]

    def change_screen(self, screen_name: str) -> None:
        """Переход на новый экран (добавление в стек).

        Args:
            screen_name: Имя экрана для перехода.
        """
        if screen_name in self.screens:
            # Создаем новый экран, передавая ему ссылку на ScreenManager (self)
            new_screen = self.screens[screen_name](self)
            self.screen_stack.append(new_screen)
        else:
            raise ValueError(f"Неизвестный экран: {screen_name}")

    def go_back(self) -> None:
        """Возврат к предыдущему экрану (выход из стека)."""
        if len(self.screen_stack) > 1:
            self.screen_stack.pop()
        else:
            # Если это последний экран - выходим из приложения
            # TODO: Рассмотреть использование raise SystemExit() вместо exit()
            exit()

    def _update_renderer_for_all_screens(self) -> None:
        """Обновляет renderer для всех экранов в стеке."""
        # Создаём НОВЫЙ экземпляр renderer с текущими размерами stdscr
        # curses.update_lines_cols() не всегда нужно, зависит от терминала
        height, width = self.stdscr.getmaxyx()
        
        # ВАЖНО: Создаем новый экземпляр Renderer, а не пытаемся обновить старый
        self.renderer = Renderer(self.stdscr, self.color_manager)
        # Примечание: Вызов update_size(width, height) не нужен, так как
        # конструктор Renderer уже должен получить размеры из stdscr.

        # Передаём новый renderer всем экранам в стеке
        for screen in self.screen_stack:
            screen.renderer = self.renderer

    def run(self) -> None:
        """Основной цикл работы менеджера экранов."""
        while True:
            # Получаем текущий экран
            current = self.current_screen

            # Обновляем размеры renderer, если размер окна изменился
            # curses.update_lines_cols() не всегда нужно, зависит от терминала
            height, width = self.stdscr.getmaxyx()
            # Сравниваем с размерами, которые знает renderer
            # Предполагается, что у renderer есть атрибуты width и height,
            # установленные в его __init__
            if hasattr(self.renderer, 'height') and hasattr(self.renderer, 'width'):
                 # Если эти атрибуты есть и отличаются
                 if height != self.renderer.height or width != self.renderer.width:
                     self._update_renderer_for_all_screens()
            else:
                 # Если атрибутов нет, обновляем на всякий случай
                 # или предполагаем, что они устанавливаются в __init__
                 # Возможно, нужно добавить их установку в __init__ Renderer
                 self._update_renderer_for_all_screens()

            # Отрисовываем текущий экран
            current.render(self.stdscr)

            # Обновляем экран
            self.stdscr.refresh()

            # Получаем ввод пользователя
            try:
                key = self.stdscr.getch()
                # Обрабатываем ввод
                current.handle_input(key)
            except KeyboardInterrupt:
                # Обработка Ctrl+C
                exit()
            except Exception as e:
                # Логирование или обработка других исключений
                # Пока просто выходим
                print(f"Критическая ошибка: {e}")
                exit()


================================================================================
Файл: game/ui/battle_screen.py
================================================================================

# game/ui/screens/battle_screen.py
"""Экран боя.
Отображает боевую сцену с возможностью взаимодействия."""
import curses
from typing import TYPE_CHECKING, Dict, Any, Optional, List, Tuple

# - ДОБАВЛЯЕМ ИМПОРТ МИКСИНА -
from game.ui.mixins import StandardLayoutMixin
# -
from game.ui.base_screen import BaseScreen
from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Text, Separator
# - ИМПОРТИРУЕМ НОВЫЕ КОМПОНЕНТЫ -
from game.ui.components.battle_components import (PlayerGroupPanel, EnemyGroupPanel, BattleLog)
# -
from game.ui.base_screen import BaseScreen
from game.ui.rendering.color_manager import Color
# Импортируем get_game_manager для использования внутри _setup_elements
from game.game_manager import get_game_manager

# - ДОБАВЛЯЕМ ИМПОРТ ДЛЯ TYPE_CHECKING -
if TYPE_CHECKING:
    from game.ui.screen_manager import ScreenManager
    from game.entities.player import Player
    from game.entities.monster import Monster
    from game.ui.rendering.renderer import Renderer
# ---


class BattleScreen(BaseScreen, StandardLayoutMixin):
    """Экран боя."""

    # --- Константы для макета ---
    HEADER_HEIGHT = 2
    #UNITS_Y_OFFSET = 1 # Отступ блока юнитов от заголовка
    UNITS_HEIGHT = 5 # Фиксированная высота блока юнитов
    #LOG_Y_OFFSET = 1 # Отступ лога от блока юнитов
    FOOTER_Y_OFFSET = 2 # Отступ подвала от низа лога
    HORIZONTAL_MARGIN = 1 # Отступы слева и справа
    GROUPS_GAP = 1 # Зазор между группами игроков и врагов
    MIN_LOG_HEIGHT = 3 # Минимальная высота лога
    MIN_LOG_WIDTH = 10 # Минимальная ширина лога
    # --- Конец констант ---

    def __init__(self, manager: 'ScreenManager'):
        # Инициализируем атрибуты для компонентов
        # Они будут инициализированы в _setup_elements
        self.player_group: Optional[PlayerGroupPanel] = None
        self.enemy_group: Optional[EnemyGroupPanel] = None
        self.battle_log: Optional[BattleLog] = None
        # Вызываем родительский конструктор
        # _setup_elements будет вызван внутри него
        super().__init__(manager)

    def _recalculate_layout(self, screen_width: int, screen_height: int) -> Dict[str, Dict[str, int]]:
        """
        Пересчитывает размеры и позиции всех основных компонентов экрана боя.

        Args:
            screen_width: Текущая ширина экрана.
            screen_height: Текущая высота экрана.

        Returns:
            Словарь с ключами 'player_group', 'enemy_group', 'battle_log',
            каждый из которых содержит словарь {'x', 'y', 'width', 'height'}.
        """
        # --- Размеры и позиции ---
        units_y = self.HEADER_HEIGHT #+ self.UNITS_Y_OFFSET

        # --- Расчет ширины для панелей юнитов ---
        # Доступная ширина для блоков юнитов (учитываем отступы и зазор)
        total_units_width = max(
            0,
            screen_width - 2 * self.HORIZONTAL_MARGIN - self.GROUPS_GAP
        )

        # Делим ширину пополам между игроками и монстрами
        half_width = total_units_width // 2
        player_group_width = half_width
        enemy_group_width = total_units_width - player_group_width

        # Координаты X
        player_group_x = self.HORIZONTAL_MARGIN
        enemy_group_x = player_group_x + player_group_width + self.GROUPS_GAP

        # --- Размеры и позиции лога боя ---
        log_x = 0  # self.HORIZONTAL_MARGIN
        log_y = units_y + self.UNITS_HEIGHT #+ self.LOG_Y_OFFSET
        log_width = max(self.MIN_LOG_WIDTH, screen_width * self.HORIZONTAL_MARGIN)

        # Высота лога - всё оставшееся пространство минус отступы и подвал
        available_height = screen_height - log_y - self.FOOTER_Y_OFFSET
        log_height = max(self.MIN_LOG_HEIGHT, available_height)

        return {
            'player_group': {
                'x': player_group_x,
                'y': units_y,
                'width': player_group_width,
                'height': self.UNITS_HEIGHT
            },
            'enemy_group': {
                'x': enemy_group_x,
                'y': units_y,
                'width': enemy_group_width,
                'height': self.UNITS_HEIGHT
            },
            'battle_log': {
                'x': log_x,
                'y': log_y,
                'width': log_width,
                'height': log_height
            }
        }

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        self.elements = [] # Очищаем список, так как компоненты будут отрисовываться напрямую

        # - ПОЛУЧАЕМ ДАННЫЕ ИЗ GameManager НЕПОСРЕДСТВЕННО В _setup_elements -
        # Это решает проблему порядка инициализации
        game_manager = get_game_manager()
        real_enemy_data = game_manager.get_current_enemies()
        real_player_data = game_manager.get_player_group()
        # -

        # Получаем начальные размеры экрана из рендерера
        if self.renderer:
            screen_width = self.renderer.width
            screen_height = self.renderer.height
        else:
            # fallback значения, если renderer еще не готов
            # Используем значения из конфигурации, если они доступны
            try:
                from game.config import get_config
                config = get_config()
                screen_width = config.ui.screen_width
                screen_height = config.ui.screen_height
            except Exception:
                screen_width = 80
                screen_height = 24

        # --- ИСПОЛЬЗУЕМ ОБЩУЮ ЛОГИКУ РАСЧЕТА ---
        layout = self._recalculate_layout(screen_width, screen_height)

        # Создаем панели с рассчитанными размерами
        self.player_group = PlayerGroupPanel(
            x=layout['player_group']['x'],
            y=layout['player_group']['y'],
            width=layout['player_group']['width'],
            height=layout['player_group']['height'],
            players=real_player_data  # Передаем данные игроков
        )

        self.enemy_group = EnemyGroupPanel(
            x=layout['enemy_group']['x'],
            y=layout['enemy_group']['y'],
            width=layout['enemy_group']['width'],
            height=layout['enemy_group']['height'],
            enemies=real_enemy_data  # Передаем данные врагов
        )

        # Инициализируем лог боя
        self.battle_log = BattleLog(
            x=layout['battle_log']['x'],
            y=layout['battle_log']['y'],
            width=layout['battle_log']['width'],
            height=layout['battle_log']['height']
        )
        # Добавляем тестовые сообщения в лог
        # TODO: Заменить на реальные сообщения из игровой логики
        self.battle_log.add_message("Битва начинается!")
        # ---

    def _update_component_sizes(self) -> None:
        """Обновление размеров компонентов."""
        if not self.renderer:
            return

        # Получаем текущие размеры экрана
        screen_width = self.renderer.width
        screen_height = self.renderer.height

        # --- ИСПОЛЬЗУЕМ ОБЩУЮ ЛОГИКУ РАСЧЕТА ---
        layout = self._recalculate_layout(screen_width, screen_height)
        # ---

        # Обновляем размеры и позиции панелей групп
        if self.player_group:
            self.player_group.x = layout['player_group']['x']
            self.player_group.y = layout['player_group']['y'] # Обновляем Y тоже
            self.player_group.width = layout['player_group']['width']
            self.player_group.height = layout['player_group']['height']
            # Обновляем размеры дочерних компонентов групп
            # _update_panels будет использовать новые self.x, self.width
            self.player_group._update_panels() 

        if self.enemy_group:
            self.enemy_group.x = layout['enemy_group']['x']
            self.enemy_group.y = layout['enemy_group']['y'] # Обновляем Y тоже
            self.enemy_group.width = layout['enemy_group']['width']
            self.enemy_group.height = layout['enemy_group']['height']
            # Обновляем размеры дочерних компонентов групп
            # _update_panels будет использовать новые self.x, self.width
            self.enemy_group._update_panels()

        # Обновляем размеры и позиции лога боя
        if self.battle_log:
            self.battle_log.x = layout['battle_log']['x']
            self.battle_log.y = layout['battle_log']['y']
            self.battle_log.width = layout['battle_log']['width']
            self.battle_log.height = layout['battle_log']['height']
            # BattleLog не имеет сложной внутренней структуры панелей,
            # поэтому явный вызов update_size не требуется.
            # Если бы требовался, нужно было бы проверить сигнатуру метода в BattleLog.

        # --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ ---

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Все команды добавятся автоматически из реестра!
        pass

    # - ОБНОВЛЯЕМ МЕТОД render -
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        # Обновляем размеры компонентов перед отрисовкой
        self._update_component_sizes()
        self.renderer.clear()

        # Отрисовка стандартного макета (шапка + подвал)
        self.render_standard_layout("=== БОЙ ===")

        # - ОТРИСОВКА НОВЫХ КОМПОНЕНТОВ -
        # Отрисовываем компоненты напрямую
        if self.player_group:
            self.player_group.render(self.renderer)
        if self.enemy_group:
            self.enemy_group.render(self.renderer)
        if self.battle_log:
            self.battle_log.render(self.renderer)
        # -
        self.renderer.refresh() # Не забываем refresh

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        # Обработка прокрутки лога
        if key == curses.KEY_UP:
            if self.battle_log:
                self.battle_log.scroll_up()
        elif key == curses.KEY_DOWN:
            if self.battle_log:
                self.battle_log.scroll_down()
        # Можно добавить отладочный вывод
        # print(f"BattleScreen: Нажата незарегистрированная клавиша: {key}")


================================================================================
Файл: game/entities/character.py
================================================================================

# game/entities/character.py
"""Базовый класс персонажа в игре."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable, TYPE_CHECKING
from game.protocols import (
    Stats, 
    Attributes,
    AbilityManagerProtocol, 
    StatusEffectManagerProtocol,
    Ability,
    StatusEffect
)
from game.config import get_config # Импортируем get_config для SimpleAttributes

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType

# ==================== Вспомогательные классы ====================

@dataclass
class CharacterConfig:
    """Конфигурация для создания персонажа."""
    
    # Базовые параметры
    name: str
    role: str
   
    # Параметры для системы уровней/характеристик
    base_stats: Dict[str, int]
    growth_rates: Dict[str, float]
    level: int = 1
    is_player: bool = field(default=False)

    class_icon: str = "?"
    class_icon_color: str = ""
    description: str = ""
    starting_abilities: List[str] = field(default_factory=list)

    # Внедрение зависимостей через конструктор
    stats_factory: Optional[Callable[[], 'Stats']] = None
    attributes_factory: Optional[Callable[['CharacterType'], 'Attributes']] = None
    ability_manager_factory: Optional[Callable[['CharacterType'], 'AbilityManagerProtocol']] = None
    status_effect_manager_factory: Optional[Callable[['CharacterType'], 'StatusEffectManagerProtocol']] = None

class SimpleStats:
    """Простая реализация базовых характеристик."""
    def __init__(self):
        self.strength = 0
        self.agility = 0
        self.intelligence = 0
        self.vitality = 0

class SimpleAttributes:
    """Простая реализация производных атрибутов."""
    def __init__(self, character: 'CharacterType', stats: Stats):
        self.character = character
        self.stats = stats
        config = get_config() # Получаем конфигурацию
        
        # Расчет производных атрибутов с использованием настроек
        self.max_hp = config.character.base_max_hp + (stats.vitality * config.character.hp_per_vitality)
        self.max_energy = config.character.base_max_energy + (stats.intelligence * config.character.energy_per_intelligence)
        self.attack_power = stats.strength * config.character.attack_per_strength
        self.defense = int(stats.agility * config.character.defense_per_agility)

    def recalculate(self, stats: Stats) -> None:
        """
        Пересчитать атрибуты на основе новых базовых характеристик.
        Это реализация метода, требуемого протоколом Attributes.
        """
        config = get_config()
        # Повторяем логику расчета из __init__
        self.max_hp = config.character.base_max_hp + (stats.vitality * config.character.hp_per_vitality)
        self.max_energy = config.character.base_max_energy + (stats.intelligence * config.character.energy_per_intelligence)
        self.attack_power = stats.strength * config.character.attack_per_strength
        self.defense = int(stats.agility * config.character.defense_per_agility)
        # Обновляем ссылку на stats
        self.stats = stats

# --- Основной класс персонажа ---
class Character(ABC):
    """Абстрактный базовый класс, представляющий персонажа в игре."""

    def __init__(self, config: CharacterConfig):
        
        self.alive = True
        
        self.name = config.name
        self.role = config.role
        self.level = config.level
        self.is_player = config.is_player

        self.class_icon = config.class_icon
        self.class_icon_color = config.class_icon_color

        self.base_stats_dict = config.base_stats
        self.growth_rates_dict = config.growth_rates

        # Создаем фабрики по умолчанию если не предоставлены
        # Это позволяет подклассам переопределить их или использовать реализацию по умолчанию
        if config.stats_factory is None:
            stats_factory = self.get_base_stats # Используем реализацию по умолчанию
        if config.attributes_factory is None:
            attributes_factory = self._attributes_factory # Используем реализацию по умолчанию

        # Инициализация характеристик
        self.stats: Stats = stats_factory()
        self.attributes: Attributes = attributes_factory(self)

        # Инициализируем hp и энергию
        self.hp = self.attributes.max_hp
        self.energy = self.attributes.max_energy

        # Менеджеры (внедрение зависимостей)
        self._ability_manager: Optional[AbilityManagerProtocol] = None
        if config.ability_manager_factory:
            self._ability_manager = config.ability_manager_factory(self)

        self._status_manager: Optional[StatusEffectManagerProtocol] = None
        if config.status_effect_manager_factory:
            self._status_manager = config.status_effect_manager_factory(self)

    # ==================== Вспомогательные методы для фабрик (по умолчанию) ====================
    # Переносим из Player/Monster
    def _attributes_factory(self, character: 'CharacterType') -> Attributes:
        """Фабрика по умолчанию для создания атрибутов."""
        return self.calculate_attributes()

    # ==================== Абстрактные методы (частично реализованы) ====================
    # Реализация по умолчанию перенесена из Player/Monster
    def get_base_stats(self) -> Stats:
        """Возвращает базовые характеристики персонажа. Реализация по умолчанию."""
        stats = SimpleStats()
        # Масштабируем базовые характеристики в соответствии с уровнем
        level_multiplier = self.level * 0.1
        stats.strength = int(self.base_stats_dict.get('strength', 10) * 
                           (1 + level_multiplier * self.growth_rates_dict.get('strength', 1.0)))
        stats.agility = int(self.base_stats_dict.get('agility', 10) * 
                          (1 + level_multiplier * self.growth_rates_dict.get('agility', 1.0)))
        stats.intelligence = int(self.base_stats_dict.get('intelligence', 10) * 
                               (1 + level_multiplier * self.growth_rates_dict.get('intelligence', 1.0)))
        stats.vitality = int(self.base_stats_dict.get('vitality', 10) * 
                           (1 + level_multiplier * self.growth_rates_dict.get('vitality', 1.0)))
        return stats

    def calculate_attributes(self) -> Attributes:
        """Вычисляет атрибуты персонажа на основе его характеристик и уровня. Реализация по умолчанию."""
        # Используем SimpleAttributes, который требует get_config()
        return SimpleAttributes(self, self.stats)

    # ==================== Уровень и характеристики ====================
    # Логика level_up остается здесь, но может быть расширена в подклассах
    def level_up(self) -> List[Dict[str, Any]]:
        """
        Повышает уровень персонажа.
        Возвращает список сообщений/результатов.
        """
        self.level += 1

        # Сохраняем текущие проценты HP и энергии
        hp_ratio = self.hp / self.attributes.max_hp if self.attributes.max_hp > 0 else 1.0
        energy_ratio = self.energy / self.attributes.max_energy if self.attributes.max_energy > 0 else 1.0

        # Пересчитываем характеристики и атрибуты через методы (которые могут быть переопределены)
        try:
            self.stats = self.get_base_stats()
            self.attributes = self.calculate_attributes()
        except NotImplementedError:
            # fallback если абстрактные методы не реализованы корректно
            pass

        # Обновляем текущие значения с учетом новых максимумов
        self.hp = max(1, int(self.attributes.max_hp * hp_ratio))
        self.energy = int(self.attributes.max_energy * energy_ratio)

        return [{"type": "level_up", "message": f"{self.name} достиг уровня {self.level}!"}]

    # ==================== Свойства ====================
    @property
    def ability_manager(self) -> Optional[AbilityManagerProtocol]:
        """Получение менеджера способностей."""
        return self._ability_manager

    @property
    def status_manager(self) -> Optional[StatusEffectManagerProtocol]:
        """Получение менеджера статус-эффектов."""
        return self._status_manager

    # ==================== Основные методы персонажа ====================
    def is_alive(self) -> bool:
        """Проверяет, жив ли персонаж."""
        return self.alive

    def get_level(self) -> int:
        """Возвращает уровень персонажа."""
        return self.level

    def on_death(self) -> List[Dict[str, Any]]:
        """
        Вызывается при смерти персонажа. 
        Возвращает список сообщений/результатов.
        """
        results = []

        # Очищаем все активные статус-эффекты
        if self._status_manager is not None:
            clear_results = self._status_manager.clear_all_effects()
            results.extend(clear_results)

        # Добавляем сообщение о смерти
        results.append({"type": "death", "message": f"{self.name} погибает!"})
        return results

    # ==================== Боевые методы ====================
    def take_damage(self, damage: int) -> List[Dict[str, Any]]:
        """
        Наносит урон персонажу, учитывая защиту.
        Возвращает список сообщений/результатов.
        """
        results = []
        # Учитываем защиту из attributes.defense
        actual_damage = max(0, damage - self.attributes.defense // 2)  # Может быть 0 урон
        actual_damage = max(1, actual_damage) if damage > 0 else 0  # Минимум 1 урон если был урон

        self.hp -= actual_damage
        results.append({
            "type": "damage_taken", 
            "target": self.name, 
            "damage": actual_damage,
            "hp_left": self.hp
        })

        if self.hp <= 0:
            self.hp = 0
            if self.alive:  # Проверяем, чтобы не вызывать on_death дважды
                self.alive = False
                death_results = self.on_death()
                results.extend(death_results)

        return results

    def take_heal(self, heal_amount: int) -> List[Dict[str, Any]]:
        """
        Исцеляет персонажа и возвращает список сообщений/результатов.
        """
        results = []
        old_hp = self.hp
        self.hp = min(self.attributes.max_hp, self.hp + heal_amount)
        actual_heal = self.hp - old_hp
        results.append({
            "type": "healed", 
            "target": self.name, 
            "heal_amount": actual_heal,
            "hp_now": self.hp
        })
        return results

    # ==================== Энергия ====================
    def restore_energy(self, amount: Optional[int] = None, percentage: Optional[float] = None) -> List[Dict[str, Any]]:
        """
        Восстанавливает энергию персонажа.
        :param amount: конкретное количество энергии для восстановления
        :param percentage: процент от максимальной энергии для восстановления
        Возвращает список сообщений/результатов.
        """
        results = []
        old_energy = self.energy

        if percentage is not None:
            restore_amount = int(self.attributes.max_energy * (percentage / 100.0))
            self.energy = min(self.attributes.max_energy, self.energy + restore_amount)
        elif amount is not None:
            self.energy = min(self.attributes.max_energy, self.energy + amount)
        else:
            self.energy = self.attributes.max_energy  # Полное восстановление

        actual_restore = self.energy - old_energy
        if actual_restore > 0:
            results.append({
                "type": "energy_restored", 
                "target": self.name, 
                "amount": actual_restore,
                "energy_now": self.energy
            })

        return results

    def spend_energy(self, amount: int) -> bool:
        """
        Тратит энергию персонажа.
        Возвращает True, если энергия была потрачена, иначе False.
        """
        if self.energy >= amount:
            self.energy -= amount
            return True
        return False

    # ==================== Способности ====================
    def add_ability(self, name: str, ability: Ability) -> None:
        """Добавляет способность персонажу."""
        if self._ability_manager:
            self._ability_manager.add_ability(name, ability)

    def get_available_abilities(self) -> List[str]:
        """Получает список доступных способностей."""
        if self._ability_manager:
            return self._ability_manager.get_available_abilities(self)
        return []

    def use_ability(self, name: str, targets: List['CharacterType'], **kwargs) -> List[Dict[str, Any]]:
        """
        Использует способность по имени.
        Возвращает список сообщений/результатов от способности и менеджера.
        """
        results = []
        if self._ability_manager:
            ability_result = self._ability_manager.use_ability(name, self, targets, **kwargs)
            if ability_result:
                if isinstance(ability_result, list):
                    results.extend(ability_result)
                else:
                    results.append(ability_result)
        return results

    def update_ability_cooldowns(self) -> None:
        """Обновляет кулдауны способностей в конце раунда."""
        if self._ability_manager:
            self._ability_manager.update_cooldowns()

    # ==================== Статус-эффекты ====================
    def add_status_effect(self, effect: StatusEffect) -> List[Dict[str, Any]]:
        """Добавляет статус-эффект персонажу. Возвращает результат от менеджера."""
        if self._status_manager:
            return [self._status_manager.add_effect(effect)]
        return []

    def remove_status_effect(self, effect_name: str) -> List[Dict[str, Any]]:
        """Удаляет статус-эффект по имени. Возвращает результат."""
        results = []
        if self._status_manager:
            success = self._status_manager.remove_effect(effect_name)
            if success:
                results.append({"type": "effect_removed", "effect": effect_name, "target": self.name})
            else:
                results.append({"type": "error", "message": f"Эффект {effect_name} не найден у {self.name}"})
        return results

    def update_status_effects(self) -> List[Dict[str, Any]]:
        """Обновляет все активные статус-эффекты. Возвращает список результатов."""
        if self._status_manager:
            return self._status_manager.update_effects()
        return []

    def has_status_effect(self, effect_name: str) -> bool:
        """Проверяет, есть ли у персонажа определенный статус-эффект."""
        if self._status_manager:
            return self._status_manager.has_effect(effect_name)
        return False

    def get_active_status_effects(self) -> List[StatusEffect]:
        """Возвращает список всех активных статус-эффектов."""
        if self._status_manager:
            return self._status_manager.get_all_effects()
        return []


================================================================================
Файл: game/entities/monster.py
================================================================================

# game/entities/monster.py
"""Класс монстра (персонажа, НЕ управляемого игроком)."""
from dataclasses import dataclass, field
from typing import Optional, TYPE_CHECKING
from game.entities.character import Character, CharacterConfig # Импортируем вспомогательные классы

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType


@dataclass
class MonsterConfig(CharacterConfig):
    is_player: bool = field(default=False)

# - Фабричная функция для создания монстра из JSON -
def create_monster_from_data(
    role: str,
    name: str,
    level: int = 1,
    data_directory: str = "game/data/characters/monster_classes"
) -> Optional['Monster']:
    """
    Создает объект Monster на основе данных из JSON файла.

    Args:
        name: Имя монстра.
        role: Внутренний идентификатор класса (должен совпадать с именем .json файла).
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Объект Monster или None, если данные не могут быть загружены.
    """
    try:
        from game.data.character_loader import load_monster_class_data
    except ImportError as e:
        print(f"Ошибка импорта character_loader внутри create_monster_from_data: {e}")
        return None

    config_data = load_monster_class_data(role, data_directory)
    if not config_data:
        print(f"Не удалось загрузить данные для класса монстра '{role}'")
        return None

    try:
        config = MonsterConfig(**config_data)
        config.name = name if name else config.name
        return Monster(config)

    except Exception as e:
        print(f"Ошибка создания монстра {name} класса {role}: {e}")
        import traceback
        traceback.print_exc()
        return None

# --- Основной класс монстра ---

class Monster(Character):
    """Класс для всех монстров (персонажей, НЕ управляемых игроком)."""

    def __init__(self, config: MonsterConfig):  
        super().__init__(config=config)



================================================================================
Файл: game/entities/player.py
================================================================================

# game/entities/player.py
"""Класс игрока (персонажа, управляемого игроком)."""
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable, TYPE_CHECKING
from game import config
from game.entities.character import Character, CharacterConfig, SimpleStats, SimpleAttributes # Импортируем вспомогательные классы
from game.protocols import (
    Stats,
    Attributes,
    AbilityManagerProtocol,
    StatusEffectManagerProtocol,
    ExperienceCalculatorProtocol,
    LevelUpHandlerProtocol
)

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType

@dataclass
class PlayerConfig(CharacterConfig):
    is_player: bool = field(default=True)
    exp_calculator: Optional[ExperienceCalculatorProtocol] = None
    level_up_handler: Optional[LevelUpHandlerProtocol] = None
    

# - Фабричная функция для создания игрока из JSON -
def create_player_from_data(
    role: str,
    name: str,
    level: int = 1,
    data_directory: str = "game/data/characters/player_classes"
    ) -> Optional['Player']:
    """
    Создает объект Player на основе данных из JSON файла.

    Args:
        name: Имя персонажа.
        role: Внутренний идентификатор класса (должен совпадать с именем .json файла).
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Объект Player или None, если данные не могут быть загружены.
    """
    try:
        from game.data.character_loader import load_player_class_data
    except ImportError as e:
        print(f"Ошибка импорта character_loader внутри create_player_from_data: {e}")
        return None

    config_data = load_player_class_data(role, data_directory)
    if not config_data:
        print(f"Не удалось загрузить данные для класса '{role}'")
        return None

    try:
        config = PlayerConfig(**config_data)
        config.name = name if name else config.name
        return Player(config)

    except Exception as e:
        print(f"Ошибка создания персонажа {name} класса {role}: {e}")
        import traceback
        traceback.print_exc()
        return None

# --- Основной класс игрока ---

class Player(Character):
    """Класс для всех игроков (персонажей, управляемых игроком)."""

    def __init__(self, config: PlayerConfig):

        super().__init__(config=config)

        # Инициализируем систему опыта
        self.exp_calculator = config.exp_calculator if config.exp_calculator else SimpleExperienceCalculator()
        self.level_up_handler = config.level_up_handler if config.level_up_handler else SimpleLevelUpHandler()
        self.exp = 0
        self.exp_to_next_level = 0
        
        # Рассчитываем опыт для следующего уровня
        self.calculate_exp_for_next_level()

    # ==================== Уровень и характеристики (расширение) ====================
    # Переопределяем level_up, чтобы добавить логику опыта
    def level_up(self) -> List[Dict[str, Any]]:
        """
        Повышает уровень персонажа (игрока).
        Возвращает список сообщений/результатов.
        """
        # Вызываем родительский метод level_up
        results = super().level_up()
        
        # Пересчитываем опыт для следующего уровня
        self.calculate_exp_for_next_level()
        
        return results

    # ==================== Свойства ====================
    @property
    def experience_to_next_level(self) -> int:
        """Получение опыта, необходимого для следующего уровня."""
        return self.exp_to_next_level

    # ==================== Система опыта ====================
    def calculate_exp_for_next_level(self) -> None:
        """
        Рассчитывает количество опыта, необходимого для следующего уровня.
        """
        self.exp_to_next_level = self.exp_calculator.calculate_exp_for_next_level(self.level)

    def gain_experience(self, exp_amount: int) -> List[Dict[str, Any]]:
        """
        Добавляет опыт игроку и проверяет на повышение уровня.
        Возвращает список сообщений/результатов.
        """
        results = []
        self.exp += exp_amount
        results.append({
            "type": "exp_gained",
            "character": self.name,
            "exp_amount": exp_amount,
            "total_exp": self.exp
        })

        # Проверяем, достаточно ли опыта для повышения уровня
        while self.exp >= self.exp_to_next_level:
            # Сбрасываем опыт, использованный для повышения уровня
            self.exp -= self.exp_to_next_level
            
            # Повышаем уровень
            level_up_results = self.level_up()
            results.extend(level_up_results)
            
            # Дополнительная обработка повышения уровня
            handler_results = self.level_up_handler.handle_level_up(self)
            results.extend(handler_results)
            
            # Пересчитываем опыт для следующего уровня
            self.calculate_exp_for_next_level()

        return results

# ==================== Вспомогательные классы (специфичные для игрока) ====================

class SimpleExperienceCalculator:
    """Простой калькулятор опыта для следующего уровня."""
    def calculate_exp_for_next_level(self, current_level: int) -> int:
        """Рассчитывает опыт, необходимый для достижения следующего уровня."""
        from game.config import get_config # Локальный импорт для избежания циклических зависимостей на уровне модуля
        config = get_config()
        return int(config.experience.formula_base * (current_level ** config.experience.formula_multiplier))

class SimpleLevelUpHandler:
    """Простой обработчик повышения уровня."""
    def handle_level_up(self, character: 'Character') -> List[Dict[str, Any]]:
        """Обработать повышение уровня и вернуть список результатов."""
        results = []
        old_hp = character.hp
        character.hp = character.attributes.max_hp
        hp_restored = character.hp - old_hp
        
        old_energy = character.energy
        character.energy = character.attributes.max_energy
        energy_restored = character.energy - old_energy
        
        results.append({
            "type": "level_up_heal",
            "character": character.name,
            "hp_restored": hp_restored,
            "energy_restored": energy_restored
        })
        
        return results


================================================================================
Файл: game/data/character_loader.py
================================================================================

# game/data/character_loader.py
"""Загрузчик данных персонажей из JSON файлов."""

import json
import os
from typing import Dict, Any, Optional, TYPE_CHECKING

# Используем TYPE_CHECKING для аннотаций без циклического импорта на уровне модуля
if TYPE_CHECKING:
    from game.config import GameConfig # Для аннотаций


# --- Вспомогательные (приватные) функции ---
def _get_default_data_directory(is_player: bool) -> str:
    """
    Получает путь к директории данных по умолчанию из конфигурации.

    Args:
        is_player: Если True, возвращает путь для игроков.
                   Если False, возвращает путь для монстров.

    Returns:
        Путь к директории данных.
    """
    from game.config import get_config # Локальный импорт
    config: 'GameConfig' = get_config()

    if is_player:
        return config.system.player_classes_directory
    else:
        return config.system.monster_classes_directory


def _load_character_data_from_file(
    role: str, 
    data_directory: str
    ) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса персонажа из JSON файла.

    Args:
        role: Внутренний идентификатор класса (например, "berserker", "goblin").
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Словарь с данными класса или None, если файл не найден или произошла ошибка.
    """
    filename = f"{role}.json"
    filepath = os.path.join(data_directory, filename)

    # Проверяем, существует ли файл
    if not os.path.exists(filepath):
        # Пробуем относительный путь от корня проекта, если предыдущий не сработал
        # Это может помочь, если скрипт запускается не из корня проекта
        try:
            # Получаем путь к корню проекта (предполагаем, что loader.py находится в game/data/)
            # os.path.abspath(__file__) дает полный путь к этому файлу
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
            filepath = os.path.join(project_root, data_directory, filename)
            if not os.path.exists(filepath):
                print(f"Файл данных для класса '{role}' не найден: {filepath}")
                return None
        except Exception as e:
            print(f"Ошибка при определении пути к файлу {filename}: {e}")
            return None

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return data
    except json.JSONDecodeError as e:
        print(f"Ошибка декодирования JSON в файле {filepath}: {e}")
        return None
    except Exception as e:
        print(f"Неизвестная ошибка при загрузке {filepath}: {e}")
        return None


# --- Публичные функции для игроков ---
def load_player_class_data(
    role: str, 
    data_directory: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса игрока из JSON файла.

    Args:
        role: Внутренний идентификатор класса (например, "berserker").
        data_directory: Путь к директории с JSON файлами.
                        Если None, используется путь из конфигурации.

    Returns:
        Словарь с данными класса или None, если файл не найден.
    """
    if data_directory is None:
        data_directory = _get_default_data_directory(is_player=True)
        
    return _load_character_data_from_file(role, data_directory)


# --- Публичные функции для монстров ---
def load_monster_class_data(
    role: str, 
    data_directory: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса монстра из JSON файла.

    Args:
        role: Внутренний идентификатор класса монстра (например, "goblin").
        data_directory: Путь к директории с JSON файлами.
                        Если None, используется путь из конфигурации.

    Returns:
        Словарь с данными класса или None, если файл не найден.
    """
    if data_directory is None:
        data_directory = _get_default_data_directory(is_player=False)
        
    return _load_character_data_from_file(role, data_directory)


================================================================================
Файл: game/factories/__init__.py
================================================================================



================================================================================
Файл: game/factories/monster_factory.py
================================================================================

# game/factories/monster_factory.py
"""Фабрика для создания монстров.

Предоставляет функции для создания экземпляров класса Monster
на основе данных из JSON файлов.
"""

from typing import TYPE_CHECKING, Optional, Union
from game.naming.template_namer import generate_monster_name
from game.data.character_loader import _get_default_data_directory

if TYPE_CHECKING:
    from game.entities.monster import Monster

def create_monster(
    role: str,
    name: Optional[str] = None,
    level: int = 1,
    data_directory: Optional[str] = None
) -> Union['Monster', None]:
    """
    Создает монстра по его роли (типу).

    Args:
        role: Внутренний идентификатор класса монстра (должен совпадать с именем .json файла).
        name: Имя монстра. Если None или пустая строка, будет сгенерировано автоматически.
        level: Уровень монстра.
        data_directory: Путь к директории с JSON файлами классов монстров.

    Returns:
        Объект Character (Monster) или None, если данные не могут быть загружены.
    """

    if data_directory is None:
        data_directory = _get_default_data_directory(is_player=False)

    if not name or not name.strip():
        name = generate_monster_name(role)


    # Импортируем внутри функции
    from game.entities.monster import create_monster_from_data as _internal_create
    return _internal_create(role=role, name=name, level=level, data_directory=data_directory)


================================================================================
Файл: game/factories/player_factory.py
================================================================================

# game/factories/player_factory.py
"""Фабрика для создания персонажей-игроков.

Предоставляет функции для создания экземпляров класса Player
на основе данных из JSON файлов.
"""

from typing import Optional, TYPE_CHECKING
from game.data.character_loader import _get_default_data_directory

if TYPE_CHECKING:
    from game.entities.player import Player


def create_player(
    role: str,
    name: str, 
    level: int = 1,
    data_directory: Optional[str] = None
    ) -> Optional['Player']:
    """
    Создает объект Player на основе данных из JSON файла.
    Упрощенный интерфейс для game.entities.player.create_player_from_data.

    Args:
        role: Внутренний идентификатор класса.
        name: Имя персонажа.
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.
                        Если None, используется путь из конфигурации.

    Returns:
        Объект Player или None, если данные не могут быть загружены.
    """
    if data_directory is None:
        data_directory = _get_default_data_directory(is_player=True)

    from game.entities.player import create_player_from_data as _internal_create
    return _internal_create(role, name, level, data_directory)


================================================================================
Файл: game/naming/template_namer.py
================================================================================

# game/naming/template_namer.py
"""Генератор имен монстров на основе шаблонов."""

import random
import json
import os
from typing import List, Dict
from game.protocols import MonsterNamerProtocol

class TemplateMonsterNamer(MonsterNamerProtocol):
    """Простой генератор имен монстров, использующий шаблоны и списки слов."""

    def __init__(self, data_directory: str = "game/data/names"):
        """
        Инициализирует генератор.

        Args:
            data_directory: Путь к директории с JSON-файлами слов.
        """
        self.data_directory = data_directory
        self.word_data: Dict[str, List[str]] = {}
        self._load_word_data()

    def _load_word_data(self) -> None:
        """Загружает данные слов из JSON-файлов."""
        self.word_data = {}
        if not os.path.exists(self.data_directory):
            print(f"Предупреждение: Директория данных имен '{self.data_directory}' не найдена.")
            return

        try:
            # Загружаем общие списки слов
            common_files = {
                "adjectives": "adjectives.json",
                "nouns": "nouns.json",
                "prefixes": "prefixes.json",
                "suffixes": "suffixes.json",
            }
            for key, filename in common_files.items():
                filepath = os.path.join(self.data_directory, filename)
                if os.path.exists(filepath):
                    with open(filepath, 'r', encoding='utf-8') as f:
                        self.word_data[key] = json.load(f)
                else:
                    print(f"Предупреждение: Файл данных имен '{filepath}' не найден.")
                    self.word_data[key] = [] # Пустой список по умолчанию

            # Можно добавить загрузку специфичных для роли списков позже
            # Например, monster_role_adjectives.json

        except json.JSONDecodeError as e:
            print(f"Ошибка: Некорректный JSON в файлах имен: {e}")
            self.word_data = {k: [] for k in ["adjectives", "nouns", "prefixes", "suffixes"]}
        except Exception as e:
            print(f"Ошибка при загрузке данных имен: {e}")
            self.word_data = {k: [] for k in ["adjectives", "nouns", "prefixes", "suffixes"]}

    def _get_words(self, category: str) -> List[str]:
        """Получает список слов по категории. Возвращает пустой список, если категория отсутствует."""
        return self.word_data.get(category, [])

    def generate_name(self, monster_role: str) -> str:
        """
        Генерирует имя для монстра на основе его роли.

        Args:
            monster_role: Роль/тип монстра (например, 'goblin', 'dragon').

        Returns:
            Сгенерированное имя.
        """
        # Простые шаблоны
        templates = [
            "{adjective} {noun}",
            "{prefix}{noun}",
            "{noun} {suffix}",
            "{adjective} {prefix}{noun}",
            "{prefix}{noun} {suffix}",
            "{noun}", # Резервный вариант
        ]

        # Можно сделать шаблоны зависимыми от роли в будущем
        # role_templates = self._load_role_templates(monster_role)
        # if role_templates:
        #     templates = role_templates

        template = random.choice(templates)

        # Получаем слова
        adjectives = self._get_words("adjectives")
        nouns = self._get_words("nouns")
        prefixes = self._get_words("prefixes")
        suffixes = self._get_words("suffixes")

        # Словарь для подстановки в шаблон
        replacements = {
            "adjective": random.choice(adjectives) if adjectives else "",
            "noun": random.choice(nouns) if nouns else "Монстр",
            "prefix": random.choice(prefixes) if prefixes else "",
            "suffix": random.choice(suffixes) if suffixes else "",
        }

        # Форматируем имя
        try:
            name = template.format(**replacements).strip()
            # Убираем лишние пробелы, которые могли остаться
            name = " ".join(name.split())
            if not name:
                name = f"{monster_role.capitalize()} {random.randint(1, 1000)}"
            return name
        except KeyError as e:
            # На случай, если в шаблоне будет неизвестный ключ
            print(f"Ошибка форматирования имени: неизвестный ключ {e} в шаблоне '{template}'. Используется резервное имя.")
            return f"{monster_role.capitalize()} {random.randint(1, 1000)}"
        except Exception as e:
            print(f"Неожиданная ошибка при генерации имени: {e}. Используется резервное имя.")
            return f"{monster_role.capitalize()} {random.randint(1, 1000)}"

# --- Глобальный экземпляр для удобства ---
_DEFAULT_NAMER: TemplateMonsterNamer = None # type: ignore

def get_default_namer() -> TemplateMonsterNamer:
    """Получить глобальный экземпляр генератора имен."""
    global _DEFAULT_NAMER
    if _DEFAULT_NAMER is None:
        _DEFAULT_NAMER = TemplateMonsterNamer()
    return _DEFAULT_NAMER

def generate_monster_name(monster_role: str) -> str:
    """
    Удобная функция для генерации имени монстра с использованием
    глобального экземпляра генератора.

    Args:
        monster_role: Роль/тип монстра.

    Returns:
        Сгенерированное имя.
    """
    return get_default_namer().generate_name(monster_role)


================================================================================
Файл: game/data/names/adjectives.json
================================================================================

[
    "Злобный",
    "Коварный",
    "Гнилой",
    "Кровавый",
    "Яростный",
    "Хитрый",
    "Мерзкий",
    "Скользкий",
    "Лютый",
    "Мрачный"
  ]

================================================================================
Файл: game/data/names/nouns.json
================================================================================

[
    "Гоблин",
    "Огр",
    "Скелет",
    "Зомби",
    "Дракон",
    "Демон",
    "Призрак",
    "Вампир",
    "Оборотень",
    "Бес"
  ]

================================================================================
Файл: game/data/names/prefixes.json
================================================================================

[
    "Супер",
    "Мега",
    "Ультра",
    "Архи",
    "Великий",
    "Король",
    "Лорд",
    "Мастер",
    "Профессор",
    "Доктор"
  ]

================================================================================
Файл: game/data/names/suffixes.json
================================================================================

[
    "Младший",
    "Старший",
    "Великий",
    "Ужасный",
    "Несокрушимый",
    "Из Тьмы",
    "Из Бездны",
    "Пожиратель",
    "Разрушитель",
    "Завоеватель"
  ]

================================================================================
Файл: game/data/characters/player_classes/archer.json
================================================================================

{
    "name": "Лучник",
    "role": "archer",
    "class_icon": "A",
    "class_icon_color": 6,
    "base_stats": {
        "strength": 8,
        "agility": 14,
        "intelligence": 10,
        "vitality": 9
    },
    "growth_rates": {
        "strength": 0.06,
        "agility": 0.07,
        "intelligence": 0.05,
        "vitality": 0.08
    },
    "description": "Класс с высоким уроном, средней ловкостью и низкой защитой.",
    "starting_abilities": [
        "Volley"
    ]
}

================================================================================
Файл: game/data/characters/player_classes/berserker.json
================================================================================

{
  "name": "Берсерк",
  "role": "berserker",
  "class_icon": "B",
  "class_icon_color": "RED",
  "base_stats": {
    "strength": 16,
    "agility": 10,
    "intelligence": 8,
    "vitality": 12
  },
  "growth_rates": {
    "strength": 0.10,
    "agility": 0.05,
    "intelligence": 0.03,
    "vitality": 0.09
  },
  "description": "Сбалансированный класс с высокой силой и защитой.",
  "starting_abilities": []
}

================================================================================
Файл: game/data/characters/player_classes/healer.json
================================================================================

{
    "name": "Лекарь",
    "role": "healer",
    "class_icon": "H",
    "class_icon_color": "CYAN",
    "base_stats": {
        "strength": 5,
        "agility": 12,
        "intelligence": 16,
        "vitality": 10
    },
    "growth_rates": {
        "strength": 0.04,
        "agility": 0.08,
        "intelligence": 0.09,
        "vitality": 0.08
    },
    "description": "Класс с низким уроном, средними защитой и здоровьем, способностью лечить.",
    "starting_abilities": [
        "Heal",
        "MassHeal"
    ]
}

================================================================================
Файл: game/data/characters/player_classes/mage.json
================================================================================

{
  "name": "Маг",
  "role": "mage",
  "class_icon": "M",
  "class_icon_color": "MAGENTA",
  "base_stats": {
    "strength": 4,
    "agility": 12,
    "intelligence": 20,
    "vitality": 6
  },
  "growth_rates": {
    "strength": 0.03,
    "agility": 0.06,
    "intelligence": 0.12,
    "vitality": 0.06
  },
  "description": "Мастер магии, наносящий огромный урон, но слабо защищенный.",
  "starting_abilities": []
}

================================================================================
Файл: game/data/characters/player_classes/rogue.json
================================================================================

{
    "name": "Разбойник",
    "role": "rogue",
    "class_icon": "R",
    "class_icon_color": "GRAY",
    "base_stats": {
        "strength": 6,
        "agility": 18,
        "intelligence": 10,
        "vitality": 7
    },
    "growth_rates": {
        "strength": 0.05,
        "agility": 0.08,
        "intelligence": 0.06,
        "vitality": 0.07
    },
    "description": "Класс с высокой ловкостью, умеренным уроном и низкой защитой.",
    "starting_abilities": [
        "Backstab",
        "SlidingStrike",
        "CriticalStrike",
        "PoisonStrike"
    ]
}

================================================================================
Файл: game/data/characters/monster_classes/goblin.json
================================================================================

{
    "name": "Гоблин",
    "role": "goblin",
    "class_icon": "G",
    "class_icon_color": "GREEN",
    "base_stats": {
        "strength": 6,
        "agility": 8,
        "intelligence": 4,
        "vitality": 8
    },
    "growth_rates": {
        "strength": 0.04,
        "agility": 0.04,
        "intelligence": 0.03,
        "vitality": 0.05
    },
    "description": "Слабый враг, который почему-то считает себя опасным. Настолько маленький, что даже его собственная тень прячется от него. Удивительно, как он вообще держит оружие, не говоря уже о том, чтобы им попасть куда-то.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/orc.json
================================================================================

{
    "name": "Орк",
    "role": "orc",
    "class_icon": "O",
    "class_icon_color": "RED",
    "base_stats": {
        "strength": 16,
        "agility": 6,
        "intelligence": 5,
        "vitality": 14
    },
    "growth_rates": {
        "strength": 0.10,
        "agility": 0.03,
        "intelligence": 0.02,
        "vitality": 0.09
    },
    "description": "Сильный враг с высоким уроном и IQ размером с арахис. Мозг настолько маленький, что даже муха не может в него въехать. Зато бьет так, что даже стены начинают искать себе другую работу.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/skeleton.json
================================================================================

{
    "name": "Скелет",
    "role": "skeleton",
    "class_icon": "S",
    "class_icon_color": "WHITE",
    "base_stats": {
        "strength": 12,
        "agility": 10,
        "intelligence": 6,
        "vitality": 10
    },
    "growth_rates": {
        "strength": 0.08,
        "agility": 0.05,
        "intelligence": 0.04,
        "vitality": 0.07
    },
    "description": "Средний враг, который умудрился умереть даже будучи мертвым. Постоянно теряет части тела, но это его не останавливает - видимо, он и при жизни был рассеян. Хотя, кто знает, может это и к лучшему.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/troll.json
================================================================================

{
    "name": "Тролль",
    "role": "troll",
    "class_icon": "T",
    "class_icon_color": "YELLOW",
    "base_stats": {
        "strength": 17,
        "agility": 4,
        "intelligence": 3,
        "vitality": 18
    },
    "growth_rates": {
        "strength": 0.09,
        "agility": 0.02,
        "intelligence": 0.01,
        "vitality": 0.11
    },
    "description": "Очень крепкий враг, который настолько туп, что даже эхо от его голоса возвращается с извинениями. Мозг размером с вишню, но зато может выдержать прямое попадание метеорита. Смертельно опасен для всего живого... и мертвого тоже.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/wizard.json
================================================================================

{
    "name": "Волшебник",
    "role": "wizard",
    "class_icon": "W",
    "class_icon_color": "MAGENTA",
    "base_stats": {
        "strength": 8,
        "agility": 12,
        "intelligence": 18,
        "vitality": 9
    },
    "growth_rates": {
        "strength": 0.05,
        "agility": 0.07,
        "intelligence": 0.10,
        "vitality": 0.06
    },
    "description": "Магический враг с высоким уроном, который считает себя гением, потому что может зажечь спичку. Проводит годы в изучении древних заклинаний, чтобы в итоге случайно поджечь сам себя. По крайней мере, он всегда в центре внимания.",
    "starting_abilities": []
}

================================================================================
Файл: game/ui/rendering/__init__.py
================================================================================

# Game/UI/Rendering/__init__.py
"""
Модуль рендеринга пользовательского интерфейса.

Содержит компоненты для отрисовки текста, шаблонов, кнопок и других элементов
интерфейса с поддержкой цветов, форматирования и шаблонов.
"""

from .renderer import Renderer
from .renderable import Renderable, Text, TemplateText, Button, Separator
from .color_manager import Color, ColorManager
from .template_renderer import TemplatePart, TemplateRenderer

__all__ = [
    'Renderer',
    'Renderable', 'Text', 'TemplateText', 'Button', 'Separator',
    'Color', 'ColorManager',
    'TemplatePart', 'TemplateRenderer'
]

================================================================================
Файл: game/ui/rendering/color_manager.py
================================================================================

# game/ui/rendering/color_manager.py
"""Управление цветами для пользовательского интерфейса.

Предоставляет систему цветов и управление цветовыми парами для curses.
"""

import curses
from enum import Enum
from typing import Any  # Для аннотации stdscr


class Color(Enum):
    """Перечисление доступных цветов."""
    DEFAULT = 0
    RED = 1
    GREEN = 2
    YELLOW = 3
    BLUE = 4
    MAGENTA = 5
    CYAN = 6
    WHITE = 7
    # Примечание: GRAY (8) может не поддерживаться всеми терминалами
    GRAY = 8


class ColorManager:
    """Управление цветами для curses."""

    def __init__(self) -> None:
        """Инициализация менеджера цветов."""
        self.color_pairs: dict = {}
        self._initialized = False

    def initialize(self, stdscr: Any) -> None:
        """
        Инициализация цветов.

        Args:
            stdscr: Окно curses для инициализации цветов.
        """
        if not self._initialized and curses.has_colors():
            curses.start_color()
            curses.use_default_colors()

            # Определяем цветовые пары
            curses.init_pair(Color.RED.value, curses.COLOR_RED, -1)
            curses.init_pair(Color.GREEN.value, curses.COLOR_GREEN, -1)
            curses.init_pair(Color.YELLOW.value, curses.COLOR_YELLOW, -1)
            curses.init_pair(Color.BLUE.value, curses.COLOR_BLUE, -1)
            curses.init_pair(Color.MAGENTA.value, curses.COLOR_MAGENTA, -1)
            curses.init_pair(Color.CYAN.value, curses.COLOR_CYAN, -1)
            curses.init_pair(Color.WHITE.value, curses.COLOR_WHITE, -1)
            # TODO: Проверить поддержку цвета 8 (GRAY) в различных терминалах
            curses.init_pair(Color.GRAY.value, 8, -1)

            self._initialized = True

    def get_color_pair(self, color: Color) -> int:
        """
        Получение цветовой пары.

        Args:
            color: Цвет из перечисления Color.

        Returns:
            Цветовая пара для curses.
        """
        if not self._initialized:
            return curses.A_NORMAL
        return curses.color_pair(color.value)


================================================================================
Файл: game/ui/rendering/renderable.py
================================================================================

# game/ui/rendering/renderable.py
"""Базовые элементы пользовательского интерфейса.

Содержит абстрактные и конкретные классы для отображаемых элементов
интерфейса: текст, кнопки, разделители и т.д.
"""

from abc import ABC, abstractmethod
from typing import Dict, Tuple, Optional, TYPE_CHECKING

from game.ui.rendering.color_manager import Color

if TYPE_CHECKING:
    from game.ui.rendering.renderer import Renderer


class Renderable(ABC):
    """Абстрактный базовый класс для всех отображаемых элементов."""

    def __init__(self, x: int = 0, y: int = 0):
        """
        Инициализация отображаемого элемента.

        Args:
            x: Координата X.
            y: Координата Y.
        """
        self.x = x
        self.y = y

    @abstractmethod
    def render(self, renderer: 'Renderer') -> None:
        """
        Отрисовка элемента.

        Args:
            renderer: Рендерер для отрисовки.
        """
        pass


class Text(Renderable):
    """Текстовый элемент."""

    def __init__(self, text: str, x: int = 0, y: int = 0,
                 bold: bool = False, dim: bool = False, color: Color = Color.DEFAULT):
        """
        Инициализация текстового элемента.

        Args:
            text: Отображаемый текст.
            x: Координата X.
            y: Координата Y.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
            color: Цвет текста.
        """
        super().__init__(x, y)
        self.text = text
        self.bold = bold
        self.dim = dim
        self.color = color

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка текста."""
        renderer.draw_text(self.text, self.x, self.y, self.bold, self.dim, self.color)


class TemplateText(Renderable):
    """Текст с шаблонами и цветами."""

    def __init__(self, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]],
                 x: int = 0, y: int = 0):
        """
        Инициализация шаблонного текста.

        Args:
            template: Шаблон текста с плейсхолдерами %1, %2 и т.д.
            replacements: Словарь замен {номер: (текст, цвет, жирный, тусклый)}.
            x: Координата X.
            y: Координата Y.
        """
        super().__init__(x, y)
        self.template = template
        self.replacements = replacements

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка шаблонного текста."""
        renderer.draw_template(self.template, self.replacements, self.x, self.y)


class Button(Renderable):
    """Кнопка."""

    def __init__(self, text: str, x: int = 0, y: int = 0,
                 key: str = "", color: Color = Color.DEFAULT, bold: bool = False, dim: bool = False):
        """
        Инициализация кнопки.

        Args:
            text: Текст кнопки.
            x: Координата X.
            y: Координата Y.
            key: Клавиша для активации.
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        super().__init__(x, y)
        self.text = text
        self.key = key
        self.color = color
        self.bold = bold
        self.dim = dim

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка кнопки."""
        display_text = f"[{self.key}] {self.text}" if self.key else self.text
        renderer.draw_text(display_text, self.x, self.y, self.bold, self.dim, self.color)


class Separator(Renderable):
    """Разделительная линия."""

    def __init__(self, y: int, char: str = "─", length: Optional[int] = None,
                 color: Color = Color.RED, bold: bool = False, dim: bool = True):
        """
        Инициализация разделителя.

        Args:
            y: Координата Y.
            char: Символ для линии.
            length: Длина линии (None для автоматической).
            color: Цвет линии.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        super().__init__(0, y)
        self.char = char
        self.length = length
        self.color = color
        self.bold = bold
        self.dim = dim

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка разделителя."""
        line_length = self.length or renderer.width
        line = self.char * (line_length - 1)
        renderer.draw_text(line, self.x, self.y, self.bold, self.dim, self.color)


================================================================================
Файл: game/ui/rendering/renderer.py
================================================================================

# game/ui/rendering/renderer.py
"""Рендерер для отрисовки элементов пользовательского интерфейса.

Предоставляет абстракцию над библиотекой curses для упрощения отрисовки
текста, шаблонов и других элементов интерфейса.
"""

import curses
from turtle import color
from typing import Dict, Tuple, Any

from game.ui.rendering.color_manager import Color, ColorManager
from game.ui.rendering.template_renderer import TemplateRenderer


class Renderer:
    """Рендерер для отрисовки элементов на экране."""

    def __init__(self, stdscr: curses.window, color_manager: ColorManager) -> None:
        """
        Инициализация рендерера.

        Args:
            stdscr: Окно curses для отрисовки.
            color_manager: Менеджер цветов.
        """
        self.stdscr = stdscr
        self.color_manager = color_manager
        self.template_renderer = TemplateRenderer(color_manager)
        self.height, self.width = stdscr.getmaxyx()

    def clear(self) -> None:
        """Очистка экрана."""
        self.stdscr.clear()

    def draw_text(self, text: str, x: int, y: int,
                  bold: bool = False, dim: bool = False, color: Color = Color.DEFAULT) -> None:
        """
        Отрисовка текста на экране.

        Args:
            text: Текст для отрисовки.
            x: Координата X.
            y: Координата Y.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
            color: Цвет текста.
        """
        try:
            # Проверяем границы экрана
            if y >= self.height or x >= self.width or y < 0 or x < 0:
                return

            # Получаем атрибуты
            attr = self.color_manager.get_color_pair(color)
            if bold:
                attr |= curses.A_BOLD
            if dim:
                attr |= curses.A_DIM

            self.stdscr.addstr(y, x, text, attr)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass

    def draw_template(self, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]],
                      x: int, y: int) -> None:
        """
        Отрисовка шаблонного текста.

        Args:
            template: Шаблон текста с плейсхолдерами %1, %2 и т.д.
            replacements: Словарь замен {номер: (текст, цвет, жирный, тусклый)}.
            x: Координата X.
            y: Координата Y.
        """
        try:
            # Проверяем границы экрана
            if y < 0 or x < 0 or y >= self.height:
                return

            self.template_renderer.draw_template(self.stdscr, template, replacements, x, y)
        except curses.error:
            pass

    def draw_box(self, x: int, y: int, width: int, height: int) -> None:
        """
        Отрисовка прямоугольника.

        Args:
            x: Координата X левого верхнего угла.
            y: Координата Y левого верхнего угла.
            width: Ширина прямоугольника.
            height: Высота прямоугольника.
        """
        try:
            # Верхняя и нижняя границы
            if y < self.height and y + height - 1 < self.height:
                self.stdscr.addstr(y, x, "+" + "-" * (width - 2) + "+")
                self.stdscr.addstr(y + height - 1, x, "+" + "-" * (width - 2) + "+")

            # Боковые границы
            for i in range(1, min(height - 1, self.height - y)):
                if y + i < self.height:
                    self.stdscr.addstr(y + i, x, "|")
                    if x + width - 1 < self.width:
                        self.stdscr.addstr(y + i, x + width - 1, "|")
        except curses.error:
            pass

    def draw_borderless_log_box(self, x: int, y: int, width: int, height: int) -> None:
        """
        Отрисовка прямоугольника.

        Args:
            x: Координата X левого верхнего угла.
            y: Координата Y левого верхнего угла.
            width: Ширина прямоугольника.
            height: Высота прямоугольника.
        """
        а = "┬ ┴"

        try:
            # Верхняя и нижняя границы
            top_text = "├" + "─" * ((width - 3) // 2) + "┴" + "─" * ((width - 3) // 2) + "┤"
            bottom_text = "└" + "─" * (width - 2) + "┘"
            
            self.draw_text(text=top_text, x=x, y=y, color=Color.DEFAULT, dim=True)
            self.draw_text(text=bottom_text, x=x, y=y + height - 1, color=Color.DEFAULT, dim=True)
            
            #if y < self.height and y + height - 1 < self.height:
                #self.stdscr.addstr(y, x, , curses.get_color_pair(Color.DEFAULT))
                #self.stdscr.addstr(y + height - 1, x, "└" + "─" * (width - 2) + "┘")

        except curses.error:
            pass

    def refresh(self) -> None:
        """Обновление экрана."""
        self.stdscr.refresh()


================================================================================
Файл: game/ui/rendering/template_renderer.py
================================================================================

# game/ui/rendering/template_renderer.py
"""Рендерер для работы с шаблонами текста.

Позволяет создавать форматированный текст с плейсхолдерами и различными
стилями для каждой части текста.
"""

import re
from typing import Dict, List, Tuple, Any

import curses

from game.ui.rendering.color_manager import Color, ColorManager


class TemplatePart:
    """Часть шаблона с форматированием."""

    def __init__(self, text: str, color: Color = Color.DEFAULT, bold: bool = False, dim: bool = False):
        """
        Инициализация части шаблона.

        Args:
            text: Текст части.
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        self.text = text
        self.color = color
        self.bold = bold
        self.dim = dim


class TemplateRenderer:
    """Рендерер для работы с шаблонами текста."""

    def __init__(self, color_manager: ColorManager) -> None:
        """
        Инициализация рендерера шаблонов.

        Args:
            color_manager: Менеджер цветов для применения стилей.
        """
        self.color_manager = color_manager
        # Регулярное выражение для поиска плейсхолдеров типа %1, %2 и т.д.
        self.placeholder_pattern = re.compile(r'%(\d+)')

    def render_template(self, template: str,
                       replacements: Dict[str, Tuple[str, Color, bool, bool]]) -> List[TemplatePart]:
        """
        Рендер шаблона с заменами.

        Args:
            template: Шаблон текста, например "%1 ударяет %2".
            replacements: Словарь {номер: (текст, цвет, жирный, тусклый)}, например {"1": ("Игрок", Color.GREEN, True, False)}.

        Returns:
            Список частей текста с форматированием.
        """
        parts: List[TemplatePart] = []
        last_end = 0

        # Находим все плейсхолдеры
        for match in self.placeholder_pattern.finditer(template):
            start, end = match.span()
            placeholder_num = match.group(1)

            # Добавляем текст до плейсхолдера
            if start > last_end:
                parts.append(TemplatePart(template[last_end:start]))

            # Добавляем замену для плейсхолдера
            if placeholder_num in replacements:
                text, color, bold, dim = replacements[placeholder_num]
                parts.append(TemplatePart(text, color, bold, dim))
            else:
                # Если нет замены, оставляем плейсхолдер как есть
                parts.append(TemplatePart(match.group(0)))

            last_end = end

        # Добавляем оставшийся текст
        if last_end < len(template):
            parts.append(TemplatePart(template[last_end:]))

        return parts

    def draw_template(self, stdscr: curses.window, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]],
                     x: int, y: int) -> None:
        """
        Отрисовка шаблона на экране.

        Args:
            stdscr: Окно curses для отрисовки.
            template: Шаблон текста.
            replacements: Словарь замен.
            x: Координата X.
            y: Координата Y.
        """
        try:
            parts = self.render_template(template, replacements)
            current_x = x

            for part in parts:
                if y >= 0 and current_x >= 0:
                    attr = self.color_manager.get_color_pair(part.color)
                    if part.bold:
                        attr |= curses.A_BOLD
                    if part.dim:
                        attr |= curses.A_DIM

                    stdscr.addstr(y, current_x, part.text, attr)
                    current_x += len(part.text)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass


================================================================================
Файл: game/ui/command_system/__init__.py
================================================================================

# game/ui/command_system/__init__.py
"""
Система команд пользовательского интерфейса.

Содержит самодостаточные команды и систему их регистрации.
"""

from .command import Command, CommandRegistry
from .screen_command_registry import (
    register_screen_commands,
    get_screen_commands,
    get_all_registered_screens,
    clear_registry
)
from .command_renderer import CommandRenderer  # ДОБАВИЛИ!

__all__ = [
    'Command',
    'CommandRegistry',
    'CommandRenderer',  # ДОБАВИЛИ!
    'register_screen_commands',
    'get_screen_commands',
    'get_all_registered_screens',
    'clear_registry'
]

================================================================================
Файл: game/ui/command_system/command.py
================================================================================

# game/ui/command_system/command.py
"""Базовые классы для системы команд.

Реализует паттерн Команда для обработки пользовательского ввода.
"""

from abc import ABC, abstractmethod
import curses
from typing import List, Set, Optional, Any, Union

# Отложенная аннотация для избежения циклического импорта
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen


class Command(ABC):
    """Абстрактная команда."""

    def __init__(self, name: str, description: str, keys: List[Union[str, int]], display_key: str = ""):
        """
        Инициализация команды.

        Args:
            name: Название команды.
            description: Описание команды.
            keys: Список клавиш, на которые назначена команда (например, ['q', 'ESC']).
            display_key: Клавиша для отображения в интерфейсе (если отличается от первой в keys).
        """
        self.name = name
        self.description = description
        self.keys = keys  # Список символов, например ['q', 'ESC']
        self.display_key = display_key if display_key else (str(keys[0]) if keys else "")

    def get_key_codes(self) -> Set[int]:
        """
        Получение кодов клавиш для регистрации.

        Returns:
            Множество кодов клавиш.
        """
        key_codes = set()
        for key in self.keys:
            if isinstance(key, int):
                key_codes.add(key)
            else:
                key_codes.add(ord(str(key)))
            # TODO: Можно добавить обработку других специальных клавиш curses, если потребуется
        return key_codes

    @abstractmethod
    def execute(self, context: Optional[Any] = None) -> None:
        """
        Выполнение команды.

        Args:
            context: Контекст выполнения (обычно экран).
        """
        pass


class CommandRegistry:
    """Реестр команд для экрана."""

    def __init__(self) -> None:
        self._commands: List[Command] = []
        self._key_to_command: dict[int, Command] = {}  # key_code -> command

    def register_command(self, command: Command) -> None:
        """
        Регистрация команды.

        Args:
            command: Команда для регистрации.
        """
        self._commands.append(command)
        # Регистрируем все клавиши команды
        for key_code in command.get_key_codes():
            self._key_to_command[key_code] = command

    def execute_command(self, key_code: int, context: Optional[Any] = None) -> bool:
        """
        Выполнение команды по коду клавиши.

        Args:
            key_code: Код нажатой клавиши.
            context: Контекст выполнения.

        Returns:
            True если команда найдена и выполнена, False если нет.
        """
        command = self._key_to_command.get(key_code)
        if command:
            command.execute(context)
            return True
        return False

    def get_all_commands(self) -> List[Command]:
        """Получение всех зарегистрированных команд."""
        return self._commands.copy()

    def get_command_by_key(self, key_code: int) -> Optional[Command]:
        """Получение команды по коду клавиши."""
        return self._key_to_command.get(key_code)


================================================================================
Файл: game/ui/command_system/command_renderer.py
================================================================================

# game/ui/command_system/command_renderer.py
"""Отрисовка команд пользовательского интерфейса.

Отдельный класс для отображения информации о доступных командах.
"""

from typing import List, TYPE_CHECKING

from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Text

if TYPE_CHECKING:
    from game.ui.command_system.command import Command


class CommandRenderer:
    """Обработчик отображения списка доступных команд."""

    def __init__(self, x: int = 0, y: int = 15, max_width: int = 70):
        """
        Инициализация отрисовщика команд.

        Args:
            x: Начальная координата X.
            y: Начальная координата Y.
            max_width: Максимальная ширина строки команд.
        """
        self.x = x
        self.y = y
        self.max_width = max_width

    def render_commands(self, commands: List['Command']) -> List[Text]:
        """
        Создание элементов отрисовки для команд в одной строке.
        Команды отображаются в формате "key : описание", разделенные " | ".
        Все элементы - тускло серые.

        Args:
            commands: Список команд для отрисовки.

        Returns:
            Список текстовых элементов для отрисовки.
        """
        if not commands:
            return []

        # Создаем список строк для каждой команды и объединяем их
        command_strings = [f"{command.display_key} : {command.name}" for command in commands]
        full_line = " | ".join(command_strings)

        # Возвращаем один текстовый элемент, весь текст будет тускло серым
        return [Text(full_line, self.x, self.y, dim=True, color=Color.GRAY)]


================================================================================
Файл: game/ui/command_system/screen_command_registry.py
================================================================================

# game/ui/command_system/screen_command_registry.py
"""Реестр команд для экранов.

Реализует паттерн Registry для хранения связей между классами экранов и их командами.
"""

from typing import Dict, List, Type, TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen
    from game.ui.command_system.command import Command

# Глобальный реестр: КлассЭкрана -> СписокКоманд
SCREEN_COMMANDS: Dict[Type['BaseScreen'], List['Command']] = {}


def register_screen_commands(screen_class: Type['BaseScreen'], commands: List['Command']) -> None:
    """
    Регистрация команд для конкретного экрана.

    Args:
        screen_class: Класс экрана.
        commands: Список команд для этого экрана.
    """
    SCREEN_COMMANDS[screen_class] = commands


def get_screen_commands(screen_class: Type['BaseScreen']) -> List['Command']:
    """
    Получение команд для конкретного экрана.

    Args:
        screen_class: Класс экрана.

    Returns:
        Список команд для экрана (пустой список если нет команд).
    """
    return SCREEN_COMMANDS.get(screen_class, [])


def get_all_registered_screens() -> List[Type['BaseScreen']]:
    """
    Получение всех экранов с зарегистрированными командами.

    Returns:
        Список классов экранов.
    """
    return list(SCREEN_COMMANDS.keys())


def clear_registry() -> None:
    """Очистка реестра (для тестирования)."""
    SCREEN_COMMANDS.clear()


================================================================================
Файл: game/ui/commands/inventory_commands.py
================================================================================

# game/ui/commands/inventory_commands.py
"""
Специфические команды для экрана инвентаря.
"""

from curses import KEY_ENTER
from game.ui.command_system.command import Command
from game.ui.inventory_screen import InventoryScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class UseItemCommand(Command):
    """Команда использования предмета."""

    def __init__(self):
        super().__init__(
            name="Использовать",
            description="Использовать выбранный предмет",
            keys=['u', KEY_ENTER],
            display_key="u/Enter"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды использования предмета."""
        if context:
            print("Предмет использован")


class DropItemCommand(Command):
    """Команда выбрасывания предмета."""

    def __init__(self):
        super().__init__(
            name="Выбросить",
            description="Выбросить выбранный предмет",
            keys=['d'],
            display_key="d"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды выбрасывания предмета."""
        if context:
            print("Предмет выброшен")


# Импортируем общие команды
from game.ui.commands.common_commands import GoBackCommand

# Регистрируем команды для экрана инвентаря
register_screen_commands(InventoryScreen, [
    UseItemCommand(),
    DropItemCommand(),
    GoBackCommand()  # Переиспользуем общую команду
])

================================================================================
Файл: game/ui/commands/battle_commands.py
================================================================================

# game/ui/commands/battle_commands.py
"""
Специфические команды для экрана боя.
"""

from game.ui.command_system.command import Command
from game.ui.battle_screen import BattleScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class AttackCommand(Command):
    """Команда атаки."""

    def __init__(self):
        super().__init__(
            name="Атака",
            description="Атаковать противника",
            keys=['a', 'A'],
            display_key="A/a"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды атаки."""
        if context:
            print("Атака!")


class DefendCommand(Command):
    """Команда защиты."""

    def __init__(self):
        super().__init__(
            name="Защита",
            description="Защититься от атаки",
            keys=['d'],
            display_key="d"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды защиты."""
        if context:
            print("Защита!")


class MagicCommand(Command):
    """Команда использования магии."""

    def __init__(self):
        super().__init__(
            name="Магия",
            description="Использовать магическое заклинание",
            keys=['m'],
            display_key="m"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды магии."""
        if context:
            print("Магия!")


# Импортируем общие команды
from game.ui.commands.common_commands import GoBackCommand, OpenInventoryCommand

# Регистрируем команды для экрана боя
register_screen_commands(BattleScreen, [
    AttackCommand(),
    DefendCommand(),
    MagicCommand(),
    OpenInventoryCommand(),  # Переиспользуем общую команду
    GoBackCommand()          # Переиспользуем общую команду
])

================================================================================
Файл: game/ui/commands/__init__.py
================================================================================

# game/ui/commands/__init__.py
"""Пакет конкретных команд для разных экранов.

Содержит реализации команд для конкретных экранов игры.
"""

# ВАЖНО: Импортируем все команды, чтобы они зарегистрировались
import game.ui.commands.common_commands
import game.ui.commands.inventory_commands
import game.ui.commands.battle_commands
import game.ui.commands.main_screen_commands

# Экспортируем основные классы команд для удобства использования
# Общие команды
from .common_commands import (
    GoBackCommand,
    OpenInventoryCommand,
    HelpCommand,
    ExitCommand
)

# Специфические команды инвентаря
from .inventory_commands import (
    UseItemCommand,
    DropItemCommand
)

# Специфические команды боя
from .battle_commands import (
    AttackCommand,
    DefendCommand,
    MagicCommand as BattleMagicCommand
)

# Специфические команды главного экрана
from .main_screen_commands import (
    StartBattleCommand,
    OpenSettingsCommand
)

__all__ = [
    # Общие команды
    'GoBackCommand',
    'OpenInventoryCommand',
    'HelpCommand',
    'ExitCommand',

    # Команды инвентаря
    'UseItemCommand',
    'DropItemCommand',

    # Команды боя
    'AttackCommand',
    'DefendCommand',
    'BattleMagicCommand',

    # Команды главного экрана
    'StartBattleCommand',
    'OpenSettingsCommand'
]


================================================================================
Файл: game/ui/commands/common_commands.py
================================================================================

# game/ui/commands/common_commands.py
"""Общие команды, которые могут использоваться в нескольких экранах."""

from typing import Optional, Any

from game.ui.command_system.command import Command


class GoBackCommand(Command):
    """Общая команда возврата назад."""

    def __init__(self):
        super().__init__(
            name="Назад",
            description="Вернуться к предыдущему экрану",
            keys=['q'],
            display_key="q"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды возврата."""
        if context and hasattr(context, 'manager'):
            context.manager.go_back()


class OpenInventoryCommand(Command):
    """Общая команда открытия инвентаря."""

    def __init__(self):
        super().__init__(
            name="Инвентарь",
            description="Открыть инвентарь",
            keys=['i'],
            display_key="i"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды открытия инвентаря."""
        if context and hasattr(context, 'manager'):
            context.manager.change_screen("inventory")


class HelpCommand(Command):
    """Общая команда помощи."""

    def __init__(self):
        super().__init__(
            name="Помощь",
            description="Показать помощь",
            keys=['h', '?'],
            display_key="h/?"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды помощи."""
        # TODO: Заменить print на отображение внутри curses UI
        if context:
            print("Помощь по экрану:", context.__class__.__name__ if context else "Неизвестный экран")


class ExitCommand(Command):
    """Общая команда выхода из игры."""

    def __init__(self):
        super().__init__(
            name="Выход",
            description="Выйти из игры",
            keys=['q'],  # Только q, не ESC чтобы избежать конфликтов
            display_key="q"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды выхода."""
        # TODO: Рассмотреть использование raise SystemExit() вместо exit()
        exit()


================================================================================
Файл: game/ui/commands/main_screen_commands.py
================================================================================

# game/ui/commands/main_screen_commands.py
"""Специфические команды для главного экрана."""

from typing import Optional, Any

from game.ui.command_system.command import Command
from game.ui.command_system.screen_command_registry import register_screen_commands
# Импортируем общие команды
from game.ui.commands.common_commands import OpenInventoryCommand, ExitCommand
# Импортируем экран для регистрации команд
from game.ui.main_screen import MainScreen


class StartBattleCommand(Command):
    """Команда начала боя."""

    def __init__(self):
        super().__init__(
            name="Бой",
            description="Начать бой",
            keys=[10],
            display_key="Enter"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды начала боя."""
        if context and hasattr(context, 'manager'):
            context.manager.change_screen("battle")


class OpenSettingsCommand(Command):
    """Команда открытия настроек."""

    def __init__(self):
        super().__init__(
            name="Настройки",
            description="Открыть настройки",
            keys=['3'],
            display_key="3"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды открытия настроек."""
        # TODO: Заменить print на отображение внутри curses UI
        if context:
            print("Открытие настроек")


# Регистрируем команды для главного экрана
register_screen_commands(MainScreen, [
    StartBattleCommand(),
    OpenInventoryCommand(),  # Переиспользуем общую команду
    OpenSettingsCommand(),
    ExitCommand()            # Переиспользуем общую команду
])


================================================================================
Файл: game/ui/components/battle_components.py
================================================================================

# game/ui/components/battle_components.py
"""Компоненты для экрана боя.
Содержит визуальные элементы для отображения игроков, врагов и лога боя."""

import curses
from typing import List, TYPE_CHECKING

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import Color
# Импортируем новые виджеты
from game.ui.widgets.labels import CharacterNameLabel, CharacterLevelLabel, CharacterClassLabel, TextLabel
from game.ui.widgets.bars import HealthBar, EnergyBar

# Импорты для аннотаций типов, чтобы избежать циклических импортов на уровне выполнения
if TYPE_CHECKING:
    from game.entities.monster import Monster
    from game.entities.player import Player
    from game.entities.character import Character


class UnitPanel(Renderable):
    """Базовая панель для отображения одного юнита (игрока или врага) в одну строку."""
    
    # Константы для компоновки
    DEFAULT_WIDGET_MAX_WIDTH = 10
    MIN_NAME_WIDTH = 5
    MIN_WIDGET_WIDTH = 3
    WIDGET_SPACING = 1
    CHARACTER_NAME_WIDTH = 6  # Все имена персонажей состоят из максимум 6 букв. 
    MONSTER_NAME_WIDTH = 20
    HP_BAR_WIDTH = 10
    EP_BAR_WIDTH = 5
    
    # Константы для оценки минимальной ширины элементов
    ESTIMATED_LEVEL_WIDTH = 3
    ESTIMATED_HP_WIDTH = 10  # Обновлено для прогресс-баров
    ESTIMATED_ENERGY_WIDTH = 5  # Обновлено для прогресс-баров
    
    # Пороги для цветов HP
    HP_CRITICAL_THRESHOLD = 0.25
    HP_LOW_THRESHOLD = 0.5

    def __init__(self, character: 'Character', x: int, y: int, width: int, height: int) -> None:
        """Инициализация базовой панели юнита.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (должна быть 1 для соответствия новому дизайну).
        """
        super().__init__(x, y)
        self.width = width
        self.height = height  # Ожидается 1
        self.character = character
        
        if character.is_player:
            name_width = self.CHARACTER_NAME_WIDTH 
            color = Color.GREEN
        else:
            name_width = self.MONSTER_NAME_WIDTH
            color = Color.BLUE

        # Инициализируем виджеты
        self.name_label = CharacterNameLabel(character=self.character, x=x, y=y, max_width=name_width, color=color)
        self.class_label = CharacterClassLabel(character=self.character, x=x, y=y)
        self.level_label = CharacterLevelLabel(character=self.character, x=x, y=y)
        
        self.hp_label = HealthBar(character=self.character, x=x, y=y, width=self.HP_BAR_WIDTH)
        self.energy_label = EnergyBar(character=character, x=x, y=y, width=self.EP_BAR_WIDTH)
        # Для HP и Energy в бою отображаем числовые значения, а не прогресс-бары
        # Поэтому создаем специальные текстовые лейблы
        #self.hp_label = TextLabel(x=x, y=y)
        #self.energy_label = TextLabel(x=x, y=y)

    def update_size(self, width: int, height: int) -> None:
        """
        Обновить размеры панели и пересчитать позиции виджетов.
        
        Args:
            width: Новая ширина.
            height: Новая высота (игнорируется, устанавливается в 1).
        """
        self.width = width
        self.height = 1  # Фиксированная высота для однострочной панели
        
        # Пересчитываем позиции виджетов
        self._update_widgets_positions()

    def _update_widgets_positions(self) -> None:
        """Обновить позиции и размеры виджетов в зависимости от ширины панели."""
        if not self.character:
            return
            
        current_x = self.x
        
        # 1. Имя
        self.name_label.x = current_x
        self.name_label.y = self.y
        name_width = self.name_label.max_width
        current_x += name_width + self.WIDGET_SPACING

        # 2. Класс/роль
        self.class_label.x = current_x
        self.class_label.y = self.y
        class_width = len(self.class_label.text) + 2  # Примерная ширина [R]
        current_x += class_width  #  Spacing не нужен 
        
        # 3. Уровень
        self.level_label.x = current_x
        self.level_label.y = self.y
        level_width = len(self.level_label.text) + 2
        current_x += level_width

        # 4. HP
        self.hp_label.x = current_x
        self.hp_label.y = self.y
        current_x += self.hp_label.width + 2
        
        # 5. Energy
        self.energy_label.x = current_x
        self.energy_label.y = self.y

    def render(self, renderer: Renderer) -> None:
        """Отрисовка базовой панели юнита в одну строку."""
        if not self.character:
            # Если персонаж не установлен, отображаем заглушку
            placeholder_text = "Нет данных"
            display_text = placeholder_text.ljust(self.width)[:self.width]
            try:
                renderer.draw_text(display_text, self.x, self.y, color=Color.GRAY)
            except curses.error:
                pass
            return

        # Пересчитываем позиции виджетов перед отрисовкой
        self._update_widgets_positions()
        
        # Отрисовываем все виджеты
        self.name_label.render(renderer)
        self.class_label.render(renderer)
        self.level_label.render(renderer)
        self.hp_label.render(renderer)
        self.energy_label.render(renderer)
            
        # Заполняем оставшееся пространство пробелами для затирания предыдущего содержимого
        # last_widget_end_x = self.energy_label.x + len(self.energy_label.text) if self.energy_label.text else \
        #                   (self.hp_label.x + len(self.hp_label.text))
        # if last_widget_end_x < self.x + self.width:
        #     remaining_width = (self.x + self.width) - last_widget_end_x
        #     try:
        #         renderer.draw_text(" " * remaining_width, last_widget_end_x, self.y)
        #     except curses.error:
        #         pass


class EnemyUnitPanel(UnitPanel):
    """Панель для отображения одного врага."""

    def __init__(self, x: int, y: int, width: int, height: int, monster: 'Monster') -> None:
        """Инициализация панели врага.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (должна быть 1).
            monster: Объект Monster для отображения.
        """
        super().__init__(monster, x, y, width, height)


class PlayerUnitPanel(UnitPanel):
    """Панель для отображения одного игрока."""

    def __init__(self, x: int, y: int, width: int, height: int, player: 'Player') -> None:
        """Инициализация панели игрока.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (должна быть 1).
            player: Объект Player для отображения.
        """
        super().__init__(player, x, y, width, height)


class GroupPanel(Renderable):
    """Базовая панель для отображения группы юнитов без внешнего обрамления."""

    def __init__(self, x: int, y: int, width: int, height: int) -> None:
        """Инициализация базовой панели группы.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели.
        """
        super().__init__(x, y)
        self.width = width
        self.height = height
        # Этот список будет заполняться в подклассах
        self.panels: List[UnitPanel] = []

    def update_size(self, max_width: int, max_height: int) -> None:
        """
        Обновление размеров панели и её компонентов.
        Args:
            max_width: Максимальная ширина экрана.
            max_height: Максимальная высота экрана.
        """
        # Обновление размеров дочерних панелей
        if self.panels:
            # Рассчитываем ширину для каждой панели
            panel_count = len(self.panels)
            new_panel_width = max(10, self.width // panel_count) if panel_count > 0 else self.width

            for i, panel in enumerate(self.panels):
                panel.width = new_panel_width
                panel.height = 1  # Высота панели юнита должна быть 1
                panel.update_size(new_panel_width, 1)  # Обновляем размеры внутренних виджетов

    def render(self, renderer: Renderer) -> None:
        """Отрисовка панели группы без внешнего обрамления."""
        # НЕ отрисовываем рамку вокруг группы
        # Отрисовка каждой панели юнита
        for panel in self.panels:
            panel.render(renderer)


class EnemyGroupPanel(GroupPanel):
    """Панель для отображения группы врагов."""

    def __init__(self, x: int, y: int, width: int, height: int, enemies: List['Monster']) -> None:
        """Инициализация панели группы врагов.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (ожидается 5).
            enemies: Список объектов Monster для отображения.
        """
        # Инициализируем базовую панель группы
        super().__init__(x, y, width, height)
        # Сохраняем ссылку на список объектов Monster
        self.enemies = enemies
        # Обновляем панели на основе переданных объектов
        self._update_panels()

    def _update_panels(self) -> None:
        """Обновление списка панелей на основе объектов врагов."""
        self.panels = []
        
        for i, monster in enumerate(self.enemies):
            # Каждая панель размещается на отдельной строке
            panel_x = self.x
            panel_y = self.y + i  # Одна строка на панель
            panel_width = self.width
            panel_height = 1  # Фиксированная высота 1 строка
            
            # Создаем панель, передавая объект Monster
            panel = EnemyUnitPanel(panel_x, panel_y, panel_width, panel_height, monster)
            self.panels.append(panel)


class PlayerGroupPanel(GroupPanel):
    """Панель для отображения группы игроков."""

    def __init__(self, x: int, y: int, width: int, height: int, players: List['Player']) -> None:
        """Инициализация панели группы игроков.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (ожидается 5).
            players: Список объектов Player для отображения.
        """
        # Инициализируем базовую панель группы
        super().__init__(x, y, width, height)
        # Сохраняем ссылку на список объектов Player
        self.players = players
        # Обновляем панели на основе переданных объектов
        self._update_panels()

    def _update_panels(self) -> None:
        """Обновление списка панелей на основе объектов игроков."""
        self.panels = []
        
        for i, player in enumerate(self.players):
            # Каждая панель размещается на отдельной строке
            panel_x = self.x
            panel_y = self.y + i  # Одна строка на панель
            panel_width = self.width
            panel_height = 1  # Фиксированная высота 1 строка
            
            # Создаем панель, передавая объект Player
            panel = PlayerUnitPanel(panel_x, panel_y, panel_width, panel_height, player)
            self.panels.append(panel)


class BattleLog(Renderable):
    """Лог боя в нижней части экрана с прокруткой и обрамлением."""

    def __init__(self, x: int, y: int, width: int, height: int) -> None:
        super().__init__(x, y)
        self.width = width
        self.height = height
        # TODO: Получать реальные сообщения из игровой логики
        self.messages: List[str] = [
            "Битва начинается!",
            "Герой вступает в бой с Драконом.",
            "Дракон издает грозный рык.",
            "Герой атакует Дракона!",
            "Дракон получает 25 урона.",
            "Дракон атакует Героя!",
            "Герой получает 15 урона.",
            "Герой использует зелье лечения.",
            "Герой восстанавливает 30 HP.",
            "Дракон готовится к мощной атаке!",
            "Герой защищается.",
            "Мощная атака Дракона отражена!",
        ]
        self.scroll_offset = 0 # Смещение прокрутки (0 = последние сообщения внизу)

    def add_message(self, message: str) -> None:
        """Добавление сообщения в лог.
        Args:
            message: Текст сообщения.
        """
        self.messages.append(message)
        # При добавлении нового сообщения сбрасываем прокрутку вниз
        self.scroll_offset = 0

    def scroll_up(self) -> None:
        """Прокрутка лога вверх."""
        # Максимальное смещение - это количество строк, которые не помещаются
        max_offset = max(0, len(self.messages) - self.height)
        if self.messages:
            self.scroll_offset = min(max_offset, self.scroll_offset + 1)

    def scroll_down(self) -> None:
        """Прокрутка лога вниз."""
        if self.messages:
            self.scroll_offset = max(0, self.scroll_offset - 1)

    def update_size(self, total_width: int, total_height: int) -> None:
        """Обновление размеров лога.
        Args:
            total_width: Общая ширина экрана.
            total_height: Общая высота экрана.
        """
        # Занимает всю ширину экрана (с отступами)
        self.width = max(10, total_width - 2) # -2 для отступов
        # Высота динамическая, устанавливается в BattleScreen._update_component_sizes
        # Пока оставим пустую реализацию или базовую
        pass

    def render(self, renderer: Renderer) -> None:
        """Отрисовка лога боя с обрамлением."""
        # Отрисовка рамки лога (она остается)
        try:
            renderer.draw_borderless_log_box(self.x, self.y, self.width, self.height)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass

        # Определяем, какие сообщения отображать с учетом прокрутки
        # scroll_offset = 0 означает, что последние сообщения внизу
        start_index = max(0, len(self.messages) - self.height - self.scroll_offset)
        end_index = start_index + self.height
        visible_messages = self.messages[start_index:end_index]

        # Отрисовка сообщений
        for i, message in enumerate(visible_messages):
            # Позиция Y для текущего сообщения
            msg_y = self.y + 1 + i
            # Позиция X (с небольшим отступом)
            msg_x = self.x + 1

            # Отрисовка текста сообщения
            try:
                # TODO: Добавить цвета/стили для разных типов сообщений (урон, лечение, и т.д.)
                renderer.draw_text(message, msg_x, msg_y, color=Color.WHITE)
            except curses.error:
                # Игнорируем ошибки выхода за границы экрана
                pass


================================================================================
Файл: game/ui/widgets/labels.py
================================================================================

# game/ui/widgets/labels.py
"""Базовые текстовые метки для отображения информации.
Эти компоненты могут использоваться в различных частях интерфейса,
например, для отображения имени, уровня, класса персонажа и другой информации."""

from typing import Optional, TYPE_CHECKING, Any, Dict, Tuple

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import Color

if TYPE_CHECKING:
    from game.entities.character import Character


class TextLabel(Renderable):
    """Базовая текстовая метка."""

    def __init__(
        self, 
        x: int = 0, 
        y: int = 0, 
        text: str = "", 
        color: Color = Color.DEFAULT,
        bold: bool = False,
        dim: bool = False
    ) -> None:
        """
        Инициализация текстовой метки.

        Args:
            x: Координата X.
            y: Координата Y.
            text: Отображаемый текст.
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        super().__init__(x, y)

        self.text = text
        self.color = color
        self.bold = bold
        self.dim = dim
        

    def render(self, renderer: Renderer) -> None:
        """Отрисовка текстовой метки."""
        if self.text:
            renderer.draw_text(self.text, self.x, self.y, self.bold, self.dim, self.color)


class CharacterNameLabel(TextLabel):
    """Метка для отображения имени персонажа."""

    def __init__(
        self,
        character: 'Character', 
        x: int = 0, 
        y: int = 0,
        max_width: int = 0,
        color: Color = Color.DEFAULT,
        bold: bool = False,
        dim: bool = False
    ) -> None:
        """
        Инициализация метки имени персонажа.

        Args:
            x: Координата X.
            y: Координата Y.
            character: Объект персонажа, имя которого нужно отобразить.
            max_width: Максимальная ширина текста (для обрезки/усечения).
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        # Инициализируем с пустым текстом, он будет обновлен в update_from_character
        super().__init__(x, y, "", color, bold, dim)
        self.character = character
        self.max_width = max_width
        self._update_from_character()

    def _update_from_character(self) -> None:
        """Обновить текст метки из данных персонажа."""
        if self.character:
            name = getattr(self.character, 'name', 'Unknown')
            if self.max_width and len(name) > self.max_width:
                # Простое усечение, можно улучшить (например, добавить "...")
                self.text = name[:self.max_width]
            else:
                self.text = name
        else:
            self.text = "Unknown"


class TemplatedTextLabel(TextLabel):
    """Базовая метка для отрисовки текста с использованием шаблонов и цветов."""
    
    def __init__(self, x: int = 0, y: int = 0) -> None:
        """
        Инициализация метки с шаблонами.

        Args:
            x: Координата X.
            y: Координата Y.
        """
        super().__init__(x, y)

    def _create_bracketed_template(
        self, 
        content: str, 
        content_color: Color = Color.DEFAULT,
        bracket_color: Color = Color.WHITE
    ) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Создать шаблон вида [content] с разными цветами для скобок и содержимого.

        Args:
            content: Содержимое внутри скобок.
            content_color: Цвет содержимого.
            bracket_color: Цвет скобок.

        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        return (
            "%1%2%3",
            {
                "1": ("[", bracket_color, False, False),
                "2": (content, content_color, False, False),
                "3": ("]", bracket_color, False, False)
            }
        )

    def render(self, renderer: Renderer) -> None:
        """Отрисовка текста с использованием шаблона."""
        template, replacements = self._get_template_and_replacements()
        renderer.draw_template(template, replacements, self.x, self.y)
        
    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Получить шаблон и словарь замен для отрисовки.
        
        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        raise NotImplementedError("Subclasses must implement _get_template_and_replacements")


class CharacterClassLabel(TemplatedTextLabel):
    """Метка для отображения класса/роли персонажа в формате [Роль]."""

    def __init__(
        self,
        character: 'Character', 
        x: int = 0, 
        y: int = 0, 
    ) -> None:
        """
        Инициализация метки класса персонажа.

        Args:
            x: Координата X.
            y: Координата Y.
            character: Объект персонажа, класс которого нужно отобразить.
        """
        super().__init__(x, y)
        self.character = character
        self._update_from_character()

    def _update_from_character(self) -> None:
        """Обновить текст метки из данных персонажа."""
        if self.character:
            self.text = getattr(self.character, 'class_icon', "?")
            color = getattr(self.character, 'class_icon_color')
            self.color = Color[color] if color else self.color
   

    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """Определяем шаблон и замены для роли."""
        return self._create_bracketed_template(self.text, self.color)


class CharacterLevelLabel(TemplatedTextLabel):
    """Метка для отображения уровня персонажа в формате [1]."""

    def __init__(
        self,
        character: 'Character', 
        x: int = 0, 
        y: int = 0, 
        
    ) -> None:
        """
        Инициализация метки уровня персонажа.

        Args:
            x: Координата X.
            y: Координата Y.
            character: Объект персонажа, уровень которого нужно отобразить.
        """
        super().__init__(x, y)
        self.character = character
        self._update_from_character()

    def _update_from_character(self) -> None:
        if self.character:
            level = getattr(self.character, 'level', 1)
        else:
            level = 1
        self.text = str(level)

    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """Определяем шаблон и замены для уровня."""
        return self._create_bracketed_template(self.text, Color.YELLOW)


================================================================================
Файл: game/ui/widgets/__init__.py
================================================================================

# game/ui/widgets/__init__.py
"""Переиспользуемые UI компоненты."""

from .labels import (
    TextLabel,
    CharacterNameLabel,
    CharacterClassLabel,
    CharacterLevelLabel
)

from .bars import (
    ProgressBar,
    HealthBar,
    EnergyBar
)

from .character_card import (
    CharacterInfoPanel
)

__all__ = [
    'TextLabel',
    'CharacterNameLabel',
    'CharacterClassLabel',
    'CharacterLevelLabel',
    'ProgressBar',
    'HealthBar',
    'EnergyBar',
    'CharacterInfoPanel',
]

================================================================================
Файл: game/ui/widgets/bars.py
================================================================================

# game/ui/widgets/bars.py
"""Прогресс-бары для отображения различных параметров (HP, Energy и т.д.).
Эти компоненты могут использоваться в различных частях интерфейса,
например, на экране боя, экране персонажа и т.д."""

from typing import Optional, TYPE_CHECKING, Dict, Tuple
from abc import ABC, abstractmethod

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import Color

if TYPE_CHECKING:
    from game.entities.character import Character


class ProgressBar(Renderable, ABC):
    """Базовый класс для отрисовки прогресс-бара с использованием шаблонов."""

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 20,
        character: Optional['Character'] = None
    ) -> None:
        """
        Инициализация базового прогресс-бара.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина прогресс-бара в символах.
            character: Объект персонажа для отслеживания значений.
        """
        super().__init__(x, y)
        self.width = width
        self.character = character

    @abstractmethod
    def _get_current_value(self) -> int:
        """Получить текущее значение из персонажа."""
        pass

    @abstractmethod
    def _get_max_value(self) -> int:
        """Получить максимальное значение из персонажа."""
        pass

    @abstractmethod
    def _get_fill_color(self) -> Color:
        """Получить цвет заполненной части прогресс-бара."""
        pass

    @abstractmethod
    def _get_empty_color(self) -> Color:
        """Получить цвет пустой части прогресс-бара."""
        pass

    def set_character(self, character: Optional['Character']) -> None:
        """
        Установить персонажа для отслеживания значений.

        Args:
            character: Объект персонажа или None.
        """
        self.character = character

    def _create_progress_template(
        self,
        filled_count: int,
        empty_count: int
    ) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Создать шаблон и словарь замен для отрисовки прогресс-бара.

        Args:
            filled_count: Количество заполненных символов.
            empty_count: Количество пустых символов.

        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        # Создаем строки заполнения
        filled_part = "■" * filled_count  # Полностью заполненные символы
        empty_part = "□" * empty_count    # Пустые символы

        # Создаем шаблон
        # %1 - открывающая скобка, %2 - заполненная часть, %3 - пустая часть, %4 - закрывающая скобка
        template = "%1%2%3%4"
        
        replacements = {
            "1": ("[", Color.WHITE, False, False),      # Открывающая скобка
            "2": (filled_part, self._get_fill_color(), False, False),  # Заполненная часть
            "3": (empty_part, self._get_empty_color(), False, False),  # Пустая часть
            "4": ("]", Color.WHITE, False, False)       # Закрывающая скобка
        }
        
        return template, replacements

    def render(self, renderer: Renderer) -> None:
        """Отрисовка прогресс-бара с использованием шаблона."""
        template, replacements = self._get_template_and_replacements()
        renderer.draw_template(template, replacements, self.x, self.y)

    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Создать шаблон и словарь замен для отрисовки прогресс-бара.

        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        # Получаем значения из персонажа
        if self.character:
            current_value = self._get_current_value()
            max_value = self._get_max_value()
        else:
            current_value = 0
            max_value = 1

        # Рассчитываем количество заполненных и пустых символов
        if max_value <= 0:
            filled_count = 0
        else:
            # Используем пропорцию: filled_count / self.width = current_value / max_value
            filled_count = int((current_value / max_value) * self.width)
        
        # Убеждаемся, что значения в допустимых пределах
        filled_count = max(0, min(filled_count, self.width))
        empty_count = self.width - filled_count

        # Используем общий метод для создания шаблона
        return self._create_progress_template(filled_count, empty_count)


class HealthBar(ProgressBar):
    """Прогресс-бар для отображения здоровья (HP)."""

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 20,
        character: Optional['Character'] = None
    ) -> None:
        """
        Инициализация прогресс-бара здоровья.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина прогресс-бара в символах.
            character: Объект персонажа для отслеживания HP.
        """
        super().__init__(x, y, width, character)

    def _get_current_value(self) -> int:
        """Получить текущее значение HP из персонажа."""
        if self.character:
            return getattr(self.character, 'hp', 0)
        return 0

    def _get_max_value(self) -> int:
        """Получить максимальное значение HP из персонажа."""
        if self.character:
            attributes = getattr(self.character, 'attributes', None)
            if attributes:
                # Используем consistent fallback: 1 как минимальное значение
                return max(1, getattr(attributes, 'max_hp', 1))
        # Если персонажа нет или атрибуты не определены, возвращаем 1 как fallback
        return 1

    def _get_fill_color(self) -> Color:
        """Получить цвет заполненной части для HP (зеленый)."""
        if not self.character:
            return Color.GREEN
            
        # Получаем значения для расчета цвета
        current = self._get_current_value()
        max_val = self._get_max_value()
        
        ratio: float = 0
        if max_val > 0:
            ratio = current / max_val
            
        if ratio < 0.25:
            return Color.RED
        elif ratio < 0.5:
            return Color.YELLOW
        else:
            return Color.GREEN

    def _get_empty_color(self) -> Color:
        """Получить цвет пустой части для HP (темно-серый/серый)."""
        return Color.GRAY


class EnergyBar(ProgressBar):
    """Прогресс-бар для отображения энергии (Energy/MP)."""

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 20,
        character: Optional['Character'] = None
    ) -> None:
        """
        Инициализация прогресс-бара энергии.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина прогресс-бара в символах.
            character: Объект персонажа для отслеживания энергии.
        """
        super().__init__(x, y, width, character)

    def _get_current_value(self) -> int:
        """Получить текущее значение энергии из персонажа."""
        if self.character:
            return getattr(self.character, 'energy', 0)
        return 0

    def _get_max_value(self) -> int:
        """Получить максимальное значение энергии из персонажа."""
        if self.character:
            attributes = getattr(self.character, 'attributes', None)
            if attributes:
                # Используем consistent fallback: 0 как минимальное значение (если энергия не используется)
                return max(0, getattr(attributes, 'max_energy', 0))
        # Если персонажа нет или атрибуты не определены, возвращаем 0 как fallback
        return 0

    def _get_fill_color(self) -> Color:
        """Получить цвет заполненной части для энергии (синий)."""
        return Color.BLUE

    def _get_empty_color(self) -> Color:
        """Получить цвет пустой части для энергии (темно-серый/серый)."""
        return Color.GRAY


================================================================================
Файл: game/ui/widgets/character_card.py
================================================================================

# game/ui/widgets/character_card.py
"""Виджет для отображения сводной информации о персонаже.
Содержит имя, уровень, класс/роль, HP и энергию в компактном виде."""

from typing import Optional, TYPE_CHECKING, List

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.widgets.labels import CharacterNameLabel, CharacterLevelLabel, CharacterClassLabel
from game.ui.widgets.bars import HealthBar, EnergyBar

if TYPE_CHECKING:
    from game.entities.character import Character


class CharacterInfoPanel(Renderable):
    """Панель с информацией о персонаже, объединяющая несколько виджетов."""
    
    # Константы для макета
    CLASS_LABEL_X_OFFSET = 0
    NAME_LABEL_X_OFFSET = 5
    LEVEL_LABEL_X_OFFSET = -5  # Отрицательное значение для позиционирования справа
    MIN_NAME_LABEL_WIDTH = 10

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 30,
        height: int = 5,
        character: Optional['Character'] = None,
        show_name: bool = True,
        show_class: bool = True,
        show_level: bool = True,
        show_health_bar: bool = True,
        show_energy_bar: bool = True
    ) -> None:
        """
        Инициализация панели информации о персонаже.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели.
            character: Объект персонажа для отображения.
            show_class: Показывать ли метку класса/роли.
            show_name: Показывать ли метку имени.
            show_level: Показывать ли метку уровня.
            show_health_bar: Показывать ли полосу здоровья.
            show_energy_bar: Показывать ли полосу энергии.
        """
        super().__init__(x, y)
        self.width = width
        self.height = height
        self.character = character
        
        # Флаги отображения компонентов
        self.show_name = show_name
        self.show_class = show_class
        self.show_level = show_level
        self.show_health_bar = show_health_bar
        self.show_energy_bar = show_energy_bar

        # Создаем дочерние виджеты (они могут быть неактивны, если show_* = False)
        self.class_label: Optional[CharacterClassLabel] = None
        self.name_label: Optional[CharacterNameLabel] = None
        self.level_label: Optional[CharacterLevelLabel] = None
        self.health_bar: Optional[HealthBar] = None
        self.energy_bar: Optional[EnergyBar] = None
        
        # Инициализируем виджеты в зависимости от флагов
        self._initialize_widgets()
        
        # Если передан персонаж, устанавливаем его для всех виджетов
        if self.character:
            self.set_character(self.character)

    def _initialize_widgets(self) -> None:
        """Инициализировать дочерние виджеты в зависимости от флагов отображения."""
        if self.show_name:
            self.name_label = CharacterNameLabel(
                x=self.x + self.NAME_LABEL_X_OFFSET, 
                y=self.y, 
                max_width=max(self.MIN_NAME_LABEL_WIDTH, self.width - self.NAME_LABEL_X_OFFSET + self.LEVEL_LABEL_X_OFFSET)
            )

        if self.show_class:
            self.class_label = CharacterClassLabel(x=self.x + self.CLASS_LABEL_X_OFFSET, y=self.y)
            
        if self.show_level:
            self.level_label = CharacterLevelLabel(x=self.x + self.width + self.LEVEL_LABEL_X_OFFSET, y=self.y)
            
        if self.show_health_bar:
            self.health_bar = HealthBar(x=self.x, y=self.y + 1, width=self.width)
            
        if self.show_energy_bar:
            self.energy_bar = EnergyBar(x=self.x, y=self.y + 2, width=self.width)

    def set_character(self, character: Optional['Character']) -> None:
        """
        Установить персонажа для отображения во всех дочерних виджетах.

        Args:
            character: Объект персонажа или None.
        """
        self.character = character
        
        # Устанавливаем персонажа только для активных виджетов
        if self.class_label and self.show_class:
            self.class_label.set_character(character)
        if self.name_label and self.show_name:
            self.name_label.set_character(character)
        if self.level_label and self.show_level:
            self.level_label.set_character(character)
        if self.health_bar and self.show_health_bar:
            self.health_bar.set_character(character)
        if self.energy_bar and self.show_energy_bar:
            self.energy_bar.set_character(character)

    def update_size(self, width: int, height: int) -> None:
        """
        Обновить размеры панели и пересчитать позиции дочерних элементов.

        Args:
            width: Новая ширина панели.
            height: Новая высота панели.
        """
        self.width = width
        self.height = height
        
        # Пересчитываем позиции активных дочерних виджетов
        if self.class_label and self.show_class:
            self.class_label.x = self.x + self.CLASS_LABEL_X_OFFSET
            self.class_label.y = self.y
            
        if self.name_label and self.show_name:
            self.name_label.x = self.x + self.NAME_LABEL_X_OFFSET
            self.name_label.y = self.y
            # Обновляем максимальную ширину имени с учетом новых размеров
            calculated_max_width = self.width - self.NAME_LABEL_X_OFFSET + self.LEVEL_LABEL_X_OFFSET
            self.name_label.max_width = max(self.MIN_NAME_LABEL_WIDTH, calculated_max_width)
            
        if self.level_label and self.show_level:
            self.level_label.x = self.x + self.width + self.LEVEL_LABEL_X_OFFSET  # Позиционируем уровень справа
            self.level_label.y = self.y
            
        if self.health_bar and self.show_health_bar:
            self.health_bar.x = self.x
            self.health_bar.y = self.y + 1
            self.health_bar.width = self.width
            
        if self.energy_bar and self.show_energy_bar:
            self.energy_bar.x = self.x
            self.energy_bar.y = self.y + 2
            self.energy_bar.width = self.width

    def render(self, renderer: Renderer) -> None:
        """
        Отрисовка панели информации о персонаже.
        
        Args:
            renderer: Рендерер для отрисовки.
        """
        # Отрисовываем только активные дочерние виджеты
        renderable_widgets: List[Renderable] = []
        
        if self.class_label and self.show_class:
            renderable_widgets.append(self.class_label)
        if self.name_label and self.show_name:
            renderable_widgets.append(self.name_label)
        if self.level_label and self.show_level:
            renderable_widgets.append(self.level_label)
        if self.health_bar and self.show_health_bar:
            renderable_widgets.append(self.health_bar)
        if self.energy_bar and self.show_energy_bar:
            renderable_widgets.append(self.energy_bar)
            
        # Отрисовываем все активные виджеты
        for widget in renderable_widgets:
            widget.render(renderer)


================================================================================
Файл: tests/__init__.py
================================================================================



================================================================================
Файл: tests/test_character.py
================================================================================

# tests/test_character.py
"""Тесты для классов Character и Player."""

from typing import Any, Dict, List

import pytest

# Импортируем протокол Attributes
from game.protocols import Attributes, Stats
from game.entities.character import Character
# Убедимся, что SimpleAttributes наследуется от Attributes в своем определении
from game.entities.player import Player, SimpleAttributes, SimpleStats


# ==================== Фикстуры ====================

@pytest.fixture
def mock_stats() -> Stats:
    """Фикстура для создания тестовых характеристик."""
    stats = SimpleStats()
    stats.strength = 10
    stats.agility = 10
    stats.intelligence = 10
    stats.vitality = 10
    return stats


@pytest.fixture
def mock_attributes(mock_stats: Stats) -> Attributes:
    """Фикстура для создания тестовых атрибутов."""
    # Убедимся, что SimpleAttributes совместим с Attributes
    return SimpleAttributes(CharacterMock(), mock_stats)


@pytest.fixture
def base_player_data() -> Dict[str, Any]:
    """Фикстура с базовыми данными для создания игрока."""
    return {
        'base_stats_dict': {
            'strength': 10,
            'agility': 10,
            'intelligence': 10,
            'vitality': 10
        },
        'growth_rates_dict': {
            'strength': 1.0,
            'agility': 1.0,
            'intelligence': 1.0,
            'vitality': 1.0
        }
    }


# ==================== Мок-классы ====================

class CharacterMock(Character):
    """Мок-класс для тестирования абстрактного Character."""

    def __init__(self) -> None:
        """Инициализация мок-персонажа."""
        # Пропускаем инициализацию Character для упрощения тестов
        self.name = "TestCharacter"
        self.role = "test"
        self.level = 1
        self.alive = True
        self.is_player = False
        self.stats = SimpleStats()
        # Убедимся, что тип атрибутов совместим
        self.attributes: Attributes = SimpleAttributes(self, self.stats)
        self.hp = 100
        self.energy = 50
        self._ability_manager = None
        self._status_manager = None

    def get_base_stats(self) -> Stats:
        """Получение базовых характеристик."""
        stats = SimpleStats()
        stats.strength = 10
        stats.agility = 10
        stats.intelligence = 10
        stats.vitality = 10
        return stats

    def calculate_attributes(self) -> Attributes:
        """Вычисление атрибутов."""
        # Убедимся, что возвращаемый тип совместим
        return SimpleAttributes(self, self.get_base_stats())


# ==================== Тесты Character ====================

class TestCharacter:
    """Тесты для базового класса Character."""

    def test_character_initialization(self) -> None:
        """Тест инициализации персонажа."""
        character = CharacterMock()
        assert character.name == "TestCharacter"
        assert character.role == "test"
        assert character.level == 1
        assert character.alive is True
        assert character.is_player is False
        assert character.hp == 100
        assert character.energy == 50

    def test_is_alive(self) -> None:
        """Тест проверки жив ли персонаж."""
        character = CharacterMock()
        assert character.is_alive() is True

        character.alive = False
        assert character.is_alive() is False

    def test_get_level(self) -> None:
        """Тест получения уровня персонажа."""
        character = CharacterMock()
        character.level = 5
        assert character.get_level() == 5

    def test_take_damage(self) -> None:
        """Тест получения урона."""
        character = CharacterMock()
        character.attributes.defense = 4 # type: ignore # Мы знаем, что у SimpleAttributes есть defense
        character.hp = 100

        # Урон 20, защита 4, фактический урон = max(1, 20 - 4//2) = 18
        results = character.take_damage(20)

        assert len(results) == 1
        assert results[0]["type"] == "damage_taken"
        assert results[0]["damage"] == 18
        assert character.hp == 82  # 100 - 18

    def test_take_damage_death(self) -> None:
        """Тест смерти персонажа от урона."""
        character = CharacterMock()
        character.hp = 5

        results = character.take_damage(10)

        # Должно быть 2 результата: урон и смерть
        assert len(results) >= 1
        assert character.hp == 0
        assert character.alive is False

    def test_take_heal(self) -> None:
        """Тест исцеления персонажа."""
        character = CharacterMock()
        character.attributes.max_hp = 100 # type: ignore # Мы знаем, что у SimpleAttributes есть max_hp
        character.hp = 50

        results = character.take_heal(30)

        assert len(results) == 1
        assert results[0]["type"] == "healed"
        assert results[0]["heal_amount"] == 30
        assert character.hp == 80

    def test_take_heal_over_max(self) -> None:
        """Тест исцеления выше максимального HP."""
        character = CharacterMock()
        character.attributes.max_hp = 100 # type: ignore # Мы знаем, что у SimpleAttributes есть max_hp
        character.hp = 90

        results = character.take_heal(20)

        assert results[0]["heal_amount"] == 10  # Только 10 до максимума
        assert character.hp == 100

    def test_restore_energy(self) -> None:
        """Тест восстановления энергии."""
        character = CharacterMock()
        character.attributes.max_energy = 100 # type: ignore # Мы знаем, что у SimpleAttributes есть max_energy
        character.energy = 50

        results = character.restore_energy(amount=30)

        assert len(results) == 1
        assert results[0]["type"] == "energy_restored"
        assert results[0]["amount"] == 30
        assert character.energy == 80

    def test_spend_energy_success(self) -> None:
        """Тест успешной траты энергии."""
        character = CharacterMock()
        character.energy = 50

        result = character.spend_energy(20)

        assert result is True
        assert character.energy == 30

    def test_spend_energy_fail(self) -> None:
        """Тест неудачной траты энергии."""
        character = CharacterMock()
        character.energy = 10

        result = character.spend_energy(20)

        assert result is False
        assert character.energy == 10  # Энергия не изменилась

    def test_level_up(self) -> None:
        """Тест повышения уровня."""
        character = CharacterMock()
        character.level = 1
        character.hp = 80
        character.energy = 30
        character.attributes.max_hp = 100 # type: ignore # Мы знаем, что у SimpleAttributes есть max_hp
        character.attributes.max_energy = 50 # type: ignore # Мы знаем, что у SimpleAttributes есть max_energy

        results = character.level_up()

        assert len(results) == 1
        assert results[0]["type"] == "level_up"
        assert character.level == 2
        # Проверяем сохранение процентов HP/энергии
        assert character.hp > 0  # HP должен сохраниться пропорционально


# ==================== Тесты Player ====================

class TestPlayer:
    """Тесты для класса Player."""

    def test_player_initialization(self, base_player_data: Dict[str, Any]) -> None:
        """Тест инициализации игрока."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        assert player.name == "TestPlayer"
        assert player.role == "warrior"
        assert player.level == 1
        assert player.is_player is True
        assert player.exp == 0
        assert hasattr(player, 'exp_to_next_level')

    def test_get_base_stats(self, base_player_data: Dict[str, Any]) -> None:
        """Тест получения базовых характеристик."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        stats = player.get_base_stats()
        # Проверяем, что объект имеет нужные атрибуты (вместо isinstance)
        assert hasattr(stats, 'strength')
        assert hasattr(stats, 'agility')
        assert hasattr(stats, 'intelligence')
        assert hasattr(stats, 'vitality')
        assert stats.strength > 0
        assert stats.agility > 0
        assert stats.intelligence > 0
        assert stats.vitality > 0

    def test_calculate_attributes(self, base_player_data: Dict[str, Any]) -> None:
        """Тест вычисления атрибутов."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        attributes = player.calculate_attributes()
        # Проверяем, что объект имеет нужные атрибуты (вместо isinstance)
        assert hasattr(attributes, 'max_hp')
        assert hasattr(attributes, 'max_energy')
        assert hasattr(attributes, 'attack_power')
        assert hasattr(attributes, 'defense')
        assert attributes.max_hp > 0
        assert attributes.max_energy > 0
        assert attributes.attack_power >= 0
        assert attributes.defense >= 0

    def test_calculate_exp_for_next_level(self, base_player_data: Dict[str, Any]) -> None:
        """Тест расчета опыта для следующего уровня."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        player.calculate_exp_for_next_level()
        assert player.exp_to_next_level > 0

        # Проверяем, что опыт увеличивается с уровнем
        player.level = 2
        player.calculate_exp_for_next_level()
        exp_level_2 = player.exp_to_next_level

        player.level = 3
        player.calculate_exp_for_next_level()
        exp_level_3 = player.exp_to_next_level

        assert exp_level_3 > exp_level_2

    def test_gain_experience(self, base_player_data: Dict[str, Any]) -> None:
        """Тест получения опыта."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )
        player.calculate_exp_for_next_level()

        # Получаем немного опыта
        results = player.gain_experience(50)

        assert len(results) == 1
        assert results[0]["type"] == "exp_gained"
        assert player.exp == 50

    def test_gain_experience_level_up(self, base_player_data: Dict[str, Any]) -> None:
        """Тест повышения уровня через опыт."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )
        player.exp_to_next_level = 100  # Устанавливаем опыт для теста

        # Получаем достаточно опыта для повышения уровня
        results = player.gain_experience(150)

        # Должно быть как минимум 2 результата: опыт и повышение уровня
        assert len(results) >= 2
        assert player.level >= 2
        assert player.exp == 50  # Остаток после повышения уровня (150 - 100 = 50)

    def test_gain_experience_multiple_level_up(self, base_player_data: Dict[str, Any]) -> None:
        """Тест множественного повышения уровня через опыт."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        # Установим начальный опыт для следующего уровня
        player.exp_to_next_level = 100

        # Получаем 250 опыта: 100 для первого уровня, 150 останется
        results = player.gain_experience(250)

        # После первого повышения уровень должен быть 2
        assert player.level == 2
        # Остаток опыта должен быть 150
        assert player.exp == 150

    def test_player_level_up(self, base_player_data: Dict[str, Any]) -> None:
        """Тест повышения уровня игрока."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )
        initial_level = player.level

        results = player.level_up()

        assert len(results) >= 1
        assert player.level == initial_level + 1
        # exp_to_next_level должен быть пересчитан
        assert player.exp_to_next_level > 0

    def test_experience_property(self, base_player_data: Dict[str, Any]) -> None:
        """Тест свойства опыта."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )
        player.calculate_exp_for_next_level()

        assert player.experience_to_next_level == player.exp_to_next_level


# ==================== Тесты вспомогательных классов ====================

class TestSimpleStats:
    """Тесты для SimpleStats."""

    def test_simple_stats_initialization(self) -> None:
        """Тест инициализации SimpleStats."""
        stats = SimpleStats()
        assert stats.strength == 0
        assert stats.agility == 0
        assert stats.intelligence == 0
        assert stats.vitality == 0


class TestSimpleAttributes:
    """Тесты для SimpleAttributes."""

    def test_simple_attributes_calculation(self, mock_stats: Stats) -> None:
        """Тест расчета атрибутов."""
        character = CharacterMock()
        attributes = SimpleAttributes(character, mock_stats)

        # Проверяем расчеты на основе формул из класса
        expected_max_hp = 50 + (mock_stats.vitality * 5)  # 50 + 50 = 100
        expected_max_energy = 20 + (mock_stats.intelligence * 3)  # 20 + 30 = 50
        expected_attack_power = mock_stats.strength * 2  # 10 * 2 = 20
        expected_defense = int(mock_stats.agility * 1.5)  # int(10 * 1.5) = 15

        assert attributes.max_hp == expected_max_hp
        assert attributes.max_energy == expected_max_energy
        assert attributes.attack_power == expected_attack_power
        assert attributes.defense == expected_defense


# ==================== Интеграционные тесты ====================

class TestCharacterPlayerIntegration:
    """Интеграционные тесты между Character и Player."""

    def test_player_inherits_character_behavior(self, base_player_data: Dict[str, Any]) -> None:
        """Тест, что Player наследует поведение Character."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        # Проверяем методы, унаследованные от Character
        assert player.is_alive() is True
        assert player.get_level() == 1

        # Проверяем, что можно использовать методы Character
        heal_results = player.take_heal(20)
        assert len(heal_results) == 1
        assert heal_results[0]["type"] == "healed"

    def test_player_damage_handling(self, base_player_data: Dict[str, Any]) -> None:
        """Тест обработки урона игроком."""
        player = Player(
            name="TestPlayer",
            role="warrior",
            **base_player_data,
            level=1
        )

        # Устанавливаем защиту для теста
        player.attributes.defense = 6 # type: ignore # Мы знаем, что у SimpleAttributes есть defense
        player.hp = 100

        damage_results = player.take_damage(20)
        assert len(damage_results) >= 1
        assert damage_results[0]["type"] == "damage_taken"
        assert player.hp < 100  # HP должно уменьшиться


================================================================================
Файл: tests/test_command_system.py
================================================================================

# tests/test_command_system.py
"""Тесты для системы команд."""

from typing import Any, Optional
from unittest.mock import MagicMock, patch

from game.ui.command_system.command import Command, CommandRegistry


class CommandTest(Command):
    """Тестовая реализация команды."""

    def __init__(self, name: str = "Test", description: str = "A test command", keys: Optional[list] = None) -> None:
        """
        Инициализация тестовой команды.

        Args:
            name: Название команды.
            description: Описание команды.
            keys: Список клавиш.
        """
        if keys is None:
            keys = ['t']
        super().__init__(name, description, keys)
        self.executed: bool = False
        self.context: Any = None

    def execute(self, context: Any = None) -> None:
        """
        Выполнение тестовой команды.

        Args:
            context: Контекст выполнения.
        """
        self.executed = True
        self.context = context


class CommandWithIntKeyTest(Command):
    """Тестовая реализация команды с целочисленным кодом клавиши."""

    def __init__(self) -> None:
        """Инициализация команды с целочисленным кодом клавиши."""
        # Имитируем ситуацию, когда ключ передан как число
        super().__init__("Int Key Cmd", "Command with int key", [10])  # Enter key code
        self.executed: bool = False

    def execute(self, context: Any = None) -> None:
        """
        Выполнение команды с целочисленным кодом клавиши.

        Args:
            context: Контекст выполнения.
        """
        self.executed = True


def test_command_initialization() -> None:
    """Тест инициализации команды."""
    cmd = CommandTest("MyCmd", "My Description", ['m', 'M'])
    assert cmd.name == "MyCmd"
    assert cmd.description == "My Description"
    assert cmd.keys == ['m', 'M']


def test_command_get_key_codes_case_insensitive() -> None:
    """Тест получения кодов клавиш с учетом регистра."""
    cmd1 = CommandTest("Test1", "Desc", ['a'])  # lowercase
    cmd2 = CommandTest("Test2", "Desc", ['A'])  # uppercase

    assert cmd1.get_key_codes() != cmd2.get_key_codes()
    assert cmd1.get_key_codes() == {ord('a')}  # Проверяем, что это код 'a'


def test_command_registry_register_command() -> None:
    """Тест регистрации команды в реестре."""
    registry = CommandRegistry()
    cmd = CommandTest()

    registry.register_command(cmd)

    assert cmd in registry._commands
    assert ord('t') in registry._key_to_command
    assert registry._key_to_command[ord('t')] == cmd


def test_command_registry_execute_command_success() -> None:
    """Тест успешного выполнения команды из реестра."""
    registry = CommandRegistry()
    cmd = CommandTest()
    registry.register_command(cmd)

    result = registry.execute_command(ord('t'), "test_context")

    assert result is True
    assert cmd.executed is True
    assert cmd.context == "test_context"


def test_command_registry_execute_command_failure() -> None:
    """Тест неуспешного выполнения команды из реестра."""
    registry = CommandRegistry()
    cmd = CommandTest()
    registry.register_command(cmd)

    result = registry.execute_command(ord('x'), "test_context")  # 'x' не зарегистрирован

    assert result is False
    assert cmd.executed is False  # Команда не должна выполниться


def test_command_registry_get_all_commands() -> None:
    """Тест получения всех команд из реестра."""
    registry = CommandRegistry()
    cmd1 = CommandTest("Cmd1", "Desc1", ['1'])
    cmd2 = CommandTest("Cmd2", "Desc2", ['2'])

    registry.register_command(cmd1)
    registry.register_command(cmd2)

    all_commands = registry.get_all_commands()

    assert len(all_commands) == 2
    assert cmd1 in all_commands
    assert cmd2 in all_commands
    # Проверяем, что возвращается копия
    assert all_commands is not registry._commands


def test_command_registry_get_command_by_key() -> None:
    """Тест получения команды по коду клавиши из реестра."""
    registry = CommandRegistry()
    cmd = CommandTest()
    registry.register_command(cmd)

    found_cmd = registry.get_command_by_key(ord('t'))
    not_found_cmd = registry.get_command_by_key(ord('x'))

    assert found_cmd == cmd
    assert not_found_cmd is None


def test_command_with_int_key_in_registry() -> None:
    """Тест работы реестра с командой, имеющей целочисленный код клавиши."""
    # Проверяем, как реестр обрабатывает команды с int ключами
    registry = CommandRegistry()
    cmd = CommandWithIntKeyTest()  # Эта команда в keys имеет [10]

    # Регистрируем команду через реестр, который должен корректно обработать int ключ
    registry.register_command(cmd)

    # Выполняем команду по её int коду
    result = registry.execute_command(10, "context")

    assert result is True
    assert cmd.executed is True


================================================================================
Файл: tests/test_game_manager.py
================================================================================

# tests/test_game_manager.py
"""Тесты для модуля game.game_manager, включая класс GameManager и функцию get_game_manager."""

import pytest
from unittest.mock import patch, MagicMock
from game.game_manager import GameManager, get_game_manager

class TestGameManager:
    """Тесты для класса GameManager."""

    def test_singleton_instance_via_get_game_manager(self) -> None:
        """
        Тест: Функция get_game_manager возвращает один и тот же экземпляр GameManager.
        Проверяет реализацию паттерна Singleton.
        """
        manager1 = get_game_manager()
        manager2 = get_game_manager()
        assert manager1 is manager2

    @patch('game.game_manager.get_config')
    def test_initialization_with_config(self, mock_get_config) -> None:
        """
        Тест: Инициализация GameManager корректно загружает конфигурацию.
        """
        # --- Ключевое исправление: Сброс Singleton перед тестом ---
        GameManager._instance = None

        # Настройка моков
        mock_config_instance = MagicMock()
        mock_get_config.return_value = mock_config_instance

        # Вызов тестируемой функциональности
        manager = get_game_manager()

        # Проверки
        mock_get_config.assert_called_once()

    def test_get_player_group(self) -> None:
        """
        Тест: Метод get_player_group возвращает список игроков.
        """
        manager = get_game_manager()

        # Создание мок-игроков и установка их в менеджер
        mock_player1 = MagicMock()
        mock_player2 = MagicMock()
        manager.player_group = [mock_player1, mock_player2]

        # Вызов тестируемой функциональности
        player_group = manager.get_player_group()

        # Проверки
        assert player_group == [mock_player1, mock_player2]
        assert len(player_group) == 2


================================================================================
Файл: tests/test_template_namer.py
================================================================================

# tests/test_template_namer.py
"""Тесты для генератора имен монстров."""

import os
import json
import pytest
from unittest.mock import patch, mock_open
from game.naming.template_namer import TemplateMonsterNamer, generate_monster_name


class TestTemplateMonsterNamer:
    """Тесты для класса TemplateMonsterNamer."""

    def test_init_with_default_directory(self):
        """Тест инициализации с директорией по умолчанию."""
        namer = TemplateMonsterNamer()
        assert namer.data_directory == "game/data/names"
        assert isinstance(namer.word_data, dict)

    def test_init_with_custom_directory(self):
        """Тест инициализации с пользовательской директорией."""
        custom_dir = "custom/names"
        namer = TemplateMonsterNamer(data_directory=custom_dir)
        assert namer.data_directory == custom_dir

    @patch('os.path.exists')
    @patch('builtins.open', new_callable=mock_open, read_data='["страшный", "злой"]')
    def test_load_word_data_success(self, mock_file, mock_exists):
        """Тест успешной загрузки данных слов."""
        mock_exists.return_value = True
        
        namer = TemplateMonsterNamer()
        assert "adjectives" in namer.word_data
        assert namer.word_data["adjectives"] == ["страшный", "злой"]

    @patch('os.path.exists')
    def test_load_word_data_directory_not_found(self, mock_exists):
        """Тест загрузки данных при отсутствии директории."""
        mock_exists.return_value = False
        
        with patch('builtins.print') as mock_print:
            namer = TemplateMonsterNamer()
            mock_print.assert_called_with(
                "Предупреждение: Директория данных имен 'game/data/names' не найдена."
            )
            assert namer.word_data == {}

    @patch('os.path.exists')
    @patch('builtins.open')
    def test_load_word_data_json_decode_error(self, mock_file, mock_exists):
        """Тест загрузки данных при ошибке JSON."""
        mock_exists.return_value = True
        mock_file.side_effect = json.JSONDecodeError("Invalid JSON", "doc", 1)
        
        with patch('builtins.print') as mock_print:
            namer = TemplateMonsterNamer()
            mock_print.assert_called()
            expected_keys = ["adjectives", "nouns", "prefixes", "suffixes"]
            for key in expected_keys:
                assert namer.word_data[key] == []

    def test_get_words_existing_category(self):
        """Тест получения слов для существующей категории."""
        namer = TemplateMonsterNamer()
        namer.word_data = {"adjectives": ["страшный", "мощный"]}
        result = namer._get_words("adjectives")
        assert result == ["страшный", "мощный"]

    def test_get_words_non_existing_category(self):
        """Тест получения слов для несуществующей категории."""
        namer = TemplateMonsterNamer()
        namer.word_data = {"adjectives": ["страшный"]}
        result = namer._get_words("nouns")
        assert result == []

    @patch('random.choice')
    def test_generate_name_success(self, mock_random_choice):
        """Тест успешной генерации имени."""
        mock_random_choice.side_effect = lambda x: x[0] if x else ""
        
        namer = TemplateMonsterNamer()
        namer.word_data = {
            "adjectives": ["страшный"],
            "nouns": ["гоблин"],
            "prefixes": ["супер"],
            "suffixes": ["младший"]
        }
        
        result = namer.generate_name("goblin")
        assert isinstance(result, str)
        assert len(result) > 0

    def test_generate_name_empty_word_data(self):
        """Тест генерации имени с пустыми данными слов."""
        namer = TemplateMonsterNamer()
        namer.word_data = {
            "adjectives": [],
            "nouns": [],
            "prefixes": [],
            "suffixes": []
        }
        
        result = namer.generate_name("test_role")
        
        # Проверяем что возвращается непустая строка (должно быть резервное имя)
        assert isinstance(result, str)
        assert len(result) > 0
        # Проверяем что имя содержит осмысленный текст
        assert "Монстр" in result or len(result) > 0

    def test_generate_name_with_various_templates(self):
        """Тест генерации имен с разными шаблонами."""
        namer = TemplateMonsterNamer()
        namer.word_data = {
            "adjectives": ["страшный", "мощный"],
            "nouns": ["гоблин", "дракон"],
            "prefixes": ["супер", "мега"],
            "suffixes": ["младший", "старший"]
        }
        
        # Тестируем несколько раз для разных результатов
        results = set()
        for i in range(5):
            with patch('random.choice') as mock_choice:
                # Фиксируем выбор для воспроизводимости
                mock_choice.side_effect = lambda x: x[i % len(x)] if x else ""
                
                result = namer.generate_name("goblin")
                results.add(result)
                assert isinstance(result, str)
                assert len(result) > 0
        
        # Должно быть хотя бы одно уникальное имя
        assert len(results) >= 1

    def test_generate_name_fallback_on_template_error(self):
        """Тест резервного имени при ошибке в шаблоне."""
        namer = TemplateMonsterNamer()
        namer.word_data = {
            "adjectives": ["страшный"],
            "nouns": ["гоблин"],
            "prefixes": ["супер"],
            "suffixes": ["младший"]
        }
        
        # Создаем ситуацию с некорректным шаблоном
        with patch('random.choice') as mock_choice:
            def choice_side_effect(options):
                # Возвращаем некорректный шаблон
                if isinstance(options, list) and len(options) > 0:
                    return "{nonexistent_key}"  # Несуществующий ключ
                return "резерв"
            mock_choice.side_effect = choice_side_effect
            
            result = namer.generate_name("test")
            
            # Должно вернуть резервное имя
            assert isinstance(result, str)
            assert len(result) > 0


class TestGlobalFunctions:
    """Тесты для глобальных функций модуля."""

    def test_get_default_namer_singleton(self):
        """Тест что get_default_namer возвращает один и тот же экземпляр."""
        # Сбрасываем глобальную переменную
        import game.naming.template_namer
        game.naming.template_namer._DEFAULT_NAMER = None
        
        # Импортируем функцию напрямую
        from game.naming.template_namer import get_default_namer
        namer1 = get_default_namer()
        namer2 = get_default_namer()
        
        assert namer1 is namer2
        assert isinstance(namer1, TemplateMonsterNamer)

    @patch('game.naming.template_namer.get_default_namer')
    def test_generate_monster_name_function(self, mock_get_namer):
        """Тест функции generate_monster_name."""
        from unittest.mock import MagicMock
        mock_namer = MagicMock()
        mock_namer.generate_name.return_value = "Тестовый Монстр"
        mock_get_namer.return_value = mock_namer
        
        result = generate_monster_name("goblin")
        assert result == "Тестовый Монстр"
        mock_get_namer.assert_called_once()
        mock_namer.generate_name.assert_called_once_with("goblin")


class TestIntegration:
    """Интеграционные тесты."""

    def test_basic_functionality(self):
        """Тест базовой функциональности."""
        namer = TemplateMonsterNamer()
        assert isinstance(namer.word_data, dict)
        
        # Даже с пустыми данными должен возвращать имя
        name = namer.generate_name("test_monster")
        assert isinstance(name, str)
        assert len(name) > 0


if __name__ == "__main__":
    pytest.main([__file__])

================================================================================
Файл: tests/test_ui/test_mixins.py
================================================================================

# tests/test_ui/test_mixins.py
"""Тесты для миксинов UI."""

import unittest
from unittest.mock import Mock, patch

# Предполагаем, что LayoutProtocol импортируется отсюда
from game.ui.mixins import FooterMixin, HeaderMixin, LayoutProtocol, StandardLayoutMixin
from game.ui.rendering.color_manager import Color


# Явно наследуем от LayoutProtocol
class _TestLayoutProtocol(LayoutProtocol):
    """Тестовая реализация LayoutProtocol для миксинов."""

    def __init__(self) -> None:
        """Инициализация тестового протокола."""
        # Инициализируем атрибуты, ожидаемые LayoutProtocol
        # Используем Mock для имитации реальных объектов
        self.renderer: Mock = Mock() 
        self.command_registry: Mock = Mock()
        # Явно указываем типы атрибутов, чтобы mypy знал, что они существуют
        # Типы Mock подойдут, так как они будут иметь необходимые атрибуты во время теста

    # Заглушки для абстрактных методов протокола, чтобы mypy не считал класс абстрактным
    def render_header(self, title: str) -> None:
        pass

    def render_footer(self) -> None:
        pass


class HeaderMixinTest(unittest.TestCase):
    """Тесты для HeaderMixin."""

    def setUp(self) -> None:
        """Настройка тестового окружения."""
        # Теперь TestHeaderClass наследуется от HeaderMixin и _TestLayoutProtocol,
        # который реализует LayoutProtocol. MyPy должен принять это.
        class TestHeaderClass(HeaderMixin, _TestLayoutProtocol):
            pass

        # mypy думает, что TestHeaderClass абстрактный из-за нереализованных методов протокола
        # Но для тестирования миксина это приемлемо
        self.test_instance = TestHeaderClass()  # type: ignore
        # Настройка моков
        self.test_instance.renderer.width = 20
        self.test_instance.renderer.height = 10

    @patch('game.ui.mixins.Text')
    @patch('game.ui.mixins.Separator')
    def test_render_header(self, mock_separator, mock_text) -> None:
        """Тест отрисовки заголовка."""
        title = "Test Title"

        # Этот вызов теперь должен пройти проверку mypy
        self.test_instance.render_header(title)
        
        # Проверяем, что Text был создан с правильными параметрами
        mock_text.assert_called_once_with(
            title, 5, 0, bold=True, color=Color.CYAN
        )
        
        # Проверяем, что render был вызван у текста
        mock_text.return_value.render.assert_called_once_with(
            self.test_instance.renderer
        )
        
        # Проверяем, что Separator был создан и отрисован
        mock_separator.assert_called_once_with(1, color=Color.DEFAULT)
        mock_separator.return_value.render.assert_called_once_with(
            self.test_instance.renderer
        )

    @patch('game.ui.mixins.Text')
    @patch('game.ui.mixins.Separator')
    def test_render_header_centering_with_short_title(self, mock_separator, mock_text) -> None:
        """Тест центрирования короткого заголовка."""
        title = "A"
        self.test_instance.renderer.width = 20

        self.test_instance.render_header(title)

        # Заголовок должен быть центрирован: (20 - 1) // 2 = 9
        mock_text.assert_called_once_with(
            title, 9, 0, bold=True, color=Color.CYAN
        )

    @patch('game.ui.mixins.Text')
    @patch('game.ui.mixins.Separator')
    def test_render_header_centering_with_long_title(self, mock_separator, mock_text) -> None:
        """Тест центрирования длинного заголовка."""
        title = "Very Long Title That Exceeds Width"
        self.test_instance.renderer.width = 20

        self.test_instance.render_header(title)

        # При отрицательном значении x должен быть 0
        mock_text.assert_called_once_with(
            title, 0, 0, bold=True, color=Color.CYAN
        )


class FooterMixinTest(unittest.TestCase):
    """Тесты для FooterMixin."""

    def setUp(self) -> None:
        """Настройка тестового окружения."""
        class TestFooterClass(FooterMixin, _TestLayoutProtocol):
            pass

        self.test_instance = TestFooterClass()  # type: ignore
        self.test_instance.renderer.width = 20
        self.test_instance.renderer.height = 10

        # Мокаем команды
        self.mock_commands = [Mock(), Mock()]
        self.test_instance.command_registry.get_all_commands.return_value = self.mock_commands

    @patch('game.ui.mixins.Separator')
    @patch('game.ui.mixins.CommandRenderer')
    def test_render_footer(self, mock_command_renderer, mock_separator) -> None:
        """Тест отрисовки подвала."""
        # Настраиваем моки
        mock_command_elements = [Mock(), Mock()]
        mock_command_renderer_instance = mock_command_renderer.return_value
        mock_command_renderer_instance.render_commands.return_value = mock_command_elements

        self.test_instance.render_footer()

        # Проверяем вызов get_all_commands
        self.test_instance.command_registry.get_all_commands.assert_called_once()

        # Проверяем создание и отрисовку разделителя подвала
        mock_separator.assert_called_once_with(8, color=Color.GRAY)
        mock_separator.return_value.render.assert_called_once_with(
            self.test_instance.renderer
        )

        # Проверяем создание CommandRenderer
        mock_command_renderer.assert_called_once_with(y=9)

        # Проверяем вызов render_commands
        mock_command_renderer_instance.render_commands.assert_called_once_with(
            self.mock_commands
        )

        # Проверяем, что render был вызван у каждого элемента команд
        for element in mock_command_elements:
            element.render.assert_called_once_with(self.test_instance.renderer)

    @patch('game.ui.mixins.Separator')
    @patch('game.ui.mixins.CommandRenderer')
    def test_render_footer_with_small_height(self, mock_command_renderer, mock_separator) -> None:
        """Тест отрисовки подвала при малой высоте."""
        self.test_instance.renderer.height = 1

        # Настраиваем моки
        mock_command_elements = [Mock()]
        mock_command_renderer_instance = mock_command_renderer.return_value
        mock_command_renderer_instance.render_commands.return_value = mock_command_elements

        self.test_instance.render_footer()

        # При высоте 1: footer_separator_y = max(0, 1-2) = 0, commands_y = max(0, 1-1) = 0
        mock_separator.assert_called_once_with(0, color=Color.GRAY)
        mock_command_renderer.assert_called_once_with(y=0)


class StandardLayoutMixinTest(unittest.TestCase):
    """Тесты для StandardLayoutMixin."""

    def setUp(self) -> None:
        """Настройка тестового окружения."""
        class TestStandardLayoutClass(StandardLayoutMixin, _TestLayoutProtocol):
            pass

        self.test_instance = TestStandardLayoutClass()  # type: ignore
        self.test_instance.renderer.width = 20
        self.test_instance.renderer.height = 10

    @patch('game.ui.mixins.Text')
    @patch('game.ui.mixins.Separator')
    @patch('game.ui.mixins.CommandRenderer')
    def test_render_standard_layout(self, mock_command_renderer, mock_separator, mock_text) -> None:
        """Тест отрисовки стандартного макета."""
        # Настраиваем моки для подвала
        mock_command_elements = [Mock()]
        mock_command_renderer_instance = mock_command_renderer.return_value
        mock_command_renderer_instance.render_commands.return_value = mock_command_elements
        self.test_instance.command_registry.get_all_commands.return_value = [Mock()]

        title = "Standard Layout"  # Длина 14 символов
        expected_x = max(0, (self.test_instance.renderer.width - len(title)) // 2)  # 20 - 14 = 6 // 2 = 3

        self.test_instance.render_standard_layout(title)

        # Проверяем вызов render_header - используем вычисленное значение expected_x
        mock_text.assert_called_once_with(
            title, expected_x, 0, bold=True, color=Color.CYAN
        )
        mock_text.return_value.render.assert_called_once_with(
            self.test_instance.renderer
        )

        # Проверяем, что были вызваны оба разделителя (один из header, один из footer)
        self.assertEqual(mock_separator.call_count, 2)

        # Проверяем вызов CommandRenderer
        mock_command_renderer.assert_called_once_with(y=9)


if __name__ == '__main__':
    unittest.main()


================================================================================
Файл: tests/test_ui/test_widgets.py
================================================================================

# tests/test_ui/test_widgets.py
"""Тесты для виджетов UI (game/ui/widgets/)."""

import pytest
from unittest.mock import Mock, patch, MagicMock
from typing import Any, Dict, List, Optional

# Импортируем тестируемые классы
from game.ui.widgets.labels import (
    TextLabel,
    CharacterNameLabel,
    CharacterClassLabel,
    CharacterLevelLabel,
    TemplatedTextLabel
)
from game.ui.widgets.bars import (
    ProgressBar,
    HealthBar,
    EnergyBar
)
from game.ui.widgets.character_card import CharacterInfoPanel

# Для аннотаций типов и создания моков
from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderer import Renderer

# === Фикстуры ===

@pytest.fixture
def mock_renderer() -> Mock:
    """Фикстура для создания мок-рендерера."""
    return Mock(spec=Renderer)


@pytest.fixture
def mock_character() -> Mock:
    """Фикстура для создания мок-персонажа."""
    character = Mock()
    character.name = "Тестовый Герой"
    character.level = 5
    character.role = "Воин"
    character.player_class = None  # Для проверки логики получения роли
    character.hp = 80
    character.energy = 30
    character.attributes = Mock()
    character.attributes.max_hp = 100
    character.attributes.max_energy = 50
    return character


@pytest.fixture
def mock_player_with_class(mock_character: Mock) -> Mock:
    """Фикстура для создания мок-игрока с классом."""
    player_class = Mock()
    player_class.name = "Paladin"
    mock_character.player_class = player_class
    mock_character.role = None  # У игрока role может быть None
    return mock_character


# === Тесты для labels.py ===

class TestTextLabel:
    """Тесты для TextLabel."""

    def test_initialization(self) -> None:
        """Тест инициализации TextLabel."""
        label = TextLabel(x=1, y=2, text="Привет", color=Color.RED, bold=True, dim=False)
        assert label.x == 1
        assert label.y == 2
        assert label.text == "Привет"
        assert label.color == Color.RED
        assert label.bold is True
        assert label.dim is False

    def test_render(self, mock_renderer: Mock) -> None:
        """Тест отрисовки TextLabel."""
        label = TextLabel(x=5, y=3, text="Тест", color=Color.BLUE, bold=False, dim=True)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Тест", 5, 3, False, True, Color.BLUE)

    def test_render_empty_text(self, mock_renderer: Mock) -> None:
        """Тест отрисовки TextLabel с пустым текстом."""
        label = TextLabel(x=0, y=0, text="")
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_not_called()


class TestCharacterNameLabel:
    """Тесты для CharacterNameLabel."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации CharacterNameLabel."""
        label = CharacterNameLabel(x=1, y=1, character=mock_character, max_width=15)
        assert label.x == 1
        assert label.y == 1
        assert label.character is mock_character
        assert label.max_width == 15
        # Текст должен обновиться из персонажа
        assert label.text == "Тестовый Герой"

    def test_set_character(self, mock_character: Mock) -> None:
        """Тест установки персонажа."""
        label = CharacterNameLabel(x=0, y=0)
        assert label.text == "Unknown"
        label.set_character(mock_character)
        assert label.character is mock_character
        assert label.text == "Тестовый Герой"

    def test_render_with_max_width(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки с ограничением ширины."""
        long_name_character = Mock()
        long_name_character.name = "Очень Длинное Имя Персонажа"
        label = CharacterNameLabel(x=2, y=2, character=long_name_character, max_width=10)
        label.render(mock_renderer)
        # Ожидаем, что текст будет обрезан до 10 символов
        mock_renderer.draw_text.assert_called_once_with("Очень Длин", 2, 2, False, False, Color.DEFAULT)

    def test_render_no_character(self, mock_renderer: Mock) -> None:
        """Тест отрисовки без персонажа."""
        label = CharacterNameLabel(x=3, y=3)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Unknown", 3, 3, False, False, Color.DEFAULT)


class TestCharacterClassLabel:
    """Тесты для CharacterClassLabel."""

    def test_initialization_with_role(self, mock_character: Mock) -> None:
        """Тест инициализации с ролью."""
        label = CharacterClassLabel(x=1, y=1, character=mock_character)
        assert label.x == 1
        assert label.y == 1
        assert label.character is mock_character

    def test_render_with_role(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки с ролью."""
        label = CharacterClassLabel(x=4, y=4, character=mock_character)
        label.render(mock_renderer)
        
        # Проверяем вызов draw_template
        mock_renderer.draw_template.assert_called_once()
        args, kwargs = mock_renderer.draw_template.call_args
        template, replacements = args[0], args[1]
        assert template == "%1%2%3"
        assert replacements["1"] == ("[", Color.WHITE, False, False)
        assert replacements["2"] == ("В", Color.CYAN, False, False) # Первая буква
        assert replacements["3"] == ("]", Color.WHITE, False, False)

    def test_render_with_player_class(self, mock_renderer: Mock, mock_player_with_class: Mock) -> None:
        """Тест отрисовки с классом игрока."""
        label = CharacterClassLabel(x=5, y=5, character=mock_player_with_class)
        label.render(mock_renderer)
        
        mock_renderer.draw_template.assert_called_once()
        args, kwargs = mock_renderer.draw_template.call_args
        template, replacements = args[0], args[1]
        assert template == "%1%2%3"
        assert replacements["2"] == ("N", Color.CYAN, False, False) # Первая буква Паладина

    def test_render_no_character(self, mock_renderer: Mock) -> None:
        """Тест отрисовки без персонажа."""
        label = CharacterClassLabel(x=6, y=6)
        label.render(mock_renderer)
        
        mock_renderer.draw_template.assert_called_once()
        args, kwargs = mock_renderer.draw_template.call_args
        replacements = args[1]
        assert replacements["2"] == ("?", Color.CYAN, False, False) # Заглушка


class TestCharacterLevelLabel:
    """Тесты для CharacterLevelLabel."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации CharacterLevelLabel."""
        label = CharacterLevelLabel(x=1, y=1, character=mock_character)
        assert label.x == 1
        assert label.y == 1
        assert label.character is mock_character

    def test_render_with_character(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки с персонажем."""
        label = CharacterLevelLabel(x=7, y=7, character=mock_character)
        label.render(mock_renderer)
        
        mock_renderer.draw_template.assert_called_once()
        args, kwargs = mock_renderer.draw_template.call_args
        template, replacements = args[0], args[1]
        assert template == "%1%2%3"
        assert replacements["1"] == ("[", Color.WHITE, False, False)
        assert replacements["2"] == ("5", Color.YELLOW, False, False) # Уровень 5
        assert replacements["3"] == ("]", Color.WHITE, False, False)

    def test_render_no_character(self, mock_renderer: Mock) -> None:
        """Тест отрисовки без персонажа."""
        label = CharacterLevelLabel(x=8, y=8)
        label.render(mock_renderer)
        
        mock_renderer.draw_template.assert_called_once()
        args, kwargs = mock_renderer.draw_template.call_args
        replacements = args[1]
        assert replacements["2"] == ("1", Color.YELLOW, False, False) # Уровень по умолчанию


class TestTemplatedTextLabel:
    """Тесты для абстрактного TemplatedTextLabel."""

    def test_initialization(self) -> None:
        """Тест инициализации TemplatedTextLabel."""
        # Напрямую создать экземпляр абстрактного класса нельзя,
        # но можно проверить его базовую инициализацию
        with patch.multiple(TemplatedTextLabel, __abstractmethods__=set()):
            label = TemplatedTextLabel(x=1, y=1)
            assert label.x == 1
            assert label.y == 1

    def test_render_calls_abstract_method(self) -> None:
        """Тест, что render вызывает абстрактный метод."""
        with patch.multiple(TemplatedTextLabel, __abstractmethods__=set()):
            label = TemplatedTextLabel(x=0, y=0)
            with patch.object(label, '_get_template_and_replacements') as mock_get_template:
                mock_get_template.return_value = ("Шаблон", {"1": ("Тест", Color.DEFAULT, False, False)})
                mock_renderer = Mock()
                
                label.render(mock_renderer)
                
                mock_get_template.assert_called_once()
                mock_renderer.draw_template.assert_called_once_with(
                    "Шаблон", {"1": ("Тест", Color.DEFAULT, False, False)}, 0, 0
                )


# === Тесты для bars.py ===

class TestProgressBar:
    """Тесты для абстрактного ProgressBar."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации ProgressBar."""
        # Напрямую создать экземпляр абстрактного класса нельзя,
        # но можно проверить его базовую инициализацию
        with patch.multiple(ProgressBar, __abstractmethods__=set()):
            bar = ProgressBar(x=1, y=1, width=20, character=mock_character)
            assert bar.x == 1
            assert bar.y == 1
            assert bar.width == 20
            assert bar.character is mock_character

    # Дополнительные тесты для абстрактного класса могут быть сложными,
    # так как они зависят от реализации абстрактных методов


class TestHealthBar:
    """Тесты для HealthBar."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации HealthBar."""
        bar = HealthBar(x=2, y=2, width=15, character=mock_character)
        assert bar.x == 2
        assert bar.y == 2
        assert bar.width == 15
        assert bar.character is mock_character

    def test_get_fill_color_high_hp(self, mock_character: Mock) -> None:
        """Тест цвета заполнения при высоком HP."""
        mock_character.hp = 90
        mock_character.attributes.max_hp = 100
        bar = HealthBar(character=mock_character)
        assert bar._get_fill_color() == Color.GREEN

    def test_get_fill_color_medium_hp(self, mock_character: Mock) -> None:
        """Тест цвета заполнения при среднем HP."""
        mock_character.hp = 40
        mock_character.attributes.max_hp = 100
        bar = HealthBar(character=mock_character)
        assert bar._get_fill_color() == Color.YELLOW

    def test_get_fill_color_low_hp(self, mock_character: Mock) -> None:
        """Тест цвета заполнения при низком HP."""
        mock_character.hp = 10
        mock_character.attributes.max_hp = 100
        bar = HealthBar(character=mock_character)
        assert bar._get_fill_color() == Color.RED

    def test_get_fill_color_no_character(self) -> None:
        """Тест цвета заполнения без персонажа."""
        bar = HealthBar()
        assert bar._get_fill_color() == Color.GREEN # Цвет по умолчанию


class TestEnergyBar:
    """Тесты для EnergyBar."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации EnergyBar."""
        bar = EnergyBar(x=3, y=3, width=10, character=mock_character)
        assert bar.x == 3
        assert bar.y == 3
        assert bar.width == 10
        assert bar.character is mock_character

    def test_get_fill_color(self, mock_character: Mock) -> None:
        """Тест цвета заполнения."""
        bar = EnergyBar(character=mock_character)
        assert bar._get_fill_color() == Color.BLUE

    def test_get_empty_color(self, mock_character: Mock) -> None:
        """Тест цвета пустой части."""
        bar = EnergyBar(character=mock_character)
        assert bar._get_empty_color() == Color.GRAY


# === Тесты для character_card.py ===

class TestCharacterInfoPanel:
    """Тесты для CharacterInfoPanel."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации CharacterInfoPanel."""
        panel = CharacterInfoPanel(x=1, y=1, width=30, height=5, character=mock_character)
        assert panel.x == 1
        assert panel.y == 1
        assert panel.width == 30
        assert panel.height == 5
        assert panel.character is mock_character
        # Проверяем, что дочерние виджеты созданы
        assert panel.class_label is not None
        assert panel.name_label is not None
        assert panel.level_label is not None
        assert panel.health_bar is not None
        assert panel.energy_bar is not None

    def test_set_character(self, mock_character: Mock) -> None:
        """Тест установки персонажа."""
        panel = CharacterInfoPanel(x=0, y=0, width=20, height=3)
        # Изначально персонаж не установлен
        assert panel.character is None
        # Устанавливаем персонажа
        panel.set_character(mock_character)
        # Проверяем, что персонаж установлен
        assert panel.character is mock_character
        # Проверяем, что персонаж установлен во всех дочерних виджетах
        # (предполагаем, что у них есть метод set_character)
        # Для простоты проверим, что методы были вызваны
        # (это косвенно подтверждает, что логика внутри set_character работает)

    def test_render(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки панели."""
        panel = CharacterInfoPanel(x=5, y=5, width=25, height=4, character=mock_character)
        
        # Мокаем методы render дочерних виджетов
        panel.class_label.render = Mock()
        panel.name_label.render = Mock()
        panel.level_label.render = Mock()
        panel.health_bar.render = Mock()
        panel.energy_bar.render = Mock()
        
        panel.render(mock_renderer)
        
        # Проверяем, что методы render были вызваны у всех дочерних виджетов
        panel.class_label.render.assert_called_once_with(mock_renderer)
        panel.name_label.render.assert_called_once_with(mock_renderer)
        panel.level_label.render.assert_called_once_with(mock_renderer)
        panel.health_bar.render.assert_called_once_with(mock_renderer)
        panel.energy_bar.render.assert_called_once_with(mock_renderer)

    def test_update_size(self) -> None:
        """Тест обновления размеров панели."""
        panel = CharacterInfoPanel(x=0, y=0, width=20, height=3)
        initial_width = panel.width
        initial_height = panel.height
        
        # Сохраняем ссылки на дочерние виджеты
        class_label = panel.class_label
        name_label = panel.name_label
        level_label = panel.level_label
        health_bar = panel.health_bar
        energy_bar = panel.energy_bar
        
        # Обновляем размеры
        new_width, new_height = 40, 6
        panel.update_size(new_width, new_height)
        
        # Проверяем, что размеры панели обновились
        assert panel.width == new_width
        assert panel.height == new_height
        
        # Проверяем, что размеры и позиции дочерних виджетов обновились
        # (проверяем, что объекты остались теми же, но их атрибуты могли измениться)
        assert panel.class_label is class_label
        assert panel.name_label is name_label
        assert panel.level_label is level_label
        assert panel.health_bar is health_bar
        assert panel.energy_bar is energy_bar
        # Проверяем, что ширина прогресс-баров обновилась
        assert panel.health_bar.width == new_width
        assert panel.energy_bar.width == new_width


================================================================================
Файл: main.py
================================================================================

# main.py
import curses
from game.ui import ScreenManager
from game.game_manager import get_game_manager

# ВАЖНО: Импортируем команды, чтобы они зарегистрировались
import game.ui.commands.inventory_commands
import game.ui.commands.battle_commands
import game.ui.commands.main_screen_commands


def main(stdscr: curses.window) -> None:
    """Главная функция curses приложения."""
    curses.curs_set(0) # Скрыть курсор

    # --- Инициализация игрового состояния ---
    game_manager = get_game_manager()

    # --- Инициализация менеджера экранов с группой игроков ---
    manager = ScreenManager(stdscr, game_manager)
    manager.run()


if __name__ == "__main__":
    curses.wrapper(main)


================================================================================
Файл: guide/style_guide.md
================================================================================

# Руководство по стилю кода проекта Battler

Этот документ описывает принятые стандарты кодирования для проекта Battler. Следование этим правилам помогает обеспечить согласованность, читаемость и поддерживаемость кода.

## 1. Общие принципы

* **Язык:** Весь код, комментарии и docstrings пишутся на русском языке.
* **PEP 8:** Соблюдаем рекомендации [PEP 8](https://peps.python.org/pep-0008/) по оформлению кода Python.
* **Аннотации типов:** Используем аннотации типов (`typing`) для всех параметров функций, методов и возвращаемых значений.
* **Именование:**
  * Переменные, функции, методы: `snake_case`.
  * Классы: `PascalCase`.
  * Константы: `UPPER_CASE_WITH_UNDERSCORES`.
* **Пустые строки:** Используем пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
* **Константы:** Именуем константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.
* Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.

## 2. Структура файла

Файлы должны следовать этой структуре сверху вниз:

1. **Комментарий модуля (Docstring):** Первая строка файла. Подробно описывает назначение модуля.
2. **Импорты:**
   * Стандартная библиотека (например, `os`, `json`, `typing`).
   * Сторонние библиотеки (например, `curses`, `dataclasses`).
   * Локальные импорты (например, `from game.protocols import ...`).
   * Импорты внутри `if TYPE_CHECKING:` располагаются после основных импортов.
3. **Константы модуля:** Если используются.
4. **Классы и функции:** Основное содержимое модуля.

## 3. Комментарии и Docstrings

* **Язык:** Все комментарии и docstrings на русском языке.
* **Docstrings:** Используем docstrings для всех модулей, классов, функций и методов.
* **Стиль:** Docstring следует стилю Google, описывая `Args` для каждого параметра конструктора.
* При длинных списках параметров допускается перенос аргументов `__init__` на новые строки с выравниванием.

## 4. Функции и методы

* **Именование:** Использовать `snake_case`.
* **Docstrings:** Все публичные (не начинающиеся с `_`) функции и методы должны иметь docstring в стиле Google.
* **Аннотации типов:** Использовать аннотации типов для всех параметров и возвращаемых значений (см. `typing`).
* **Длина:** Функции и методы должны быть компактными и выполнять одну задачу. Избегать чрезмерной длины.

## 5. Классы

* **Именование:** Использовать `PascalCase`.
* **Docstrings:** Классы должны иметь docstring, описывающий их назначение и основные атрибуты/методы.
* **Атрибуты:** Атрибуты класса, если не очевидны из контекста, должны быть задокументированы в docstring класса или аннотированы типами.
* **Методы:** См. раздел "Функции и методы".

## 6. Обработка ошибок

* **Исключения:** Использовать встроенные исключения Python (`ValueError`, `TypeError`, `FileNotFoundError` и т.д.) при возможности. Создавать собственные исключения только при необходимости.
* **Блоки try/except:** Использовать для обработки ожидаемых ошибок. Не подавлять исключения без логгирования или обработки.
* **finally:** Использовать для кода, который должен выполниться в любом случае (например, закрытие файлов).

Пример обработки ошибок:

```python
try:
    with open("config.json", 'r', encoding='utf-8') as f:
        data = json.load(f)
    # ... обработка данных ...
except FileNotFoundError:
    # Обработка отсутствия файла
    print("Файл конфигурации не найден, используются значения по умолчанию.")
    data = {}
except json.JSONDecodeError as e:
    # Обработка ошибки парсинга JSON
    print(f"Ошибка чтения конфигурации: Некорректный JSON. {e}")
    data = {}
except Exception as e:
    # Логирование или обработка других исключений
    # Пока просто выходим
    print(f"Критическая ошибка: {e}")
    exit()
```
## 7. Написание тестов

Тесты обеспечивают надежность и корректность кода. Для проекта Battler установлены следующие правила написания тестов с использованием `pytest`:

* **Фреймворк:** Использовать `pytest` для написания тестов. Все тесты должны находиться в директории `tests/`. Тесты должны быть простыми - и выдавать максимальное покрытие
* **Структура файлов тестов:**
  * Файлы тестов должны называться `test_<имя_модуля>.py`, где `<имя_модуля>` соответствует тестируемому файлу в основном коде (например, тесты для `game/entities/character.py` находятся в `tests/test_character.py`).
  * Внутри файлов тестов классы тестов именуются как `Test<ИмяКласса>` или `Test<ОписаниеФункционала>`.
  * Отдельные тестовые методы именуются как `test_<описание_теста>`.
* **Покрытие:**
  * Стремиться к высокому покрытию кода тестами, особенно для бизнес-логики.
  * Тестировать как нормальные сценарии, так и граничные условия и возможные ошибки.
* **Читаемость тестов:**
  * Тесты должны быть легко читаемыми и понятными.
  * Использовать понятные имена для переменных внутри тестов.
  * Комментарии в тестах допустимы для пояснения сложных сценариев подготовки данных.
* **Фикстуры:**
  * Использовать фикстуры `pytest` (`@pytest.fixture`) для подготовки и очистки общих ресурсов, объектов или данных, используемых в нескольких тестах.
  * Использовать декоратор `@pytest.mark.parametrize` для запуска одного и того же теста с разными наборами входных данных и ожидаемых результатов.
* **Маркировка тестов:**
  * Использовать марки (`@pytest.mark.slow`, `@pytest.mark.integration`) для классификации тестов и возможности выборочного запуска.
* **Docstrings для тестов:** Docstrings для тестов не обязательны, но могут быть полезны для сложных сценариев. Если используются, следовать стилю Google.

## 8. Прочее

* **Отступы:** 4 пробела.
* **Пробелы:** Следовать PEP 8 (пробелы вокруг операторов, после запятых и т.д.).
* **Пустые строки:** Использовать пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
* **Константы:** Именовать константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.
* Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.
* Не допускать магических чисел. Магические числа должны быть на именованные константы.

## 9. Принципы проектирования

* **SOLID и DRY:**
  * Следовать принципам [SOLID] для объектно-ориентированного проектирования.
    * **S** - Принцип единственной ответственности (Single Responsibility Principle).
    * **O** - Принцип открытости/закрытости (Open/Closed Principle).
    * **L** - Принцип подстановки Барбары Лисков (Liskov Substitution Principle).
    * **I** - Принцип разделения интерфейса (Interface Segregation Principle).
    * **D** - Принцип инверсии зависимостей (Dependency Inversion Principle).
  * Следовать принципу [DRY] (Don't Repeat Yourself) - избегать дублирования кода. Повторяющуюся логику следует выносить в функции, классы или модули.

* **KISS и YAGNI:**

  * Следовать принципу KISS  (Keep It Simple, Stupid) - стремиться к максимально простым решениям. Код должен быть понятен другим разработчикам без необходимости вникать в сложные абстракции.
  * Следовать принципу YAGNI  (You Aren't Gonna Need It) - реализовывать функциональность только тогда, когда она действительно нужна, а не потому, что "вдруг пригодится".

## 10. Рабочий процесс

* **Работа с TODO:**
  * **Перед началом работы:** Всегда уточнять, над какой конкретной задачей вы работаете.
  * **Поиск задачи:** Найти эту задачу в файле `PROJECT_TODO.md` в корне проекта.
  * **Если задачи нет:** Добавить новую задачу в секцию `## TODO` файла `PROJECT_TODO.md`, используя формат `<!-- TODO: Краткое описание задачи. -->`.
  * **Если задача есть:** Перед началом работы изменить тег задачи с `TODO` на `WIP` (Work In Progress) в файле `PROJECT_TODO.md`.
  * **После завершения:** Изменить тег задачи с `WIP` (или `TODO`, если забыли поменять) на `DONE` в файле `PROJECT_TODO.md`.

