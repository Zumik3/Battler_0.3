Сборник исходных кодов и конфигурационных файлов
Дата создания: 2025-08-17 22:38:42
================================================================================

================================================================================
Файл: PROJECT_TODO.md
================================================================================

# PROJECT TODO LIST

## Общее

<!-- DONE: Создать этот файл PROJECT_TODO.md и поместить в корень проекта -->
<!-- DONE: Настроить в IDE отображение TODO из этого файла (если необходимо, добавить паттерн в настройки TODO) -->

## Игровая логика & Менеджеры

<!-- DONE: Создать масштабируемую систему имен монстров -->
<!-- DONE: Интегрировать реальные данные монстров в BattleScreen. Связать EnemyGroupPanel с GameManager, чтобы панели отображали состояние объектов Character (монстров), созданных фабрикой. -->
<!-- DONE: Добавить загрузку стартовых монстров в GameManager._initialize_game_entities (или аналогичный метод), используя monster_factory. -->
<!-- DONE: Реализовать механизм обновления UI (HP/MP) в BattleScreen на основе текущего состояния объектов Player/Character. -->
<!-- DONE: Добавить в GameManager методы для управления текущими врагами (`get_current_enemies`, `set_current_enemies` и т.д.). -->
<!-- DONE: Создать JSON-файлы для классов монстров в `game/data/characters/monster_classes/`, если они еще не существуют. -->
<!-- TODO: GameManager должен отвечать за хранение и предоставление данных о текущих игроках и монстрах для экранов UI. -->
<!-- DONE: Описание задачи -->
<!-- TODO: Сделать централихованный обработчик ошибок -->
<!-- TODO: Сделать централихованный логгер -->


## Пользовательский Интерфейс

<!-- TODO: Доработать BattleScreen.render, чтобы он обновлял содержимое UnitPanel (имя, HP, MP) на основе данных из GameManager перед отрисовкой панелей. -->
<!-- TODO: Проверить/доработать логику `_update_component_sizes` в `BattleScreen` для корректного изменения размеров компонентов при ресайзе окна терминала. -->
<!-- TODO: Реализовать отображение имен монстров/игроков в UnitPanel (сейчас в EnemyUnitPanel имя передается вручную, нужно брать из объекта Character). -->
<!-- DONE: Улучшить визуал BattleScreen: корректное расположение игроков/монстров, настройка лога, порядок обрамления. -->

## Компоненты UI

<!-- TODO: Проверить корректность работы прокрутки BattleLog (scroll_up, scroll_down) и отображения большого количества сообщений. -->
<!-- TODO: Добавить отображение дополнительной информации в UnitPanel (например, уровень, статусные эффекты, если будут). -->
<!-- TODO: Убедиться, что отрисовка (render) всех компонентов корректно обрабатывает выход за границы экрана (curses.error). -->

## Данные

<!-- TODO: Убедиться, что все необходимые JSON-файлы (игроки, монстры) существуют и корректны. -->
<!-- TODO: Проверить/доработать character_loader.py для корректной обработки всех полей из JSON (например, abilities, если структура сложнее). -->

## Система Команд

<!-- TODO: Завершить рефакторинг системы команд (Command System) согласно ранее обсужденным идеям (регистрация, контекст). -->
<!-- TODO: Добавить команды для BattleScreen (например, выбор цели, использование атаки/зелья). -->

## Тестирование

### Конфигурация и Загрузка Данных
<!-- TODO: Написать тесты для game/config.py (загрузка, значения по умолчанию, обработка ошибок). -->
<!-- TODO: Написать тесты для game/data/character_loader.py (успешная загрузка, обработка отсутствующих файлов, некорректного JSON). -->
<!-- TODO: Написать тесты для game/naming/monster_namer.py (если используется отдельно от TemplateMonsterNamer). -->

### Основные Сущности и Фабрики
<!-- TODO: Написать тесты для фабрик в game/factories/ (PlayerFactory, MonsterFactory - корректное создание объектов из данных). -->

### Пользовательский Интерфейс (UI)
<!-- DONE: Написать тесты для game/ui/base_screen.py (общая логика экрана, обработка команд, рендеринг, если применимо). -->
<!-- TODO: Написать тесты для game/ui/main_screen.py (логика главного экрана, отрисовка, команды). -->
<!-- TODO: Написать тесты для game/ui/inventory_screen.py (логика экрана инвентаря, отрисовка, команды). -->
<!-- TODO: Написать тесты для game/ui/battle_screen.py (логика обновления данных, отрисовка компонентов, обработка команд боя). -->
<!-- TODO: Проверить и расширить тесты для компонентов UI в game/ui/widgets/ и game/ui/components/ (UnitPanel, GroupPanel, BattleLog, TextLabel, ProgressBar - граничные условия, взаимодействие, отрисовка). -->
<!-- TODO: Добавить тесты в tests/test_ui/test_command_system.py для проверки поведения абстрактного метода Command.execute (например, что он требует реализации или корректно аннотирован). -->

### Интеграционные тесты и Системные проверки
<!-- TODO: Добавить интеграционные тесты для проверки работы экранов с реальным GameManager, фабриками и рендерером (возможно, с моками curses). -->
<!-- TODO: Добавить тесты для интеграции GameManager с фабриками и UI. -->

## Документация/Кодстайл

<!-- TODO: Добавить/проверить docstrings для новых/измененных классов и методов. -->
<!-- TODO: Убедиться, что весь код соответствует PEP 8 и проходит flake8. -->

## DONE (переносить сюда выполненные задачи)

<!-- DONE: Реализовать фабрики для создания игроков и монстров. -->
<!-- DONE: Создать базовую структуру BattleScreen с компонентами (UnitPanel, GroupPanel, BattleLog). -->
<!-- DONE: Настроить базовую отрисовку BattleScreen с использованием Renderer. -->
<!-- DONE: Реализовать базовую прокрутку BattleLog. -->

================================================================================
Файл: game/__init__.py
================================================================================



================================================================================
Файл: game/config.py
================================================================================

# game/config.py
"""Основные настройки игры."""

from dataclasses import dataclass, field
from pathlib import Path
import json
import os
from typing import Any, Dict


@dataclass
class ExperienceSettings:
    """Настройки системы опыта."""
    formula_base: int = 100
    formula_multiplier: float = 1.5


@dataclass
class CombatSettings:
    """Настройки боевой системы."""
    min_damage: int = 1
    defense_reduction_factor: float = 0.5


@dataclass
class CharacterSettings:
    """Настройки персонажей."""
    base_max_hp: int = 50
    base_max_energy: int = 20
    hp_per_vitality: int = 5
    energy_per_intelligence: int = 3
    attack_per_strength: int = 2
    defense_per_agility: float = 1.5


@dataclass
class UISettings:
    """Настройки пользовательского интерфейса."""
    screen_width: int = 80
    screen_height: int = 24


@dataclass
class SystemSettings:
    """Системные настройки."""
    enable_debug_logging: bool = False
    log_file: str = "game.log"
    save_directory: str = "saves"
    autosave_interval: int = 300
    data_directory: str = "game/data"
    characters_data_directory: str = "game/data/characters"
    player_classes_directory: str = "game/data/characters/player_classes"
    monster_classes_directory: str = "game/data/characters/monster_classes"
    character_names_directory: str = "game/data/names"


@dataclass
class GameConfig:
    """Основной класс конфигурации игры."""

    experience: ExperienceSettings = field(default_factory=ExperienceSettings)
    combat: CombatSettings = field(default_factory=CombatSettings)
    character: CharacterSettings = field(default_factory=CharacterSettings)
    ui: UISettings = field(default_factory=UISettings)
    system: SystemSettings = field(default_factory=SystemSettings)

    config_file: str = "config.json"

    def load_from_file(self, config_file: str = "") -> None:
        """
        Загрузить конфигурацию из файла.
        """
        file_path = config_file or self.config_file
        try:
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self._update_from_dict(data)
        except Exception as e:
            print(f"Ошибка загрузки конфигурации из {file_path}: {e}")

    def save_to_file(self, config_file: str = "") -> None:
        """
        Сохранить конфигурацию в файл.
        """
        file_path = config_file or self.config_file
        try:
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self._to_dict(), f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"Ошибка сохранения конфигурации в {file_path}: {e}")

    def _to_dict(self) -> Dict[str, Any]:
        """Преобразовать конфигурацию в словарь."""
        return {
            'experience': {
                'formula_base': self.experience.formula_base,
                'formula_multiplier': self.experience.formula_multiplier,
            },
            'combat': {
                'min_damage': self.combat.min_damage,
                'defense_reduction_factor': self.combat.defense_reduction_factor,
            },
            'character': {
                'base_max_hp': self.character.base_max_hp,
                'base_max_energy': self.character.base_max_energy,
                'hp_per_vitality': self.character.hp_per_vitality,
                'energy_per_intelligence': self.character.energy_per_intelligence,
                'attack_per_strength': self.character.attack_per_strength,
                'defense_per_agility': self.character.defense_per_agility,
            },
            'ui': {
                'screen_width': self.ui.screen_width,
                'screen_height': self.ui.screen_height,
            },
            'system': {
                'enable_debug_logging': self.system.enable_debug_logging,
                'log_file': self.system.log_file,
                'save_directory': self.system.save_directory,
                'autosave_interval': self.system.autosave_interval,
                'data_directory': self.system.data_directory,
                'characters_data_directory': self.system.characters_data_directory,
                'player_classes_directory': self.system.player_classes_directory,
                'monster_classes_directory': self.system.monster_classes_directory,  # ✅ Добавлено
                'character_names_directory': self.system.character_names_directory,   # ✅ Добавлено
            }
        }

    def _update_from_dict(self, data: Dict[str, Any]) -> None:
        """
        Обновить конфигурацию из словаря.
        """
        if 'experience' in data:
            for key, value in data['experience'].items():
                if hasattr(self.experience, key):
                    setattr(self.experience, key, value)

        if 'combat' in data:
            for key, value in data['combat'].items():
                if hasattr(self.combat, key):
                    setattr(self.combat, key, value)

        if 'character' in data:
            for key, value in data['character'].items():
                if hasattr(self.character, key):
                    setattr(self.character, key, value)

        if 'ui' in data:
            for key, value in data['ui'].items():
                if hasattr(self.ui, key):
                    setattr(self.ui, key, value)

        if 'system' in data:
            for key, value in data['system'].items():
                if hasattr(self.system, key):
                    setattr(self.system, key, value)


# Глобальный экземпляр конфигурации
game_config = GameConfig()


def get_config() -> GameConfig:
    """Получить глобальный экземпляр конфигурации."""
    return game_config

================================================================================
Файл: game/protocols.py
================================================================================

# game/protocols.py
"""Протоколы, определяющие интерфейсы для различных компонентов игры."""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Protocol, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType
    from game.results import ActionResult, ExperienceGainedResult
    from game.config import GameConfig

# ==================== Базовые протоколы данных ====================

class Stats(Protocol):
    """Протокол для базовых характеристик персонажа."""
    strength: int
    agility: int
    intelligence: int
    vitality: int

class Attributes(Protocol):
    """Протокол для производных атрибутов персонажа."""
    max_hp: int
    max_energy: int
    attack_power: int
    defense: int

    def recalculate(self, stats: Stats, config: 'GameConfig') -> None:
        """Пересчитать атрибуты на основе базовых характеристик."""
        ...

# ==================== Протоколы игровых систем ====================

class AbilityManagerProtocol(Protocol):
    """Протокол для менеджера способностей."""
    def add_ability(self, ability: 'Ability') -> List['ActionResult']:
        """Добавляет способность персонажу."""
        ...

    def use_ability(self, ability_name: str, target: List['CharacterType'], **kwargs) -> List['ActionResult']:
        """Использовать способность на цель."""
        ...

    def get_available_abilities(self) -> List['Ability']:
        """Получить список доступных способностей."""
        ...

    def update_cooldowns(self) -> List['ActionResult']:
        """Обновить кулдауны способностей."""
        ...

class StatusEffectManagerProtocol(Protocol):
    """Протокол для менеджера статус-эффектов."""
    def apply_effect(self, effect: 'StatusEffect') -> List['ActionResult']:
        """Применить эффект к персонажу."""
        ...

    def remove_effect(self, effect_name: str) -> List['ActionResult']:
        """Удалить эффект по имени."""
        ...

    def update_effects(self) -> List['ActionResult']:
        """Обновить эффекты."""
        ...

    def get_effect(self, effect_name: str) -> Optional['StatusEffect']:
        """Получить эффект по имени."""
        ...

    def get_all_effects(self) -> List['StatusEffect']:
        """Получить список всех активных эффектов."""
        ...

    def clear_all_effects(self) -> List['ActionResult']:
        """Очистить все эффекты и вернуть список результатов."""
        ...

# ==================== Протоколы систем опыта и уровней ====================

class ExperienceCalculatorProtocol(Protocol):
    def calculate_exp_for_next_level(self, current_level: int) -> int:
        """Рассчитывает опыт, необходимый для следующего уровня."""
        ...

class LevelUpHandlerProtocol(Protocol):
    def handle_level_up(self, character: 'CharacterType') -> List['ActionResult']:
        """Обрабатывает повышение уровня и возвращает результаты."""
        ...

class ExperienceSystemProtocol(Protocol):
    def add_experience(self, character: 'CharacterType', amount: int) -> List['ExperienceGainedResult']:
        """Добавляет опыт персонажу и возвращает результаты."""
        ...

class LevelingSystemProtocol(Protocol):
    def try_level_up(self, character: 'CharacterType') -> List['ActionResult']:
        """Проверяет и выполняет повышение уровня, если возможно."""
        ...

# ==================== Протоколы генераторов ====================

class MonsterNamerProtocol(Protocol):
    """Протокол для генератора имен монстров."""
    
    def generate_name(self, monster_role: str) -> str:
        """
        Генерирует имя для монстра на основе его роли.

        Args:
            monster_role: Роль/тип монстра (например, 'goblin', 'dragon').

        Returns:
            Сгенерированное имя.
        """
        ...

# ==================== Базовые абстрактные классы ====================

class Character(ABC):
    """Абстрактный базовый класс, представляющий персонажа в игре."""
    pass

class Ability(ABC):
    """Абстрактный базовый класс для способностей."""
    def __init__(self, name: str, energy_cost: int, description: str = ""):
        self.name = name
        self.energy_cost = energy_cost
        self.description = description

    @abstractmethod
    def activate(self, caster: 'CharacterType', target: 'CharacterType') -> List['ActionResult']:
        """Активировать способность."""
        ...

class StatusEffect(ABC):
    """Абстрактный базовый класс для статус-эффектов."""
    def __init__(self, name: str, duration: int, description: str = ""):
        self.name = name
        self.duration = duration
        self.description = description

    @abstractmethod
    def apply(self, target: 'CharacterType') -> List['ActionResult']:
        """Применить эффект к цели."""
        ...

    @abstractmethod
    def remove(self, target: 'CharacterType') -> List['ActionResult']:
        """Удалить эффект с цели."""
        ...

    def tick(self, target: 'CharacterType') -> List['ActionResult']:
        """Выполнить действие эффекта за ход (если применимо)."""
        self.duration -= 1
        if self.duration <= 0:
            # Сигнализируем, что эффект нужно удалить
            return [ActionResult(type="effect_expired", message=f"Эффект {self.name} истек")]
        return []

    @property
    def is_expired(self) -> bool:
        """Проверить, истек ли эффект."""
        return self.duration <= 0

================================================================================
Файл: game/game_manager.py
================================================================================

# game/game_manager.py
"""Менеджер игрового состояния."""

from typing import Any, Dict, List, Optional, TYPE_CHECKING
from game.config import get_config

if TYPE_CHECKING:
    from game.entities.player import Player
    from game.entities.monster import Monster

class GameManager:
    """Менеджер игрового состояния."""
    
    _instance: Optional['GameManager'] = None

    def __new__(cls) -> 'GameManager':
        """Реализация паттерна Singleton."""
        if cls._instance is None:
            cls._instance = super(GameManager, cls).__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        """Инициализирует менеджер игры и загружает начальное состояние."""
        if hasattr(self, 'initialized'):
            return

        self.config = get_config()
        self.player_group: List['Player'] = []
        self.current_enemies: List['Monster'] = []
        
        self._initialize_game_entities()
        self.initialized = True

    def _initialize_game_entities(self) -> None:
        """Создает и инициализирует стартовые сущности игры."""
        player_data_dir = self.config.system.player_classes_directory
        
        # Инициализация игроков
        starting_players = {
            "Роланд": "berserker",
            "Стайлс": "rogue", 
            "Морган": "mage",
            "Дамиан": "healer"
        }
        
        self._create_players(starting_players, player_data_dir)
        self._create_initial_enemies()

    def _create_players(self, player_data: Dict[str, str], data_dir: str) -> None:
        """Создает группу игроков."""
        from game.factories.player_factory import create_player
        
        for name, role in player_data.items():
            player = create_player(role=role, name=name, level=1, data_directory=data_dir)
            if player:
                self.player_group.append(player)

    def _create_initial_enemies(self) -> None:
        """Создает начальную группу врагов."""
        initial_enemy_data = [
            {'role': 'goblin', 'level': 1},
            {'role': 'orc', 'level': 2},
        ]
        self.create_enemies(initial_enemy_data)

    def get_player_group(self) -> List['Player']:
        """Получить текущую группу игроков."""
        return self.player_group.copy()

    def get_current_enemies(self) -> List['Monster']:
        """Получение списка текущих врагов."""
        return self.current_enemies.copy()

    def create_enemies(self, enemy_data_list: List[Dict[str, Any]]) -> bool:
        """Создание новой группы врагов."""
        self.current_enemies.clear()
        
        from game.factories.monster_factory import create_monster

        for enemy_data in enemy_data_list:
            role = enemy_data.get('role')
            if not role:
                # TODO: Заменить на логирование
                continue

            level = enemy_data.get('level', 1)
            name = enemy_data.get('name')
            
            monster = create_monster(name=name, role=role, level=level)
            if monster:
                self.current_enemies.append(monster)
        
        return True

def get_game_manager() -> GameManager:
    """Получить глобальный экземпляр GameManager."""
    return GameManager()

================================================================================
Файл: game/results.py
================================================================================

# game/results.py
"""Типизированные классы для результатов действий."""

from dataclasses import dataclass, field
from typing import Optional

@dataclass
class ActionResult:
    """Базовый класс для результатов игровых действий."""
    type: str
    message: Optional[str] = None

@dataclass
class ExperienceGainedResult(ActionResult):
    """Результат получения опыта."""
    type: str = field(default="exp_gained")
    character: str = ""
    exp_amount: int = 0
    total_exp: int = 0

@dataclass
class LevelUpResult(ActionResult):
    """Результат повышения уровня."""
    type: str = field(default="level_up")
    character: str = ""
    new_level: int = 0

@dataclass
class LevelUpHealResult(ActionResult):
    """Результат исцеления при повышении уровня."""
    type: str = field(default="level_up_heal")
    character: str = ""
    hp_restored: int = 0
    energy_restored: int = 0

@dataclass
class DamageTakenResult(ActionResult):
    """Результат получения урона."""
    type: str = field(default="damage_taken")
    target: str = ""
    damage: int = 0
    hp_left: int = 0

@dataclass
class HealedResult(ActionResult):
    """Результат исцеления."""
    type: str = field(default="healed")
    target: str = ""
    heal_amount: int = 0
    hp_now: int = 0

================================================================================
Файл: game/logging_config.py
================================================================================

# game/logging_config.py
"""Настройка логирования."""

import logging
import logging.handlers
import sys
from pathlib import Path
from typing import Optional, Dict, Any, List

def setup_logging(config: Optional[Dict[str, Any]] = None) -> logging.Logger:
    """
    Настройка логирования.
    
    Args:
        config: Параметры логирования
        
    Returns:
        Корневой логгер
    """
    # Параметры по умолчанию
    if config is None:
        config = {}
        
    level = config.get('level', logging.INFO)
    if isinstance(level, str):
        level = getattr(logging, level.upper(), logging.INFO)
        
    log_dir = Path(config.get('log_directory', 'logs'))
    log_file = config.get('log_file', 'game.log')
    file_max_bytes = config.get('file_max_bytes', 10485760)
    backup_count = config.get('backup_count', 5)
    log_format = config.get('format', '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    # Создаем директорию для логов
    log_dir.mkdir(exist_ok=True)
    full_log_path = log_dir / log_file
    
    # Настройка форматтеров
    formatter = logging.Formatter(log_format)
    
    # Настройка хендлеров
    handlers: List[logging.Handler] = []  # Явная типизация
    
    # Файловый хендлер с ротацией
    file_handler = logging.handlers.RotatingFileHandler(
        filename=str(full_log_path),
        maxBytes=file_max_bytes,
        backupCount=backup_count,
        encoding='utf-8'
    )
    file_handler.setFormatter(formatter)
    handlers.append(file_handler)
    
    # Консольный хендлер
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    handlers.append(console_handler)
    
    # Настройка корневого логгера
    root_logger = logging.getLogger()
    root_logger.setLevel(level)
    root_logger.handlers.clear()
    
    for handler in handlers:
        root_logger.addHandler(handler)
    
    logger = logging.getLogger(__name__)
    logger.info(f"Логирование настроено. Уровень: {logging.getLevelName(level)}")
    
    return logger

def get_logger(name: str) -> logging.Logger:
    """
    Получить логгер для модуля.
    
    Args:
        name: Имя модуля
        
    Returns:
        Логгер
    """
    return logging.getLogger(name)

def shutdown_logging() -> None:
    """Завершить логирование."""
    logging.shutdown()

================================================================================
Файл: game/ui/base_screen.py
================================================================================

# game/ui/base_screen.py
import curses
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, List
from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.command_system import CommandRegistry
from game.ui.command_system.screen_command_registry import get_screen_commands

if TYPE_CHECKING:
    from game.ui.screen_manager import ScreenManager
    from game.ui.command_system.command import Command # Импортируем Command для аннотаций

class BaseScreen(ABC):
    """Абстрактный базовый класс для всех экранов."""
    def __init__(self, manager: 'ScreenManager'):
        self.manager = manager
        self.elements: List[Renderable] = []
        self.renderer: Renderer = manager.renderer
        self.command_registry = CommandRegistry()
        self._setup_elements()
        self._setup_commands()
        self._setup_auto_commands()

    @abstractmethod
    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        pass

    @abstractmethod
    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        pass

    def _setup_auto_commands(self) -> None:
        """Автоматическая регистрация команд из реестра."""
        # Явно аннотируем тип возвращаемого значения get_screen_commands
        commands: List['Command'] = get_screen_commands(self.__class__)
        # Явно аннотируем тип переменной command в цикле
        command: 'Command'
        for command in commands:
            self.add_command(command) # <-- Эта строка вызывала ошибку mypy

    def add_command(self, command: 'Command') -> None: # <-- Убедитесь, что тип команды аннотирован здесь
        """
        Добавление команды на экран.
        Args:
            command: Команда для добавления
        """
        self.command_registry.register_command(command)

    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
        # Базовый класс НЕ отрисовывает команды.
        # Это responsibility конкретных экранов или миксинов.
        # Отрисовка команд убрана отсюда.

    def handle_input(self, key: int) -> None:
        """
        Обработка ввода пользователя.
        Args:
            key: Нажатая клавиша
        """
        # Пытаемся выполнить команду, если не удалось - вызываем обработчик по умолчанию
        if not self.command_registry.execute_command(key, self):
            self._handle_unregistered_key(key)

    def _handle_unregistered_key(self, key: int) -> None:
        """
        Обработка назарегистрированных клавиш.
        Может быть переопределен в подклассах.
        """
        pass

================================================================================
Файл: game/ui/main_screen.py
================================================================================

# game/ui/main_screen.py
"""
Главный экран игры.
Отображает главное меню с возможностью перехода в бой или инвентарь,
а также выход из игры.
"""
import curses
# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.mixins.ui_mixin import StandardLayoutMixin
# --------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class MainScreen(BaseScreen, StandardLayoutMixin):
    """Главный экран игры."""

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель, так как они теперь в миксине
        self.elements = [
            # Основные кнопки (визуальное отображение)
            # Смещаем Y на +2, так как шапка занимает первые 2 строки
            Text("[1] Начать бой", 5, 2, color=Color.GREEN, bold=True),
            Text("[2] Инвентарь", 5, 3, color=Color.YELLOW),
            Text("[3] Настройки", 5, 4, color=Color.MAGENTA, dim=True),
            # Separator(6, color=Color.BLUE), # Убираем старый разделитель
            # Кнопка выхода
            Text("[q] Выйти из игры", 20, 6, color=Color.RED, dim=True),
            # Информационное сообщение
            Text("Используйте клавиши 1, 2, 3 для навигации", 2, 8, dim=True),
            Text("Нажмите 'q' для выхода", 2, 9, dim=True)
            # Нижний разделитель и команды теперь тоже из миксина
        ]

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Все команды добавятся автоматически из реестра!
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        
        # Отрисовка стандартного макета (шапка + подвал)
        self.render_standard_layout("=== ГЛАВНОЕ МЕНЮ ===")
        
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
            
        self.renderer.refresh() # Не забываем refresh в конце конкретного render

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        pass


================================================================================
Файл: game/ui/__init__.py
================================================================================

# game/ui/__init__.py
"""
Пакет пользовательского интерфейса игры.

Содержит все компоненты для отображения и взаимодействия с пользователем.
"""

# Импортируем основные компоненты для удобства
from .screen_manager import ScreenManager
from .base_screen import BaseScreen

__all__ = [
    'ScreenManager',
    'BaseScreen'
]

================================================================================
Файл: game/ui/inventory_screen.py
================================================================================

# game/ui/inventory_screen.py
"""
Экран инвентаря.
Отображает содержимое инвентаря игрока.
"""
import curses
# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.mixins.ui_mixin import StandardLayoutMixin
# --------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class InventoryScreen(BaseScreen, StandardLayoutMixin):
    """Экран инвентаря."""

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель
        self.elements = [
            # Предметы инвентаря (смещаем Y на +2)
            Text("• Меч (+10 ATK)", 2, 2, color=Color.WHITE),           # Смещаем Y
            Text("• Зелье лечения", 2, 3, color=Color.GREEN, dim=True), # Смещаем Y
            Text("• Ключ от сундука", 2, 4, color=Color.CYAN, dim=True), # Смещаем Y
            Text("• Свиток телепортации", 2, 5, color=Color.MAGENTA, dim=True), # Смещаем Y
            # Separator(7, "-", 40, Color.WHITE, dim=True), # Убираем старый разделитель
            # Статистика (смещаем Y)
            Text("Всего предметов: 4", 2, 7, dim=True), # Смещаем Y
            Text("Занято: 4/20", 2, 8, dim=True),       # Смещаем Y
            # Separator(10, color=Color.YELLOW), # Убираем старый разделитель
        ]

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Команды из реестра добавятся автоматически!
        # Здесь можно добавить специфичные для этого экрана команды
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        
        # Отрисовка стандартного макета
        self.render_standard_layout("=== ИНВЕНТАРЬ ===")
        
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
            
        self.renderer.refresh() # Не забываем refresh

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        pass


================================================================================
Файл: game/ui/screen_manager.py
================================================================================

# game/ui/screen_manager.py
"""Управление экранами игры.
Реализует паттерн Состояние для переключения между экранами."""

import curses
from typing import Dict, Type, List, TYPE_CHECKING

from game.ui.base_screen import BaseScreen
from game.ui.battle_screen import BattleScreen
from game.ui.inventory_screen import InventoryScreen
from game.ui.main_screen import MainScreen
from game.ui.rendering.color_manager import ColorManager
from game.ui.rendering.renderer import Renderer

# Импортируем GameManager только для аннотаций типов, чтобы избежать циклических импортов
if TYPE_CHECKING:
    from game.game_manager import GameManager


class ScreenManager:
    """Управление экранами игры с использованием паттерна состояние."""

    def __init__(self, stdscr: curses.window, game_manager: 'GameManager') -> None:
        """
        Инициализация менеджера экранов.

        Args:
            stdscr: Окно curses.
            game_manager: Экземпляр GameManager, содержащий все игровые сущности.
        """
        self.stdscr = stdscr
        self.game_manager = game_manager # Сохраняем ссылку на GameManager

        self.color_manager = ColorManager()
        self.color_manager.initialize(stdscr)

        # Инициализируем renderer, он получит начальный размер
        self.renderer = Renderer(stdscr, self.color_manager)

        # Словарь доступных экранов (имя -> класс)
        self.screens: Dict[str, Type[BaseScreen]] = {
            "main": MainScreen,
            "battle": BattleScreen,
            "inventory": InventoryScreen,
        }

        # Стек экранов для управления историей переходов
        self.screen_stack: List[BaseScreen] = []

        # Начинаем с главного экрана, передаем ему ссылку на себя (manager)
        initial_screen = self.screens["main"](self)
        self.screen_stack.append(initial_screen)

    @property
    def current_screen(self) -> BaseScreen:
        """Текущий экран - верхний элемент стека."""
        return self.screen_stack[-1]

    def change_screen(self, screen_name: str) -> None:
        """Переход на новый экран (добавление в стек).

        Args:
            screen_name: Имя экрана для перехода.
        """
        if screen_name in self.screens:
            # Создаем новый экран, передавая ему ссылку на ScreenManager (self)
            new_screen = self.screens[screen_name](self)
            self.screen_stack.append(new_screen)
        else:
            raise ValueError(f"Неизвестный экран: {screen_name}")

    def go_back(self) -> None:
        """Возврат к предыдущему экрану (выход из стека)."""
        if len(self.screen_stack) > 1:
            self.screen_stack.pop()
        else:
            # Если это последний экран - выходим из приложения
            # TODO: Рассмотреть использование raise SystemExit() вместо exit()
            exit()

    def _update_renderer_for_all_screens(self) -> None:
        """Обновляет renderer для всех экранов в стеке."""
        # Создаём НОВЫЙ экземпляр renderer с текущими размерами stdscr
        # curses.update_lines_cols() не всегда нужно, зависит от терминала
        height, width = self.stdscr.getmaxyx()
        
        # ВАЖНО: Создаем новый экземпляр Renderer, а не пытаемся обновить старый
        self.renderer = Renderer(self.stdscr, self.color_manager)
        # Примечание: Вызов update_size(width, height) не нужен, так как
        # конструктор Renderer уже должен получить размеры из stdscr.

        # Передаём новый renderer всем экранам в стеке
        for screen in self.screen_stack:
            screen.renderer = self.renderer

    def run(self) -> None:
        """Основной цикл работы менеджера экранов."""
        while True:
            # Получаем текущий экран
            current = self.current_screen

            # Обновляем размеры renderer, если размер окна изменился
            # curses.update_lines_cols() не всегда нужно, зависит от терминала
            height, width = self.stdscr.getmaxyx()
            # Сравниваем с размерами, которые знает renderer
            # Предполагается, что у renderer есть атрибуты width и height,
            # установленные в его __init__
            if hasattr(self.renderer, 'height') and hasattr(self.renderer, 'width'):
                 # Если эти атрибуты есть и отличаются
                 if height != self.renderer.height or width != self.renderer.width:
                     self._update_renderer_for_all_screens()
            else:
                 # Если атрибутов нет, обновляем на всякий случай
                 # или предполагаем, что они устанавливаются в __init__
                 # Возможно, нужно добавить их установку в __init__ Renderer
                 self._update_renderer_for_all_screens()

            # Отрисовываем текущий экран
            current.render(self.stdscr)

            # Обновляем экран
            self.stdscr.refresh()

            # Получаем ввод пользователя
            try:
                key = self.stdscr.getch()
                # Обрабатываем ввод
                current.handle_input(key)
            except KeyboardInterrupt:
                # Обработка Ctrl+C
                exit()
            except Exception as e:
                # Логирование или обработка других исключений
                # Пока просто выходим
                print(f"Критическая ошибка: {e}")
                exit()


================================================================================
Файл: game/ui/battle_screen.py
================================================================================

# game/ui/battle_screen.py
"""Экран боя.
Отображает боевую сцену с возможностью взаимодействия."""
import curses
from typing import TYPE_CHECKING, Dict, Any, Optional, List, Tuple

# - ДОБАВЛЯЕМ ИМПОРТ МИКСИНА -
from game.mixins.ui_mixin import StandardLayoutMixin
# -
from game.ui.base_screen import BaseScreen
from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Text, Separator
# - ИМПОРТИРУЕМ НОВЫЕ КОМПОНЕНТЫ -
from game.ui.components.battle_components import (PlayerGroupPanel, EnemyGroupPanel, BattleLog)
# -
from game.ui.base_screen import BaseScreen
from game.ui.rendering.color_manager import Color
# Импортируем get_game_manager для использования внутри _setup_elements
from game.game_manager import get_game_manager

# - ДОБАВЛЯЕМ ИМПОРТ ДЛЯ TYPE_CHECKING -
if TYPE_CHECKING:
    from game.ui.screen_manager import ScreenManager
    from game.entities.player import Player
    from game.entities.monster import Monster
    from game.ui.rendering.renderer import Renderer
# ---


class BattleScreen(BaseScreen, StandardLayoutMixin):
    """Экран боя."""

    # --- Константы для макета ---
    HEADER_HEIGHT = 2
    #UNITS_Y_OFFSET = 1 # Отступ блока юнитов от заголовка
    UNITS_HEIGHT = 5 # Фиксированная высота блока юнитов
    #LOG_Y_OFFSET = 1 # Отступ лога от блока юнитов
    FOOTER_Y_OFFSET = 2 # Отступ подвала от низа лога
    HORIZONTAL_MARGIN = 1 # Отступы слева и справа
    GROUPS_GAP = 1 # Зазор между группами игроков и врагов
    MIN_LOG_HEIGHT = 3 # Минимальная высота лога
    MIN_LOG_WIDTH = 10 # Минимальная ширина лога
    # --- Конец констант ---

    def __init__(self, manager: 'ScreenManager'):
        # Инициализируем атрибуты для компонентов
        # Они будут инициализированы в _setup_elements
        self.player_group: Optional[PlayerGroupPanel] = None
        self.enemy_group: Optional[EnemyGroupPanel] = None
        self.battle_log: Optional[BattleLog] = None
        # Вызываем родительский конструктор
        # _setup_elements будет вызван внутри него
        super().__init__(manager)

    def _recalculate_layout(self, screen_width: int, screen_height: int) -> Dict[str, Dict[str, int]]:
        """
        Пересчитывает размеры и позиции всех основных компонентов экрана боя.

        Args:
            screen_width: Текущая ширина экрана.
            screen_height: Текущая высота экрана.

        Returns:
            Словарь с ключами 'player_group', 'enemy_group', 'battle_log',
            каждый из которых содержит словарь {'x', 'y', 'width', 'height'}.
        """
        # --- Размеры и позиции ---
        units_y = self.HEADER_HEIGHT #+ self.UNITS_Y_OFFSET

        # --- Расчет ширины для панелей юнитов ---
        # Доступная ширина для блоков юнитов (учитываем отступы и зазор)
        total_units_width = max(
            0,
            screen_width - 2 * self.HORIZONTAL_MARGIN - self.GROUPS_GAP
        )

        # Делим ширину пополам между игроками и монстрами
        half_width = total_units_width // 2
        player_group_width = half_width
        enemy_group_width = total_units_width - player_group_width

        # Координаты X
        player_group_x = self.HORIZONTAL_MARGIN
        enemy_group_x = player_group_x + player_group_width + self.GROUPS_GAP

        # --- Размеры и позиции лога боя ---
        log_x = 0  # self.HORIZONTAL_MARGIN
        log_y = units_y + self.UNITS_HEIGHT #+ self.LOG_Y_OFFSET
        log_width = max(self.MIN_LOG_WIDTH, screen_width * self.HORIZONTAL_MARGIN)

        # Высота лога - всё оставшееся пространство минус отступы и подвал
        available_height = screen_height - log_y - self.FOOTER_Y_OFFSET
        log_height = max(self.MIN_LOG_HEIGHT, available_height)

        return {
            'player_group': {
                'x': player_group_x,
                'y': units_y,
                'width': player_group_width,
                'height': self.UNITS_HEIGHT
            },
            'enemy_group': {
                'x': enemy_group_x,
                'y': units_y,
                'width': enemy_group_width,
                'height': self.UNITS_HEIGHT
            },
            'battle_log': {
                'x': log_x,
                'y': log_y,
                'width': log_width,
                'height': log_height
            }
        }

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        self.elements = [] # Очищаем список, так как компоненты будут отрисовываться напрямую

        # - ПОЛУЧАЕМ ДАННЫЕ ИЗ GameManager НЕПОСРЕДСТВЕННО В _setup_elements -
        # Это решает проблему порядка инициализации
        game_manager = get_game_manager()
        real_enemy_data = game_manager.get_current_enemies()
        real_player_data = game_manager.get_player_group()
        # -

        # Получаем начальные размеры экрана из рендерера
        if self.renderer:
            screen_width = self.renderer.width
            screen_height = self.renderer.height
        else:
            # fallback значения, если renderer еще не готов
            # Используем значения из конфигурации, если они доступны
            try:
                from game.config import get_config
                config = get_config()
                screen_width = config.ui.screen_width
                screen_height = config.ui.screen_height
            except Exception:
                screen_width = 80
                screen_height = 24

        # --- ИСПОЛЬЗУЕМ ОБЩУЮ ЛОГИКУ РАСЧЕТА ---
        layout = self._recalculate_layout(screen_width, screen_height)

        # Создаем панели с рассчитанными размерами
        self.player_group = PlayerGroupPanel(
            x=layout['player_group']['x'],
            y=layout['player_group']['y'],
            width=layout['player_group']['width'],
            height=layout['player_group']['height'],
            players=real_player_data  # Передаем данные игроков
        )

        self.enemy_group = EnemyGroupPanel(
            x=layout['enemy_group']['x'],
            y=layout['enemy_group']['y'],
            width=layout['enemy_group']['width'],
            height=layout['enemy_group']['height'],
            enemies=real_enemy_data  # Передаем данные врагов
        )

        # Инициализируем лог боя
        self.battle_log = BattleLog(
            x=layout['battle_log']['x'],
            y=layout['battle_log']['y'],
            width=layout['battle_log']['width'],
            height=layout['battle_log']['height']
        )
        # Добавляем тестовые сообщения в лог
        # TODO: Заменить на реальные сообщения из игровой логики
        self.battle_log.add_message("Битва начинается!")
        # ---

    def _update_component_sizes(self) -> None:
        """Обновление размеров компонентов."""
        if not self.renderer:
            return

        # Получаем текущие размеры экрана
        screen_width = self.renderer.width
        screen_height = self.renderer.height

        # --- ИСПОЛЬЗУЕМ ОБЩУЮ ЛОГИКУ РАСЧЕТА ---
        layout = self._recalculate_layout(screen_width, screen_height)
        # ---

        # Обновляем размеры и позиции панелей групп
        if self.player_group:
            self.player_group.x = layout['player_group']['x']
            self.player_group.y = layout['player_group']['y'] # Обновляем Y тоже
            self.player_group.width = layout['player_group']['width']
            self.player_group.height = layout['player_group']['height']
            # Обновляем размеры дочерних компонентов групп
            # _update_panels будет использовать новые self.x, self.width
            self.player_group._update_panels() 

        if self.enemy_group:
            self.enemy_group.x = layout['enemy_group']['x']
            self.enemy_group.y = layout['enemy_group']['y'] # Обновляем Y тоже
            self.enemy_group.width = layout['enemy_group']['width']
            self.enemy_group.height = layout['enemy_group']['height']
            # Обновляем размеры дочерних компонентов групп
            # _update_panels будет использовать новые self.x, self.width
            self.enemy_group._update_panels()

        # Обновляем размеры и позиции лога боя
        if self.battle_log:
            self.battle_log.x = layout['battle_log']['x']
            self.battle_log.y = layout['battle_log']['y']
            self.battle_log.width = layout['battle_log']['width']
            self.battle_log.height = layout['battle_log']['height']
            # BattleLog не имеет сложной внутренней структуры панелей,
            # поэтому явный вызов update_size не требуется.
            # Если бы требовался, нужно было бы проверить сигнатуру метода в BattleLog.

        # --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ ---

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Все команды добавятся автоматически из реестра!
        pass

    # - ОБНОВЛЯЕМ МЕТОД render -
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        # Обновляем размеры компонентов перед отрисовкой
        self._update_component_sizes()
        self.renderer.clear()

        # Отрисовка стандартного макета (шапка + подвал)
        self.render_standard_layout("=== БОЙ ===")

        # - ОТРИСОВКА НОВЫХ КОМПОНЕНТОВ -
        # Отрисовываем компоненты напрямую
        if self.player_group:
            self.player_group.render(self.renderer)
        if self.enemy_group:
            self.enemy_group.render(self.renderer)
        if self.battle_log:
            self.battle_log.render(self.renderer)
        # -
        self.renderer.refresh() # Не забываем refresh

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        # Обработка прокрутки лога
        if key == curses.KEY_UP:
            if self.battle_log:
                self.battle_log.scroll_up()
        elif key == curses.KEY_DOWN:
            if self.battle_log:
                self.battle_log.scroll_down()
        # Можно добавить отладочный вывод
        # print(f"BattleScreen: Нажата незарегистрированная клавиша: {key}")


================================================================================
Файл: game/entities/character.py
================================================================================

# game/entities/character.py
"""Базовый класс персонажа в игре."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable, TYPE_CHECKING
from game.protocols import (
    Stats, 
    Attributes,
    AbilityManagerProtocol, 
    StatusEffectManagerProtocol,
    Ability,
    StatusEffect
)
from game.config import get_config
from game.results import (
    ActionResult, 
    DamageTakenResult, 
    HealedResult
)

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType

# ==================== Вспомогательные классы ====================

@dataclass
class CharacterConfig:
    """Конфигурация для создания персонажа."""
    
    # Базовые параметры
    name: str
    role: str
   
    # Параметры для системы уровней/характеристик
    base_stats: Dict[str, int]
    growth_rates: Dict[str, float]
    level: int = 1
    is_player: bool = field(default=False)

    class_icon: str = "?"
    class_icon_color: str = ""
    description: str = ""
    starting_abilities: List[str] = field(default_factory=list)

    # Внедрение зависимостей через конструктор
    stats_factory: Optional[Callable[[str, int, Dict[str, int], Dict[str, float]], 'Stats']] = None
    attributes_factory: Optional[Callable[['Stats', Any], 'Attributes']] = None
    ability_manager_factory: Optional[Callable[['CharacterType'], 'AbilityManagerProtocol']] = None
    status_effect_manager_factory: Optional[Callable[['CharacterType'], 'StatusEffectManagerProtocol']] = None

@dataclass
class SimpleStats:
    strength: int = 0
    agility: int = 0
    intelligence: int = 0
    vitality: int = 0

@dataclass
class SimpleAttributes:
    max_hp: int = 0
    max_energy: int = 0
    attack_power: int = 0
    defense: int = 0

    def recalculate(self, stats: Stats, config: Any) -> None:
        """Пересчитывает атрибуты на основе новых характеристик."""
        self.max_hp = config.character.base_max_hp + (stats.vitality * config.character.hp_per_vitality)
        self.max_energy = config.character.base_max_energy + (stats.intelligence * config.character.energy_per_intelligence)
        self.attack_power = stats.strength * config.character.attack_per_strength
        self.defense = int(stats.agility * config.character.defense_per_agility)

# ==================== Основной класс персонажа ====================
class Character(ABC):
    """Абстрактный базовый класс, представляющий персонажа в игре."""

    def __init__(self, config: CharacterConfig):
        self.alive = True
        
        self.name = config.name
        self.role = config.role
        self.level = config.level
        self.is_player = config.is_player

        self.class_icon = config.class_icon
        self.class_icon_color = config.class_icon_color

        self.base_stats_dict = config.base_stats
        self.growth_rates_dict = config.growth_rates

        # Используем фабрики из конфига или по умолчанию
        self._stats_factory = config.stats_factory or (lambda role, level, base, growth: Character.default_stats_factory(role, level, base, growth))
        self._attributes_factory = config.attributes_factory or (lambda stats, config_obj: Character.default_attributes_factory(stats, config_obj))

        # Инициализация характеристик
        self.stats: Stats = self._stats_factory(self.role, self.level, self.base_stats_dict, self.growth_rates_dict)
        self.attributes: Attributes = self._attributes_factory(self.stats, get_config())

        # Инициализируем hp и энергию
        self.hp = self.attributes.max_hp
        self.energy = self.attributes.max_energy

        # Менеджеры (внедрение зависимостей)
        self._ability_manager: Optional[AbilityManagerProtocol] = None
        if config.ability_manager_factory:
            self._ability_manager = config.ability_manager_factory(self)

        self._status_manager: Optional[StatusEffectManagerProtocol] = None
        if config.status_effect_manager_factory:
            self._status_manager = config.status_effect_manager_factory(self)

    # ==================== Фабричные методы ====================
    @staticmethod
    def default_stats_factory(role: str, level: int, base_stats_dict: Dict[str, int], growth_rates_dict: Dict[str, float]) -> Stats:
        """Фабрика по умолчанию для создания Stats."""
        level_multiplier = level * 0.1
        return SimpleStats(
            strength=int(base_stats_dict.get('strength', 10) * (1 + level_multiplier * growth_rates_dict.get('strength', 1.0))),
            agility=int(base_stats_dict.get('agility', 10) * (1 + level_multiplier * growth_rates_dict.get('agility', 1.0))),
            intelligence=int(base_stats_dict.get('intelligence', 10) * (1 + level_multiplier * growth_rates_dict.get('intelligence', 1.0))),
            vitality=int(base_stats_dict.get('vitality', 10) * (1 + level_multiplier * growth_rates_dict.get('vitality', 1.0))),
        )

    @staticmethod
    def default_attributes_factory(stats: Stats, config: Any) -> Attributes:
        """Фабрика по умолчанию для создания Attributes."""
        attr = SimpleAttributes()
        attr.recalculate(stats, config)
        return attr

    # ==================== Вспомогательные методы ====================
    def _update_attributes(self) -> None:
        """Обновляет атрибуты на основе текущих характеристик."""
        config = get_config()
        self.attributes.recalculate(self.stats, config)
        # Обновляем hp и энергию до максимума при пересчете
        self.hp = self.attributes.max_hp
        self.energy = self.attributes.max_energy

    # ==================== Свойства ====================
    @property
    def ability_manager(self) -> Optional[AbilityManagerProtocol]:
        """Получение менеджера способностей."""
        return self._ability_manager

    @property
    def status_manager(self) -> Optional[StatusEffectManagerProtocol]:
        """Получение менеджера статус-эффектов."""
        return self._status_manager

    # ==================== Основные методы персонажа ====================
    def is_alive(self) -> bool:
        """Проверяет, жив ли персонаж."""
        return self.alive

    def get_level(self) -> int:
        """Возвращает уровень персонажа."""
        return self.level

    def level_up(self) -> List[ActionResult]:
        """
        Повышает уровень персонажа.
        Возвращает список сообщений/результатов.
        """
        self.level += 1
        
        # Пересчитываем характеристики
        self.stats = self._stats_factory(self.role, self.level, self.base_stats_dict, self.growth_rates_dict)
        
        # Пересчитываем атрибуты
        self._update_attributes()
        
        # Возвращаем результат как ActionResult
        return [ActionResult(
            type="level_up",
            message=f"{self.name} достиг уровня {self.level}!"
        )]

    def on_death(self) -> List[ActionResult]:
        """
        Вызывается при смерти персонажа. 
        Возвращает список сообщений/результатов.
        """
        results: List[ActionResult] = []

        # Очищаем все активные статус-эффекты
        if self._status_manager is not None:
            clear_results = self._status_manager.clear_all_effects()
            results.extend(clear_results)

        # Добавляем сообщение о смерти
        results.append(ActionResult(type="death", message=f"{self.name} погибает!"))
        return results

    # ==================== Боевые методы ====================
    def take_damage(self, damage: int) -> List[ActionResult]:
        """
        Наносит урон персонажу, учитывая защиту.
        Возвращает список сообщений/результатов.
        """
        results: List[ActionResult] = []
        
        # Учитываем защиту из attributes.defense
        actual_damage = max(0, damage - self.attributes.defense // 2)  # Может быть 0 урон
        actual_damage = max(1, actual_damage) if damage > 0 else 0  # Минимум 1 урон если был урон

        self.hp -= actual_damage
        results.append(DamageTakenResult(
            target=self.name,
            damage=actual_damage,
            hp_left=self.hp
        ))

        if self.hp <= 0:
            self.hp = 0
            if self.alive:  # Проверяем, чтобы не вызывать on_death дважды
                self.alive = False
                death_results = self.on_death()
                results.extend(death_results)

        return results

    def take_heal(self, heal_amount: int) -> List[ActionResult]:
        """
        Исцеляет персонажа и возвращает список сообщений/результатов.
        """
        results: List[ActionResult] = []
        old_hp = self.hp
        self.hp = min(self.attributes.max_hp, self.hp + heal_amount)
        actual_heal = self.hp - old_hp
        results.append(HealedResult(
            target=self.name,
            heal_amount=actual_heal,
            hp_now=self.hp
        ))
        return results

    # ==================== Энергия ====================
    def restore_energy(self, amount: Optional[int] = None, 
        percentage: Optional[float] = None) -> List[ActionResult]:
        """
        Восстанавливает энергию персонажа.
        :param amount: конкретное количество энергии для восстановления
        :param percentage: процент от максимальной энергии для восстановления
        Возвращает список сообщений/результатов.
        """
        results: List[ActionResult] = []
        old_energy = self.energy

        if percentage is not None:
            restore_amount = int(self.attributes.max_energy * (percentage / 100.0))
            self.energy = min(self.attributes.max_energy, self.energy + restore_amount)
        elif amount is not None:
            self.energy = min(self.attributes.max_energy, self.energy + amount)
        else:
            self.energy = self.attributes.max_energy  # Полное восстановление

        actual_restore = self.energy - old_energy
        if actual_restore > 0:
            results.append(ActionResult(
                type="energy_restored",
                message=f"{self.name} восстановил {actual_restore} энергии. Текущая энергия: {self.energy}"
            ))

        return results

    def spend_energy(self, amount: int) -> bool:
        """
        Тратит энергию персонажа.
        Возвращает True, если энергия была потрачена, иначе False.
        """
        if self.energy >= amount:
            self.energy -= amount
            return True
        return False

    # ==================== Способности ====================
    def add_ability(self, name: str, ability: Ability) -> List[ActionResult]:
        """Добавляет способность персонажу."""
        results: List[ActionResult] = []
        if self._ability_manager:
            self._ability_manager.add_ability(ability)
            results.append(ActionResult(
                type="ability_added",
                message=f"Способность {name} добавлена персонажу {self.name}"
            ))
        return results

    def get_available_abilities(self) -> List[Ability]:
        """Получает список доступных способностей."""
        if self._ability_manager:
            return self._ability_manager.get_available_abilities()
        return []

    def use_ability(self, name: str, targets: List['CharacterType'], **kwargs) -> List[ActionResult]:
        """
        Использует способность по имени.
        Возвращает список сообщений/результатов от способности и менеджера.
        """
        results: List[ActionResult] = []
        if self._ability_manager:
            ability_result = self._ability_manager.use_ability(name, targets, **kwargs)
            if ability_result:
                if isinstance(ability_result, list):
                    results.extend(ability_result)
                else:
                    results.append(ability_result)
        return results

    def update_ability_cooldowns(self) -> List[ActionResult]:
        """Обновляет кулдауны способностей в конце раунда."""
        results: List[ActionResult] = []
        if self._ability_manager:
            results.append(ActionResult(
                type="cooldowns_updated",
                message=f"Кулдауны обновлены для персонажа {self.name}"
            ))
            self._ability_manager.update_cooldowns()
        return results

    # ==================== Статус-эффекты ====================
    def add_status_effect(self, effect: StatusEffect) -> List[ActionResult]:
        """Добавляет статус-эффект персонажу. Возвращает результат от менеджера."""
        if self._status_manager:
            return self._status_manager.apply_effect(effect)
        return []                  

    def remove_status_effect(self, effect_name: str) -> List[ActionResult]:
        """Удаляет статус-эффект по имени. Возвращает результат."""
        results: List[ActionResult] = []
        if self._status_manager:
            success = self._status_manager.remove_effect(effect_name)
            if success:
                results.append(ActionResult(type="effect_removed", message=f"Эффект {effect_name} удален у {self.name}"))
            else:
                results.append(ActionResult(type="error", message=f"Эффект {effect_name} не найден у {self.name}"))
        return results

    def update_status_effects(self) -> List[ActionResult]:
        """Обновляет все активные статус-эффекты. Возвращает список результатов."""
        if self._status_manager:
            return self._status_manager.update_effects()
        return []

    def has_status_effect(self, effect_name: str) -> bool:
        """Проверяет, есть ли у персонажа определенный статус-эффект."""
        if self._status_manager:
            return self._status_manager.get_effect(effect_name) is not None
        return False

    def get_active_status_effects(self) -> List[StatusEffect]:
        """Возвращает список всех активных статус-эффектов."""
        if self._status_manager:
            return self._status_manager.get_all_effects()
        return []

================================================================================
Файл: game/entities/monster.py
================================================================================

# game/entities/monster.py
"""Класс монстра (персонажа, НЕ управляемого игроком)."""

from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING
from game.entities.character import Character, CharacterConfig

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType

# MonsterConfig можно не создавать - используем CharacterConfig
# или если нужна специфика:
@dataclass
class MonsterConfig(CharacterConfig):
    """Конфигурация для создания монстра."""
    pass  # Пока нет специфичных параметров

def create_monster_from_data(
    role: str,
    name: str,
    level: int = 1,
    data_directory: Optional[str] = None
) -> Optional['Monster']:
    """
    Создает объект Monster на основе данных из JSON файла.

    Args:
        role: Внутренний идентификатор класса.
        name: Имя монстра.
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Объект Monster или None, если данные не могут быть загружены.
    """
    if data_directory is None:
        from game.config import get_config
        data_directory = get_config().system.monster_classes_directory
        
    try:
        from game.data.character_loader import load_monster_class_data
    except ImportError as e:
        print(f"Ошибка импорта character_loader: {e}")
        return None

    config_data = load_monster_class_data(role, data_directory)
    if not config_data:
        print(f"Не удалось загрузить данные для класса монстра '{role}'")
        return None

    try:
        config = MonsterConfig(**config_data)
        config.level = level
        config.name = name if name else config.name
        config.is_player = False  # Явно указываем
        return Monster(config)

    except Exception as e:
        print(f"Ошибка создания монстра {name} класса {role}: {e}")
        import traceback
        traceback.print_exc()
        return None

class Monster(Character):
    """Класс для всех монстров (персонажей, НЕ управляемых игроком)."""

    def __init__(self, config: MonsterConfig):
        """
        Инициализирует монстра.

        Args:
            config: Конфигурация монстра.
        """
        super().__init__(config=config)
        
        # Здесь можно добавить специфичную для монстров логику
        # Например:
        # self.ai_behavior = config.ai_behavior if hasattr(config, 'ai_behavior') else 'aggressive'

================================================================================
Файл: game/entities/player.py
================================================================================

# game/entities/player.py
"""Класс игрока (персонажа, управляемого игроком)."""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, TYPE_CHECKING
from game.entities.character import Character, CharacterConfig
from game.protocols import (
    ExperienceCalculatorProtocol,
    LevelUpHandlerProtocol
)
from game.systems.implementations import (
    SimpleExperienceCalculator, 
    SimpleLevelUpHandler
)
from game.systems.experience import ExperienceSystem, LevelingSystem
from game.results import ActionResult

if TYPE_CHECKING:
    from game.entities.character import Character as CharacterType


@dataclass
class PlayerConfig(CharacterConfig):
    """Конфигурация для создания игрока."""
    is_player: bool = field(default=True)
    exp_calculator: Optional[ExperienceCalculatorProtocol] = None
    level_up_handler: Optional[LevelUpHandlerProtocol] = None


def create_player_from_data(
    role: str,
    name: str,
    level: int = 1,
    data_directory: str = "game/data/characters/player_classes"
) -> Optional['Player']:
    """
    Создает объект Player на основе данных из JSON файла.

    Args:
        role: Внутренний идентификатор класса (должен совпадать с именем .json файла).
        name: Имя персонажа.
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Объект Player или None, если данные не могут быть загружены.
    """
    try:
        from game.data.character_loader import load_player_class_data
    except ImportError as e:
        print(f"Ошибка импорта character_loader внутри create_player_from_data: {e}")
        return None

    config_data = load_player_class_data(role, data_directory)
    if not config_data:
        print(f"Не удалось загрузить данные для класса '{role}'")
        return None

    try:
        config = PlayerConfig(**config_data)
        config.name = name if name else config.name
        return Player(config)

    except Exception as e:
        print(f"Ошибка создания персонажа {name} класса {role}: {e}")
        import traceback
        traceback.print_exc()
        return None


class Player(Character):
    """Класс для всех игроков (персонажей, управляемых игроком)."""

    def __init__(self, config: PlayerConfig):
        """
        Инициализирует игрока.

        Args:
            config: Конфигурация игрока.
        """
        super().__init__(config=config)

        # Инициализируем системы
        exp_calculator = config.exp_calculator or SimpleExperienceCalculator()
        level_up_handler = config.level_up_handler or SimpleLevelUpHandler()
        
        self.experience_system = ExperienceSystem(exp_calculator)
        self.leveling_system = LevelingSystem(level_up_handler)
        
        self.exp = 0
        self.exp_to_next_level = self.experience_system.calculate_exp_for_next_level(self.level)

    def level_up(self) -> List[ActionResult]:
        """
        Повышает уровень персонажа (игрока).

        Returns:
            Список сообщений/результатов повышения уровня.
        """
        # Вызываем родительский метод level_up
        results = super().level_up()
        
        # Пересчитываем опыт для следующего уровня
        self.exp_to_next_level = self.experience_system.calculate_exp_for_next_level(self.level)
        
        return results

    @property
    def experience_to_next_level(self) -> int:
        """Получение опыта, необходимого для следующего уровня."""
        return self.exp_to_next_level

    def gain_experience(self, exp_amount: int) -> List[ActionResult]:
        """
        Добавляет опыт игроку и проверяет на повышение уровня.

        Args:
            exp_amount: Количество получаемого опыта.

        Returns:
            Список результатов добавления опыта и возможного повышения уровня.
        """
        results: List[ActionResult] = []
        
        # Добавляем опыт
        self.exp += exp_amount
        exp_results = self.experience_system.add_experience(self, exp_amount)
        results.extend(exp_results)

        # Проверяем, достаточно ли опыта для повышения уровня
        while self.exp >= self.exp_to_next_level:
            # Сбрасываем опыт, использованный для повышения уровня
            self.exp -= self.exp_to_next_level
            
            # Повышаем уровень через родительский метод
            level_up_results = super().level_up()
            results.extend(level_up_results)
            
            # Дополнительная обработка повышения уровня
            level_results = self.leveling_system.try_level_up(self)
            results.extend(level_results)
            
            # Пересчитываем опыт для следующего уровня
            self.exp_to_next_level = self.experience_system.calculate_exp_for_next_level(self.level)

        return results

================================================================================
Файл: game/data/character_loader.py
================================================================================

# game/data/character_loader.py
"""Загрузчик данных персонажей из JSON файлов."""

import json
import os
from typing import Dict, Any, Optional, TYPE_CHECKING

# Используем TYPE_CHECKING для аннотаций без циклического импорта на уровне модуля
if TYPE_CHECKING:
    from game.config import GameConfig # Для аннотаций


# --- Вспомогательные (приватные) функции ---
def _get_default_data_directory(is_player: bool) -> str:
    """
    Получает путь к директории данных по умолчанию из конфигурации.

    Args:
        is_player: Если True, возвращает путь для игроков.
                   Если False, возвращает путь для монстров.

    Returns:
        Путь к директории данных.
    """
    from game.config import get_config # Локальный импорт
    config: 'GameConfig' = get_config()

    if is_player:
        return config.system.player_classes_directory
    else:
        return config.system.monster_classes_directory


def _load_character_data_from_file(
    role: str, 
    data_directory: str
    ) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса персонажа из JSON файла.

    Args:
        role: Внутренний идентификатор класса (например, "berserker", "goblin").
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Словарь с данными класса или None, если файл не найден или произошла ошибка.
    """
    filename = f"{role}.json"
    filepath = os.path.join(data_directory, filename)

    # Проверяем, существует ли файл
    if not os.path.exists(filepath):
        # Пробуем относительный путь от корня проекта, если предыдущий не сработал
        # Это может помочь, если скрипт запускается не из корня проекта
        try:
            # Получаем путь к корню проекта (предполагаем, что loader.py находится в game/data/)
            # os.path.abspath(__file__) дает полный путь к этому файлу
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
            filepath = os.path.join(project_root, data_directory, filename)
            if not os.path.exists(filepath):
                print(f"Файл данных для класса '{role}' не найден: {filepath}")
                return None
        except Exception as e:
            print(f"Ошибка при определении пути к файлу {filename}: {e}")
            return None

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return data
    except json.JSONDecodeError as e:
        print(f"Ошибка декодирования JSON в файле {filepath}: {e}")
        return None
    except Exception as e:
        print(f"Неизвестная ошибка при загрузке {filepath}: {e}")
        return None


# --- Публичные функции для игроков ---
def load_player_class_data(
    role: str, 
    data_directory: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса игрока из JSON файла.

    Args:
        role: Внутренний идентификатор класса (например, "berserker").
        data_directory: Путь к директории с JSON файлами.
                        Если None, используется путь из конфигурации.

    Returns:
        Словарь с данными класса или None, если файл не найден.
    """
    if data_directory is None:
        data_directory = _get_default_data_directory(is_player=True)
        
    return _load_character_data_from_file(role, data_directory)


# --- Публичные функции для монстров ---
def load_monster_class_data(
    role: str, 
    data_directory: Optional[str] = None
    ) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса монстра из JSON файла.

    Args:
        role: Внутренний идентификатор класса монстра (например, "goblin").
        data_directory: Путь к директории с JSON файлами.
                        Если None, используется путь из конфигурации.

    Returns:
        Словарь с данными класса или None, если файл не найден.
    """
    if data_directory is None:
        data_directory = _get_default_data_directory(is_player=False)
        
    return _load_character_data_from_file(role, data_directory)


================================================================================
Файл: game/factories/__init__.py
================================================================================



================================================================================
Файл: game/factories/monster_factory.py
================================================================================

# game/factories/monster_factory.py
"""Фабрика для создания монстров."""

from typing import TYPE_CHECKING, Optional
from game.naming.template_namer import generate_monster_name

if TYPE_CHECKING:
    from game.entities.monster import Monster

def create_monster(
    role: str,
    name: Optional[str] = None,
    level: int = 1,
    data_directory: Optional[str] = None
) -> Optional['Monster']:
    """
    Создает монстра по его роли (типу).

    Args:
        role: Внутренний идентификатор класса монстра.
        name: Имя монстра. Если None, будет сгенерировано автоматически.
        level: Уровень монстра.
        data_directory: Путь к директории с JSON файлами классов монстров.

    Returns:
        Объект Monster или None, если данные не могут быть загружены.
    """
    # Получаем директорию из конфигурации если не задана
    if data_directory is None:
        from game.config import get_config
        data_directory = get_config().system.monster_classes_directory

    # Генерируем имя если не задано
    if not name or not name.strip():
        name = generate_monster_name(role)

    # Ленивый импорт для избежания циклических импортов
    from game.entities.monster import create_monster_from_data
    return create_monster_from_data(
        role=role, 
        name=name, 
        level=level, 
        data_directory=data_directory
    )

================================================================================
Файл: game/factories/player_factory.py
================================================================================

# game/factories/player_factory.py
"""Фабрика для создания персонажей-игроков."""

from typing import Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from game.entities.player import Player

def create_player(
    role: str,
    name: str, 
    level: int = 1,
    data_directory: Optional[str] = None
) -> Optional['Player']:
    """
    Создает объект Player на основе данных из JSON файла.

    Args:
        role: Внутренний идентификатор класса.
        name: Имя персонажа.
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.
                        Если None, используется путь из конфигурации.

    Returns:
        Объект Player или None, если данные не могут быть загружены.
    """
    # Получаем директорию из конфигурации если не задана
    if data_directory is None:
        from game.config import get_config
        data_directory = get_config().system.player_classes_directory

    # Ленивый импорт для избежания циклических импортов
    from game.entities.player import create_player_from_data
    return create_player_from_data(
        role=role, 
        name=name, 
        level=level, 
        data_directory=data_directory
    )

================================================================================
Файл: game/naming/template_namer.py
================================================================================

# game/naming/template_namer.py
"""Генератор имен монстров на основе шаблонов."""

import random
import json
import os
from typing import List, Dict, Optional
from game.protocols import MonsterNamerProtocol

class TemplateMonsterNamer(MonsterNamerProtocol):
    """Простой генератор имен монстров, использующий шаблоны и списки слов."""

    def __init__(self, data_directory: Optional[str] = None):
        """
        Инициализирует генератор.

        Args:
            data_directory: Путь к директории с JSON-файлами слов.
        """
        if data_directory is None:
            from game.config import get_config
            data_directory = get_config().system.character_names_directory
            
        self.data_directory = data_directory
        self.word_data: Dict[str, List[str]] = {}
        self._load_word_data()

    def _load_word_data(self) -> None:
        """Загружает данные слов из JSON-файлов."""
        self.word_data = {}
        if not os.path.exists(self.data_directory):
            print(f"Предупреждение: Директория данных имен '{self.data_directory}' не найдена.")
            return

        try:
            # Загружаем общие списки слов
            common_files = {
                "adjectives": "adjectives.json",
                "nouns": "nouns.json",
                "prefixes": "prefixes.json",
                "suffixes": "suffixes.json",
            }
            
            for key, filename in common_files.items():
                filepath = os.path.join(self.data_directory, filename)
                if os.path.exists(filepath):
                    with open(filepath, 'r', encoding='utf-8') as f:
                        self.word_data[key] = json.load(f)
                else:
                    self.word_data[key] = []
                    
        except (json.JSONDecodeError, Exception) as e:
            print(f"Ошибка при загрузке данных имен: {e}")
            self.word_data = {k: [] for k in common_files.keys()}

    def _get_words(self, category: str) -> List[str]:
        """Получает список слов по категории."""
        return self.word_data.get(category, [])

    def generate_name(self, monster_role: str) -> str:
        """
        Генерирует имя для монстра на основе его роли.
        """
        if not monster_role or not monster_role.strip():
            monster_role = "monster"

        templates = [
            "{adjective} {noun}",
            "{prefix}{noun}",
            "{noun} {suffix}",
            "{adjective} {prefix}{noun}",
            "{prefix}{noun} {suffix}",
            "{noun}",
        ]

        template = random.choice(templates)

        # Получаем слова
        adjectives = self._get_words("adjectives")
        nouns = self._get_words("nouns") 
        prefixes = self._get_words("prefixes")
        suffixes = self._get_words("suffixes")

        # Словарь для подстановки в шаблон
        replacements = {
            "adjective": random.choice(adjectives) if adjectives else "",
            "noun": random.choice(nouns) if nouns else "Монстр",
            "prefix": random.choice(prefixes) if prefixes else "",
            "suffix": random.choice(suffixes) if suffixes else "",
        }

        try:
            name = template.format(**replacements).strip()
            name = " ".join(name.split())
            return name if name else f"{monster_role.capitalize()} {random.randint(1, 1000)}"
        except (KeyError, Exception):
            return f"{monster_role.capitalize()} {random.randint(1, 1000)}"

# --- Фабрика для удобства ---
def create_default_namer() -> TemplateMonsterNamer:
    """Создать экземпляр генератора имен с настройками по умолчанию."""
    return TemplateMonsterNamer()

def generate_monster_name(monster_role: str) -> str:
    """
    Удобная функция для генерации имени монстра.
    """
    namer = create_default_namer()
    return namer.generate_name(monster_role)

================================================================================
Файл: game/systems/experience.py
================================================================================

# game/systems/experience.py
"""Системы управления опытом и уровнями."""

from typing import List, TYPE_CHECKING
from game.protocols import (
    ExperienceCalculatorProtocol, 
    LevelUpHandlerProtocol,
    ExperienceSystemProtocol,
    LevelingSystemProtocol
)
from game.results import ActionResult, ExperienceGainedResult, LevelUpHealResult

if TYPE_CHECKING:
    from game.entities.character import Character

class ExperienceSystem(ExperienceSystemProtocol):
    """Система управления опытом персонажа."""
    
    def __init__(self, calculator: ExperienceCalculatorProtocol):
        self.calculator = calculator
    
    def calculate_exp_for_next_level(self, current_level: int) -> int:
        """Рассчитывает опыт для следующего уровня."""
        return self.calculator.calculate_exp_for_next_level(current_level)
    
    def add_experience(self, character: 'Character', amount: int) -> List[ExperienceGainedResult]:
        """Добавляет опыт персонажу."""
        results: List[ExperienceGainedResult] = []
        
        # Получаем текущий опыт персонажа
        current_exp = getattr(character, 'exp', 0)
        new_total_exp = current_exp + amount
        
        results.append(ExperienceGainedResult(
            character=character.name,
            exp_amount=amount,
            total_exp=new_total_exp
        ))
        
        return results

class LevelingSystem(LevelingSystemProtocol):
    """Система управления повышением уровней."""
    
    def __init__(self, handler: LevelUpHandlerProtocol):
        self.handler = handler
    
    def try_level_up(self, character: 'Character') -> List[ActionResult]:
        """Проверяет и выполняет повышение уровня."""
        results: List[ActionResult] = []
        
        # Вызываем родительский level_up если есть
        if hasattr(character, 'level_up'):
            character.level_up()
        
        # Дополнительная обработка
        handler_results = self.handler.handle_level_up(character)
        # Фильтруем только LevelUpHealResult (или преобразуем)
        for result in handler_results:
            if isinstance(result, LevelUpHealResult):
                results.append(result)
        
        return results

================================================================================
Файл: game/systems/implementations.py
================================================================================

# game/systems/implementations.py
"""Реализации различных протоколов."""

from typing import TYPE_CHECKING, List
from game.protocols import (
    ExperienceCalculatorProtocol, 
    LevelUpHandlerProtocol
)

from game.results import ActionResult, LevelUpHealResult
from game.config import get_config

if TYPE_CHECKING:
    from game.entities.character import Character

class SimpleExperienceCalculator(ExperienceCalculatorProtocol):
    """Простой калькулятор опыта для следующего уровня."""
    
    def calculate_exp_for_next_level(self, current_level: int) -> int:
        """Рассчитывает опыт, необходимый для достижения следующего уровня."""
        config = get_config()
        return int(config.experience.formula_base * (current_level ** config.experience.formula_multiplier))

class SimpleLevelUpHandler(LevelUpHandlerProtocol):
    """Простой обработчик повышения уровня."""
    
    def handle_level_up(self, character: 'Character') -> List[ActionResult]:
        """Обработать повышение уровня и вернуть список результатов."""
        results: List[ActionResult] = []
        old_hp = character.hp
        character.hp = character.attributes.max_hp
        hp_restored = character.hp - old_hp
        
        old_energy = character.energy
        character.energy = character.attributes.max_energy
        energy_restored = character.energy - old_energy
        
        results.append(LevelUpHealResult(
            character=character.name,
            hp_restored=hp_restored,
            energy_restored=energy_restored
        ))
        
        return results

================================================================================
Файл: game/mixins/logging_mixin.py
================================================================================

# game/mixins/logging_mixin.py
"""Миксин для добавления логирования в классы."""

import logging
from typing import Any, Optional

class LoggingMixin:
    """Добавляет логирование в класс."""
    
    _logger: Optional[logging.Logger] = None
    
    @property
    def logger(self) -> logging.Logger:
        """Получить логгер для текущего класса."""
        if self._logger is None:
            try:
                logger_name = f"{self.__class__.__module__}.{self.__class__.__name__}"
                self._logger = logging.getLogger(logger_name)
            except Exception:
                self._logger = logging.getLogger("fallback")
        return self._logger
    
    def log_debug(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Записать DEBUG сообщение."""
        try:
            self.logger.debug(message, *args, **kwargs)
        except Exception:
            pass
    
    def log_info(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Записать INFO сообщение."""
        try:
            self.logger.info(message, *args, **kwargs)
        except Exception:
            pass
    
    def log_warning(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Записать WARNING сообщение."""
        try:
            self.logger.warning(message, *args, **kwargs)
        except Exception:
            pass
    
    def log_error(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Записать ERROR сообщение."""
        try:
            self.logger.error(message, *args, **kwargs)
        except Exception:
            pass
    
    def log_critical(self, message: str, *args: Any, **kwargs: Any) -> None:
        """Записать CRITICAL сообщение."""
        try:
            self.logger.critical(message, *args, **kwargs)
        except Exception:
            pass

================================================================================
Файл: game/mixins/__init__.py
================================================================================

# game/mixins/__init__.py
"""Централизованные миксины для всего проекта."""

from .logging_mixin import LoggingMixin
from .ui_mixin import HeaderMixin, FooterMixin, StandardLayoutMixin, LayoutProtocol

__all__ = [
    'LoggingMixin',
    'HeaderMixin', 
    'FooterMixin', 
    'StandardLayoutMixin',
    'LayoutProtocol'
]

================================================================================
Файл: game/mixins/ui_mixin.py
================================================================================

# game/mixins/ui_mixin.py
"""Миксины для UI функциональности."""

from typing import TYPE_CHECKING, Protocol

from game.ui.command_system import CommandRenderer
from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Separator, Text

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen
    from game.ui.command_system.command import CommandRegistry
    from game.ui.rendering.renderer import Renderer


class LayoutProtocol(Protocol):
    """Протокол для классов с методами отрисовки шапки и подвала."""
    renderer: 'Renderer'
    command_registry: 'CommandRegistry'

    def render_header(self, title: str) -> None: ...
    def render_footer(self) -> None: ...


class HeaderMixin:
    """Миксин для отрисовки стандартной шапки экрана."""

    def render_header(self: LayoutProtocol, title: str) -> None:
        """
        Отрисовка стандартной шапки экрана.
        """
        renderer = getattr(self, 'renderer')
        title_x = max(0, (renderer.width - len(title)) // 2)
        header_text = Text(title, title_x, 0, bold=True, color=Color.CYAN)
        header_text.render(renderer)

        header_separator = Separator(1, color=Color.DEFAULT)
        header_separator.render(renderer)


class FooterMixin:
    """Миксин для отрисовки стандартного подвала экрана."""

    def render_footer(self: LayoutProtocol) -> None:
        """
        Отрисовка стандартного подвала экрана.
        """
        command_registry = getattr(self, 'command_registry')
        renderer = getattr(self, 'renderer')
        commands = command_registry.get_all_commands()

        footer_separator_y = max(0, renderer.height - 2)
        commands_y = max(0, renderer.height - 1)

        footer_separator = Separator(footer_separator_y, color=Color.GRAY)
        footer_separator.render(renderer)

        footer_command_renderer = CommandRenderer(y=commands_y)
        command_elements = footer_command_renderer.render_commands(commands)
        for element in command_elements:
            element.render(renderer)


class StandardLayoutMixin(HeaderMixin, FooterMixin):
    """Миксин, объединяющий стандартную шапку и подвал."""

    def render_standard_layout(self: LayoutProtocol, title: str) -> None:
        """
        Отрисовка стандартного макета экрана.
        """
        self.render_header(title)
        self.render_footer()

================================================================================
Файл: game/data/names/adjectives.json
================================================================================

[
    "Злобный",
    "Коварный",
    "Гнилой",
    "Кровавый",
    "Яростный",
    "Хитрый",
    "Мерзкий",
    "Скользкий",
    "Лютый",
    "Мрачный"
  ]

================================================================================
Файл: game/data/names/nouns.json
================================================================================

[
    "Гоблин",
    "Огр",
    "Скелет",
    "Зомби",
    "Дракон",
    "Демон",
    "Призрак",
    "Вампир",
    "Оборотень",
    "Бес"
  ]

================================================================================
Файл: game/data/names/prefixes.json
================================================================================

[
    "Супер",
    "Мега",
    "Ультра",
    "Архи",
    "Великий",
    "Король",
    "Лорд",
    "Мастер",
    "Профессор",
    "Доктор"
  ]

================================================================================
Файл: game/data/names/suffixes.json
================================================================================

[
    "Младший",
    "Старший",
    "Великий",
    "Ужасный",
    "Несокрушимый",
    "Из Тьмы",
    "Из Бездны",
    "Пожиратель",
    "Разрушитель",
    "Завоеватель"
  ]

================================================================================
Файл: game/data/characters/player_classes/archer.json
================================================================================

{
    "name": "Лучник",
    "role": "archer",
    "class_icon": "A",
    "class_icon_color": 6,
    "base_stats": {
        "strength": 8,
        "agility": 14,
        "intelligence": 10,
        "vitality": 9
    },
    "growth_rates": {
        "strength": 0.06,
        "agility": 0.07,
        "intelligence": 0.05,
        "vitality": 0.08
    },
    "description": "Класс с высоким уроном, средней ловкостью и низкой защитой.",
    "starting_abilities": [
        "Volley"
    ]
}

================================================================================
Файл: game/data/characters/player_classes/berserker.json
================================================================================

{
  "name": "Берсерк",
  "role": "berserker",
  "class_icon": "B",
  "class_icon_color": "RED",
  "base_stats": {
    "strength": 16,
    "agility": 10,
    "intelligence": 8,
    "vitality": 12
  },
  "growth_rates": {
    "strength": 0.10,
    "agility": 0.05,
    "intelligence": 0.03,
    "vitality": 0.09
  },
  "description": "Сбалансированный класс с высокой силой и защитой.",
  "starting_abilities": []
}

================================================================================
Файл: game/data/characters/player_classes/healer.json
================================================================================

{
    "name": "Лекарь",
    "role": "healer",
    "class_icon": "H",
    "class_icon_color": "CYAN",
    "base_stats": {
        "strength": 5,
        "agility": 12,
        "intelligence": 16,
        "vitality": 10
    },
    "growth_rates": {
        "strength": 0.04,
        "agility": 0.08,
        "intelligence": 0.09,
        "vitality": 0.08
    },
    "description": "Класс с низким уроном, средними защитой и здоровьем, способностью лечить.",
    "starting_abilities": [
        "Heal",
        "MassHeal"
    ]
}

================================================================================
Файл: game/data/characters/player_classes/mage.json
================================================================================

{
  "name": "Маг",
  "role": "mage",
  "class_icon": "M",
  "class_icon_color": "MAGENTA",
  "base_stats": {
    "strength": 4,
    "agility": 12,
    "intelligence": 20,
    "vitality": 6
  },
  "growth_rates": {
    "strength": 0.03,
    "agility": 0.06,
    "intelligence": 0.12,
    "vitality": 0.06
  },
  "description": "Мастер магии, наносящий огромный урон, но слабо защищенный.",
  "starting_abilities": []
}

================================================================================
Файл: game/data/characters/player_classes/rogue.json
================================================================================

{
    "name": "Разбойник",
    "role": "rogue",
    "class_icon": "R",
    "class_icon_color": "GRAY",
    "base_stats": {
        "strength": 6,
        "agility": 18,
        "intelligence": 10,
        "vitality": 7
    },
    "growth_rates": {
        "strength": 0.05,
        "agility": 0.08,
        "intelligence": 0.06,
        "vitality": 0.07
    },
    "description": "Класс с высокой ловкостью, умеренным уроном и низкой защитой.",
    "starting_abilities": [
        "Backstab",
        "SlidingStrike",
        "CriticalStrike",
        "PoisonStrike"
    ]
}

================================================================================
Файл: game/data/characters/monster_classes/goblin.json
================================================================================

{
    "name": "Гоблин",
    "role": "goblin",
    "class_icon": "G",
    "class_icon_color": "GREEN",
    "base_stats": {
        "strength": 6,
        "agility": 8,
        "intelligence": 4,
        "vitality": 8
    },
    "growth_rates": {
        "strength": 0.04,
        "agility": 0.04,
        "intelligence": 0.03,
        "vitality": 0.05
    },
    "description": "Слабый враг, который почему-то считает себя опасным. Настолько маленький, что даже его собственная тень прячется от него. Удивительно, как он вообще держит оружие, не говоря уже о том, чтобы им попасть куда-то.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/orc.json
================================================================================

{
    "name": "Орк",
    "role": "orc",
    "class_icon": "O",
    "class_icon_color": "RED",
    "base_stats": {
        "strength": 16,
        "agility": 6,
        "intelligence": 5,
        "vitality": 14
    },
    "growth_rates": {
        "strength": 0.10,
        "agility": 0.03,
        "intelligence": 0.02,
        "vitality": 0.09
    },
    "description": "Сильный враг с высоким уроном и IQ размером с арахис. Мозг настолько маленький, что даже муха не может в него въехать. Зато бьет так, что даже стены начинают искать себе другую работу.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/skeleton.json
================================================================================

{
    "name": "Скелет",
    "role": "skeleton",
    "class_icon": "S",
    "class_icon_color": "WHITE",
    "base_stats": {
        "strength": 12,
        "agility": 10,
        "intelligence": 6,
        "vitality": 10
    },
    "growth_rates": {
        "strength": 0.08,
        "agility": 0.05,
        "intelligence": 0.04,
        "vitality": 0.07
    },
    "description": "Средний враг, который умудрился умереть даже будучи мертвым. Постоянно теряет части тела, но это его не останавливает - видимо, он и при жизни был рассеян. Хотя, кто знает, может это и к лучшему.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/troll.json
================================================================================

{
    "name": "Тролль",
    "role": "troll",
    "class_icon": "T",
    "class_icon_color": "YELLOW",
    "base_stats": {
        "strength": 17,
        "agility": 4,
        "intelligence": 3,
        "vitality": 18
    },
    "growth_rates": {
        "strength": 0.09,
        "agility": 0.02,
        "intelligence": 0.01,
        "vitality": 0.11
    },
    "description": "Очень крепкий враг, который настолько туп, что даже эхо от его голоса возвращается с извинениями. Мозг размером с вишню, но зато может выдержать прямое попадание метеорита. Смертельно опасен для всего живого... и мертвого тоже.",
    "starting_abilities": []
}

================================================================================
Файл: game/data/characters/monster_classes/wizard.json
================================================================================

{
    "name": "Волшебник",
    "role": "wizard",
    "class_icon": "W",
    "class_icon_color": "MAGENTA",
    "base_stats": {
        "strength": 8,
        "agility": 12,
        "intelligence": 18,
        "vitality": 9
    },
    "growth_rates": {
        "strength": 0.05,
        "agility": 0.07,
        "intelligence": 0.10,
        "vitality": 0.06
    },
    "description": "Магический враг с высоким уроном, который считает себя гением, потому что может зажечь спичку. Проводит годы в изучении древних заклинаний, чтобы в итоге случайно поджечь сам себя. По крайней мере, он всегда в центре внимания.",
    "starting_abilities": []
}

================================================================================
Файл: game/ui/rendering/__init__.py
================================================================================

# Game/UI/Rendering/__init__.py
"""
Модуль рендеринга пользовательского интерфейса.

Содержит компоненты для отрисовки текста, шаблонов, кнопок и других элементов
интерфейса с поддержкой цветов, форматирования и шаблонов.
"""

from .renderer import Renderer
from .renderable import Renderable, Text, TemplateText, Button, Separator
from .color_manager import Color, ColorManager
from .template_renderer import TemplatePart, TemplateRenderer

__all__ = [
    'Renderer',
    'Renderable', 'Text', 'TemplateText', 'Button', 'Separator',
    'Color', 'ColorManager',
    'TemplatePart', 'TemplateRenderer'
]

================================================================================
Файл: game/ui/rendering/color_manager.py
================================================================================

# game/ui/rendering/color_manager.py
"""Управление цветами для пользовательского интерфейса.

Предоставляет систему цветов и управление цветовыми парами для curses.
"""

import curses
from enum import Enum
from typing import Any  # Для аннотации stdscr


class Color(Enum):
    """Перечисление доступных цветов."""
    DEFAULT = 0
    RED = 1
    GREEN = 2
    YELLOW = 3
    BLUE = 4
    MAGENTA = 5
    CYAN = 6
    WHITE = 7
    # Примечание: GRAY (8) может не поддерживаться всеми терминалами
    GRAY = 8


class ColorManager:
    """Управление цветами для curses."""

    def __init__(self) -> None:
        """Инициализация менеджера цветов."""
        self.color_pairs: dict = {}
        self._initialized = False

    def initialize(self, stdscr: Any) -> None:
        """
        Инициализация цветов.

        Args:
            stdscr: Окно curses для инициализации цветов.
        """
        if not self._initialized and curses.has_colors():
            curses.start_color()
            curses.use_default_colors()

            # Определяем цветовые пары
            curses.init_pair(Color.RED.value, curses.COLOR_RED, -1)
            curses.init_pair(Color.GREEN.value, curses.COLOR_GREEN, -1)
            curses.init_pair(Color.YELLOW.value, curses.COLOR_YELLOW, -1)
            curses.init_pair(Color.BLUE.value, curses.COLOR_BLUE, -1)
            curses.init_pair(Color.MAGENTA.value, curses.COLOR_MAGENTA, -1)
            curses.init_pair(Color.CYAN.value, curses.COLOR_CYAN, -1)
            curses.init_pair(Color.WHITE.value, curses.COLOR_WHITE, -1)
            # TODO: Проверить поддержку цвета 8 (GRAY) в различных терминалах
            curses.init_pair(Color.GRAY.value, 8, -1)

            self._initialized = True

    def get_color_pair(self, color: Color) -> int:
        """
        Получение цветовой пары.

        Args:
            color: Цвет из перечисления Color.

        Returns:
            Цветовая пара для curses.
        """
        if not self._initialized:
            return curses.A_NORMAL
        return curses.color_pair(color.value)


================================================================================
Файл: game/ui/rendering/renderable.py
================================================================================

# game/ui/rendering/renderable.py
"""Базовые элементы пользовательского интерфейса.

Содержит абстрактные и конкретные классы для отображаемых элементов
интерфейса: текст, кнопки, разделители и т.д.
"""

from abc import ABC, abstractmethod
from typing import Dict, Tuple, Optional, TYPE_CHECKING

from game.ui.rendering.color_manager import Color

if TYPE_CHECKING:
    from game.ui.rendering.renderer import Renderer


class Renderable(ABC):
    """Абстрактный базовый класс для всех отображаемых элементов."""

    def __init__(self, x: int = 0, y: int = 0):
        """
        Инициализация отображаемого элемента.

        Args:
            x: Координата X.
            y: Координата Y.
        """
        self.x = x
        self.y = y

    @abstractmethod
    def render(self, renderer: 'Renderer') -> None:
        """
        Отрисовка элемента.

        Args:
            renderer: Рендерер для отрисовки.
        """
        pass


class Text(Renderable):
    """Текстовый элемент."""

    def __init__(self, text: str, x: int = 0, y: int = 0,
                 bold: bool = False, dim: bool = False, color: Color = Color.DEFAULT):
        """
        Инициализация текстового элемента.

        Args:
            text: Отображаемый текст.
            x: Координата X.
            y: Координата Y.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
            color: Цвет текста.
        """
        super().__init__(x, y)
        self.text = text
        self.bold = bold
        self.dim = dim
        self.color = color

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка текста."""
        renderer.draw_text(self.text, self.x, self.y, self.bold, self.dim, self.color)


class TemplateText(Renderable):
    """Текст с шаблонами и цветами."""

    def __init__(self, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]],
                 x: int = 0, y: int = 0):
        """
        Инициализация шаблонного текста.

        Args:
            template: Шаблон текста с плейсхолдерами %1, %2 и т.д.
            replacements: Словарь замен {номер: (текст, цвет, жирный, тусклый)}.
            x: Координата X.
            y: Координата Y.
        """
        super().__init__(x, y)
        self.template = template
        self.replacements = replacements

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка шаблонного текста."""
        renderer.draw_template(self.template, self.replacements, self.x, self.y)


class Button(Renderable):
    """Кнопка."""

    def __init__(self, text: str, x: int = 0, y: int = 0,
                 key: str = "", color: Color = Color.DEFAULT, bold: bool = False, dim: bool = False):
        """
        Инициализация кнопки.

        Args:
            text: Текст кнопки.
            x: Координата X.
            y: Координата Y.
            key: Клавиша для активации.
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        super().__init__(x, y)
        self.text = text
        self.key = key
        self.color = color
        self.bold = bold
        self.dim = dim

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка кнопки."""
        display_text = f"[{self.key}] {self.text}" if self.key else self.text
        renderer.draw_text(display_text, self.x, self.y, self.bold, self.dim, self.color)


class Separator(Renderable):
    """Разделительная линия."""

    def __init__(self, y: int, char: str = "─", length: Optional[int] = None,
                 color: Color = Color.RED, bold: bool = False, dim: bool = True):
        """
        Инициализация разделителя.

        Args:
            y: Координата Y.
            char: Символ для линии.
            length: Длина линии (None для автоматической).
            color: Цвет линии.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        super().__init__(0, y)
        self.char = char
        self.length = length
        self.color = color
        self.bold = bold
        self.dim = dim

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка разделителя."""
        line_length = self.length or renderer.width
        line = self.char * (line_length - 1)
        renderer.draw_text(line, self.x, self.y, self.bold, self.dim, self.color)


================================================================================
Файл: game/ui/rendering/renderer.py
================================================================================

# game/ui/rendering/renderer.py
"""Рендерер для отрисовки элементов пользовательского интерфейса.

Предоставляет абстракцию над библиотекой curses для упрощения отрисовки
текста, шаблонов и других элементов интерфейса.
"""

import curses
from turtle import color
from typing import Dict, Tuple, Any

from game.ui.rendering.color_manager import Color, ColorManager
from game.ui.rendering.template_renderer import TemplateRenderer


class Renderer:
    """Рендерер для отрисовки элементов на экране."""

    def __init__(self, stdscr: curses.window, color_manager: ColorManager) -> None:
        """
        Инициализация рендерера.

        Args:
            stdscr: Окно curses для отрисовки.
            color_manager: Менеджер цветов.
        """
        self.stdscr = stdscr
        self.color_manager = color_manager
        self.template_renderer = TemplateRenderer(color_manager)
        self.height, self.width = stdscr.getmaxyx()

    def clear(self) -> None:
        """Очистка экрана."""
        self.stdscr.clear()

    def draw_text(self, text: str, x: int, y: int,
                  bold: bool = False, dim: bool = False, color: Color = Color.DEFAULT) -> None:
        """
        Отрисовка текста на экране.

        Args:
            text: Текст для отрисовки.
            x: Координата X.
            y: Координата Y.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
            color: Цвет текста.
        """
        try:
            # Проверяем границы экрана
            if y >= self.height or x >= self.width or y < 0 or x < 0:
                return

            # Получаем атрибуты
            attr = self.color_manager.get_color_pair(color)
            if bold:
                attr |= curses.A_BOLD
            if dim:
                attr |= curses.A_DIM

            self.stdscr.addstr(y, x, text, attr)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass

    def draw_template(self, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]],
                      x: int, y: int) -> None:
        """
        Отрисовка шаблонного текста.

        Args:
            template: Шаблон текста с плейсхолдерами %1, %2 и т.д.
            replacements: Словарь замен {номер: (текст, цвет, жирный, тусклый)}.
            x: Координата X.
            y: Координата Y.
        """
        try:
            # Проверяем границы экрана
            if y < 0 or x < 0 or y >= self.height:
                return

            self.template_renderer.draw_template(self.stdscr, template, replacements, x, y)
        except curses.error:
            pass

    def draw_box(self, x: int, y: int, width: int, height: int) -> None:
        """
        Отрисовка прямоугольника.

        Args:
            x: Координата X левого верхнего угла.
            y: Координата Y левого верхнего угла.
            width: Ширина прямоугольника.
            height: Высота прямоугольника.
        """
        try:
            # Верхняя и нижняя границы
            if y < self.height and y + height - 1 < self.height:
                self.stdscr.addstr(y, x, "+" + "-" * (width - 2) + "+")
                self.stdscr.addstr(y + height - 1, x, "+" + "-" * (width - 2) + "+")

            # Боковые границы
            for i in range(1, min(height - 1, self.height - y)):
                if y + i < self.height:
                    self.stdscr.addstr(y + i, x, "|")
                    if x + width - 1 < self.width:
                        self.stdscr.addstr(y + i, x + width - 1, "|")
        except curses.error:
            pass

    def draw_borderless_log_box(self, x: int, y: int, width: int, height: int) -> None:
        """
        Отрисовка прямоугольника.

        Args:
            x: Координата X левого верхнего угла.
            y: Координата Y левого верхнего угла.
            width: Ширина прямоугольника.
            height: Высота прямоугольника.
        """
        а = "┬ ┴"

        try:
            # Верхняя и нижняя границы
            top_text = "├" + "─" * ((width - 3) // 2) + "┴" + "─" * ((width - 3) // 2) + "┤"
            bottom_text = "└" + "─" * (width - 2) + "┘"
            
            self.draw_text(text=top_text, x=x, y=y, color=Color.DEFAULT, dim=True)
            self.draw_text(text=bottom_text, x=x, y=y + height - 1, color=Color.DEFAULT, dim=True)
            
            #if y < self.height and y + height - 1 < self.height:
                #self.stdscr.addstr(y, x, , curses.get_color_pair(Color.DEFAULT))
                #self.stdscr.addstr(y + height - 1, x, "└" + "─" * (width - 2) + "┘")

        except curses.error:
            pass

    def refresh(self) -> None:
        """Обновление экрана."""
        self.stdscr.refresh()


================================================================================
Файл: game/ui/rendering/template_renderer.py
================================================================================

# game/ui/rendering/template_renderer.py
"""Рендерер для работы с шаблонами текста.

Позволяет создавать форматированный текст с плейсхолдерами и различными
стилями для каждой части текста.
"""

import re
from typing import Dict, List, Tuple, Any

import curses

from game.ui.rendering.color_manager import Color, ColorManager


class TemplatePart:
    """Часть шаблона с форматированием."""

    def __init__(self, text: str, color: Color = Color.DEFAULT, bold: bool = False, dim: bool = False):
        """
        Инициализация части шаблона.

        Args:
            text: Текст части.
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        self.text = text
        self.color = color
        self.bold = bold
        self.dim = dim


class TemplateRenderer:
    """Рендерер для работы с шаблонами текста."""

    def __init__(self, color_manager: ColorManager) -> None:
        """
        Инициализация рендерера шаблонов.

        Args:
            color_manager: Менеджер цветов для применения стилей.
        """
        self.color_manager = color_manager
        # Регулярное выражение для поиска плейсхолдеров типа %1, %2 и т.д.
        self.placeholder_pattern = re.compile(r'%(\d+)')

    def render_template(self, template: str,
                       replacements: Dict[str, Tuple[str, Color, bool, bool]]) -> List[TemplatePart]:
        """
        Рендер шаблона с заменами.

        Args:
            template: Шаблон текста, например "%1 ударяет %2".
            replacements: Словарь {номер: (текст, цвет, жирный, тусклый)}, например {"1": ("Игрок", Color.GREEN, True, False)}.

        Returns:
            Список частей текста с форматированием.
        """
        parts: List[TemplatePart] = []
        last_end = 0

        # Находим все плейсхолдеры
        for match in self.placeholder_pattern.finditer(template):
            start, end = match.span()
            placeholder_num = match.group(1)

            # Добавляем текст до плейсхолдера
            if start > last_end:
                parts.append(TemplatePart(template[last_end:start]))

            # Добавляем замену для плейсхолдера
            if placeholder_num in replacements:
                text, color, bold, dim = replacements[placeholder_num]
                parts.append(TemplatePart(text, color, bold, dim))
            else:
                # Если нет замены, оставляем плейсхолдер как есть
                parts.append(TemplatePart(match.group(0)))

            last_end = end

        # Добавляем оставшийся текст
        if last_end < len(template):
            parts.append(TemplatePart(template[last_end:]))

        return parts

    def draw_template(self, stdscr: curses.window, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]],
                     x: int, y: int) -> None:
        """
        Отрисовка шаблона на экране.

        Args:
            stdscr: Окно curses для отрисовки.
            template: Шаблон текста.
            replacements: Словарь замен.
            x: Координата X.
            y: Координата Y.
        """
        try:
            parts = self.render_template(template, replacements)
            current_x = x

            for part in parts:
                if y >= 0 and current_x >= 0:
                    attr = self.color_manager.get_color_pair(part.color)
                    if part.bold:
                        attr |= curses.A_BOLD
                    if part.dim:
                        attr |= curses.A_DIM

                    stdscr.addstr(y, current_x, part.text, attr)
                    current_x += len(part.text)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass


================================================================================
Файл: game/ui/command_system/__init__.py
================================================================================

# game/ui/command_system/__init__.py
"""
Система команд пользовательского интерфейса.

Содержит самодостаточные команды и систему их регистрации.
"""

from .command import Command, CommandRegistry
from .screen_command_registry import (
    register_screen_commands,
    get_screen_commands,
    get_all_registered_screens,
    clear_registry
)
from .command_renderer import CommandRenderer  # ДОБАВИЛИ!

__all__ = [
    'Command',
    'CommandRegistry',
    'CommandRenderer',  # ДОБАВИЛИ!
    'register_screen_commands',
    'get_screen_commands',
    'get_all_registered_screens',
    'clear_registry'
]

================================================================================
Файл: game/ui/command_system/command.py
================================================================================

# game/ui/command_system/command.py
"""Базовые классы для системы команд.

Реализует паттерн Команда для обработки пользовательского ввода.
"""

from abc import ABC, abstractmethod
import curses
from typing import List, Set, Optional, Any, Union

# Отложенная аннотация для избежения циклического импорта
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen


class Command(ABC):
    """Абстрактная команда."""

    def __init__(self, name: str, description: str, keys: List[Union[str, int]], display_key: str = ""):
        """
        Инициализация команды.

        Args:
            name: Название команды.
            description: Описание команды.
            keys: Список клавиш, на которые назначена команда (например, ['q', 'ESC']).
            display_key: Клавиша для отображения в интерфейсе (если отличается от первой в keys).
        """
        self.name = name
        self.description = description
        self.keys = keys  # Список символов, например ['q', 'ESC']
        self.display_key = display_key if display_key else (str(keys[0]) if keys else "")

    def get_key_codes(self) -> Set[int]:
        """Получение множества кодов клавиш команды."""
        # ord работает только со строками, числа возвращаем как есть
        return {key if isinstance(key, int) else ord(key) for key in self.keys}

    @abstractmethod
    def execute(self, context: Any = None) -> bool:
        """
        Выполнение команды.
        
        Args:
            context: Контекст выполнения команды.
            
        Returns:
            bool: True если команда выполнена успешно, False в противном случае.
        """
        raise NotImplementedError("Метод execute должен быть реализован в подклассе.")


class CommandRegistry:
    """Реестр команд для экрана."""

    def __init__(self) -> None:
        self._commands: List[Command] = []
        self._key_to_command: dict[int, Command] = {}  # key_code -> command

    def register_command(self, command: Command) -> None:
        """
        Регистрация команды.

        Args:
            command: Команда для регистрации.
        """
        self._commands.append(command)
        # Регистрируем все клавиши команды
        for key_code in command.get_key_codes():
            self._key_to_command[key_code] = command

    def execute_command(self, key_code: int, context: Optional[Any] = None) -> bool:
        """
        Выполнение команды по коду клавиши.

        Args:
            key_code: Код нажатой клавиши.
            context: Контекст выполнения.

        Returns:
            True если команда найдена и выполнена, False если нет.
        """
        command = self._key_to_command.get(key_code)
        if command:
            command.execute(context)
            return True
        return False

    def get_all_commands(self) -> List[Command]:
        """Получение всех зарегистрированных команд."""
        return self._commands.copy()

    def get_command_by_key(self, key_code: int) -> Optional[Command]:
        """Получение команды по коду клавиши."""
        return self._key_to_command.get(key_code)


================================================================================
Файл: game/ui/command_system/command_renderer.py
================================================================================

# game/ui/command_system/command_renderer.py
"""Отрисовка команд пользовательского интерфейса.

Отдельный класс для отображения информации о доступных командах.
"""

from typing import List, TYPE_CHECKING

from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Text

if TYPE_CHECKING:
    from game.ui.command_system.command import Command


class CommandRenderer:
    """Обработчик отображения списка доступных команд."""

    def __init__(self, x: int = 0, y: int = 15, max_width: int = 70):
        """
        Инициализация отрисовщика команд.

        Args:
            x: Начальная координата X.
            y: Начальная координата Y.
            max_width: Максимальная ширина строки команд.
        """
        self.x = x
        self.y = y
        self.max_width = max_width

    def render_commands(self, commands: List['Command']) -> List[Text]:
        """
        Создание элементов отрисовки для команд в одной строке.
        Команды отображаются в формате "key : описание", разделенные " | ".
        Все элементы - тускло серые.

        Args:
            commands: Список команд для отрисовки.

        Returns:
            Список текстовых элементов для отрисовки.
        """
        if not commands:
            return []

        # Создаем список строк для каждой команды и объединяем их
        command_strings = [f"{command.display_key} : {command.name}" for command in commands]
        full_line = " | ".join(command_strings)

        # Возвращаем один текстовый элемент, весь текст будет тускло серым
        return [Text(full_line, self.x, self.y, dim=True, color=Color.GRAY)]


================================================================================
Файл: game/ui/command_system/screen_command_registry.py
================================================================================

# game/ui/command_system/screen_command_registry.py
"""Реестр команд для экранов.

Реализует паттерн Registry для хранения связей между классами экранов и их командами.
"""

from typing import Dict, List, Type, TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen
    from game.ui.command_system.command import Command

# Глобальный реестр: КлассЭкрана -> СписокКоманд
SCREEN_COMMANDS: Dict[Type['BaseScreen'], List['Command']] = {}


def register_screen_commands(screen_class: Type['BaseScreen'], commands: List['Command']) -> None:
    """
    Регистрация команд для конкретного экрана.

    Args:
        screen_class: Класс экрана.
        commands: Список команд для этого экрана.
    """
    SCREEN_COMMANDS[screen_class] = commands


def get_screen_commands(screen_class: Type['BaseScreen']) -> List['Command']:
    """
    Получение команд для конкретного экрана.

    Args:
        screen_class: Класс экрана.

    Returns:
        Список команд для экрана (пустой список если нет команд).
    """
    return SCREEN_COMMANDS.get(screen_class, [])


def get_all_registered_screens() -> List[Type['BaseScreen']]:
    """
    Получение всех экранов с зарегистрированными командами.

    Returns:
        Список классов экранов.
    """
    return list(SCREEN_COMMANDS.keys())


def clear_registry() -> None:
    """Очистка реестра (для тестирования)."""
    SCREEN_COMMANDS.clear()


================================================================================
Файл: game/ui/commands/inventory_commands.py
================================================================================

# game/ui/commands/inventory_commands.py
"""
Специфические команды для экрана инвентаря.
"""

from curses import KEY_ENTER
from game.ui.command_system.command import Command
from game.ui.inventory_screen import InventoryScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class UseItemCommand(Command):
    """Команда использования предмета."""

    def __init__(self):
        super().__init__(
            name="Использовать",
            description="Использовать выбранный предмет",
            keys=['u', KEY_ENTER],
            display_key="u/Enter"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды использования предмета."""
        if context:
            print("Предмет использован")


class DropItemCommand(Command):
    """Команда выбрасывания предмета."""

    def __init__(self):
        super().__init__(
            name="Выбросить",
            description="Выбросить выбранный предмет",
            keys=['d'],
            display_key="d"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды выбрасывания предмета."""
        if context:
            print("Предмет выброшен")


# Импортируем общие команды
from game.ui.commands.common_commands import GoBackCommand

# Регистрируем команды для экрана инвентаря
register_screen_commands(InventoryScreen, [
    UseItemCommand(),
    DropItemCommand(),
    GoBackCommand()  # Переиспользуем общую команду
])

================================================================================
Файл: game/ui/commands/battle_commands.py
================================================================================

# game/ui/commands/battle_commands.py
"""
Специфические команды для экрана боя.
"""

from game.ui.command_system.command import Command
from game.ui.battle_screen import BattleScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class AttackCommand(Command):
    """Команда атаки."""

    def __init__(self):
        super().__init__(
            name="Атака",
            description="Атаковать противника",
            keys=['a', 'A'],
            display_key="A/a"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды атаки."""
        if context:
            print("Атака!")


class DefendCommand(Command):
    """Команда защиты."""

    def __init__(self):
        super().__init__(
            name="Защита",
            description="Защититься от атаки",
            keys=['d'],
            display_key="d"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды защиты."""
        if context:
            print("Защита!")


class MagicCommand(Command):
    """Команда использования магии."""

    def __init__(self):
        super().__init__(
            name="Магия",
            description="Использовать магическое заклинание",
            keys=['m'],
            display_key="m"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды магии."""
        if context:
            print("Магия!")


# Импортируем общие команды
from game.ui.commands.common_commands import GoBackCommand, OpenInventoryCommand

# Регистрируем команды для экрана боя
register_screen_commands(BattleScreen, [
    AttackCommand(),
    DefendCommand(),
    MagicCommand(),
    OpenInventoryCommand(),  # Переиспользуем общую команду
    GoBackCommand()          # Переиспользуем общую команду
])

================================================================================
Файл: game/ui/commands/__init__.py
================================================================================

# game/ui/commands/__init__.py
"""Пакет конкретных команд для разных экранов.

Содержит реализации команд для конкретных экранов игры.
"""

# ВАЖНО: Импортируем все команды, чтобы они зарегистрировались
import game.ui.commands.common_commands
import game.ui.commands.inventory_commands
import game.ui.commands.battle_commands
import game.ui.commands.main_screen_commands

# Экспортируем основные классы команд для удобства использования
# Общие команды
from .common_commands import (
    GoBackCommand,
    OpenInventoryCommand,
    HelpCommand,
    ExitCommand
)

# Специфические команды инвентаря
from .inventory_commands import (
    UseItemCommand,
    DropItemCommand
)

# Специфические команды боя
from .battle_commands import (
    AttackCommand,
    DefendCommand,
    MagicCommand as BattleMagicCommand
)

# Специфические команды главного экрана
from .main_screen_commands import (
    StartBattleCommand,
    OpenSettingsCommand
)

__all__ = [
    # Общие команды
    'GoBackCommand',
    'OpenInventoryCommand',
    'HelpCommand',
    'ExitCommand',

    # Команды инвентаря
    'UseItemCommand',
    'DropItemCommand',

    # Команды боя
    'AttackCommand',
    'DefendCommand',
    'BattleMagicCommand',

    # Команды главного экрана
    'StartBattleCommand',
    'OpenSettingsCommand'
]


================================================================================
Файл: game/ui/commands/common_commands.py
================================================================================

# game/ui/commands/common_commands.py
"""Общие команды, которые могут использоваться в нескольких экранах."""

from typing import Optional, Any

from game.ui.command_system.command import Command


class GoBackCommand(Command):
    """Общая команда возврата назад."""

    def __init__(self):
        super().__init__(
            name="Назад",
            description="Вернуться к предыдущему экрану",
            keys=['q'],
            display_key="q"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды возврата."""
        if context and hasattr(context, 'manager'):
            context.manager.go_back()


class OpenInventoryCommand(Command):
    """Общая команда открытия инвентаря."""

    def __init__(self):
        super().__init__(
            name="Инвентарь",
            description="Открыть инвентарь",
            keys=['i'],
            display_key="i"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды открытия инвентаря."""
        if context and hasattr(context, 'manager'):
            context.manager.change_screen("inventory")


class HelpCommand(Command):
    """Общая команда помощи."""

    def __init__(self):
        super().__init__(
            name="Помощь",
            description="Показать помощь",
            keys=['h', '?'],
            display_key="h/?"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды помощи."""
        # TODO: Заменить print на отображение внутри curses UI
        if context:
            print("Помощь по экрану:", context.__class__.__name__ if context else "Неизвестный экран")


class ExitCommand(Command):
    """Общая команда выхода из игры."""

    def __init__(self):
        super().__init__(
            name="Выход",
            description="Выйти из игры",
            keys=['q'],  # Только q, не ESC чтобы избежать конфликтов
            display_key="q"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды выхода."""
        # TODO: Рассмотреть использование raise SystemExit() вместо exit()
        exit()


================================================================================
Файл: game/ui/commands/main_screen_commands.py
================================================================================

# game/ui/commands/main_screen_commands.py
"""Специфические команды для главного экрана."""

from typing import Optional, Any

from game.ui.command_system.command import Command
from game.ui.command_system.screen_command_registry import register_screen_commands
# Импортируем общие команды
from game.ui.commands.common_commands import OpenInventoryCommand, ExitCommand
# Импортируем экран для регистрации команд
from game.ui.main_screen import MainScreen


class StartBattleCommand(Command):
    """Команда начала боя."""

    def __init__(self):
        super().__init__(
            name="Бой",
            description="Начать бой",
            keys=[10],
            display_key="Enter"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды начала боя."""
        if context and hasattr(context, 'manager'):
            context.manager.change_screen("battle")


class OpenSettingsCommand(Command):
    """Команда открытия настроек."""

    def __init__(self):
        super().__init__(
            name="Настройки",
            description="Открыть настройки",
            keys=['3'],
            display_key="3"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды открытия настроек."""
        # TODO: Заменить print на отображение внутри curses UI
        if context:
            print("Открытие настроек")


# Регистрируем команды для главного экрана
register_screen_commands(MainScreen, [
    StartBattleCommand(),
    OpenInventoryCommand(),  # Переиспользуем общую команду
    OpenSettingsCommand(),
    ExitCommand()            # Переиспользуем общую команду
])


================================================================================
Файл: game/ui/components/battle_components.py
================================================================================

# game/ui/components/battle_components.py
"""Компоненты для экрана боя.
Содержит визуальные элементы для отображения игроков, врагов и лога боя."""

import curses
from typing import List, TYPE_CHECKING

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import Color
# Импортируем новые виджеты
from game.ui.widgets.labels import CharacterNameLabel, CharacterLevelLabel, CharacterClassLabel, TextLabel
from game.ui.widgets.bars import HealthBar, EnergyBar

# Импорты для аннотаций типов, чтобы избежать циклических импортов на уровне выполнения
if TYPE_CHECKING:
    from game.entities.monster import Monster
    from game.entities.player import Player
    from game.entities.character import Character


class UnitPanel(Renderable):
    """Базовая панель для отображения одного юнита (игрока или врага) в одну строку."""
    
    # Константы для компоновки
    DEFAULT_WIDGET_MAX_WIDTH = 10
    MIN_NAME_WIDTH = 5
    MIN_WIDGET_WIDTH = 3
    WIDGET_SPACING = 1
    CHARACTER_NAME_WIDTH = 6  # Все имена персонажей состоят из максимум 6 букв. 
    MONSTER_NAME_WIDTH = 20
    HP_BAR_WIDTH = 10
    EP_BAR_WIDTH = 5
    
    # Константы для оценки минимальной ширины элементов
    ESTIMATED_LEVEL_WIDTH = 3
    ESTIMATED_HP_WIDTH = 10  # Обновлено для прогресс-баров
    ESTIMATED_ENERGY_WIDTH = 5  # Обновлено для прогресс-баров
    
    # Пороги для цветов HP
    HP_CRITICAL_THRESHOLD = 0.25
    HP_LOW_THRESHOLD = 0.5

    def __init__(self, character: 'Character', x: int, y: int, width: int, height: int) -> None:
        """Инициализация базовой панели юнита.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (должна быть 1 для соответствия новому дизайну).
        """
        super().__init__(x, y)
        self.width = width
        self.height = height  # Ожидается 1
        self.character = character
        
        if character.is_player:
            name_width = self.CHARACTER_NAME_WIDTH 
            color = Color.GREEN
        else:
            name_width = self.MONSTER_NAME_WIDTH
            color = Color.BLUE

        # Инициализируем виджеты
        self.name_label = CharacterNameLabel(character=self.character, x=x, y=y, max_width=name_width, color=color)
        self.class_label = CharacterClassLabel(character=self.character, x=x, y=y)
        self.level_label = CharacterLevelLabel(character=self.character, x=x, y=y)
        
        self.hp_label = HealthBar(character=self.character, x=x, y=y, width=self.HP_BAR_WIDTH)
        self.energy_label = EnergyBar(character=character, x=x, y=y, width=self.EP_BAR_WIDTH)
        # Для HP и Energy в бою отображаем числовые значения, а не прогресс-бары
        # Поэтому создаем специальные текстовые лейблы
        #self.hp_label = TextLabel(x=x, y=y)
        #self.energy_label = TextLabel(x=x, y=y)

    def update_size(self, width: int, height: int) -> None:
        """
        Обновить размеры панели и пересчитать позиции виджетов.
        
        Args:
            width: Новая ширина.
            height: Новая высота (игнорируется, устанавливается в 1).
        """
        self.width = width
        self.height = 1  # Фиксированная высота для однострочной панели
        
        # Пересчитываем позиции виджетов
        self._update_widgets_positions()

    def _update_widgets_positions(self) -> None:
        """Обновить позиции и размеры виджетов в зависимости от ширины панели."""
        if not self.character:
            return
            
        current_x = self.x
        
        # 1. Имя
        self.name_label.x = current_x
        self.name_label.y = self.y
        name_width = self.name_label.max_width
        current_x += name_width + self.WIDGET_SPACING

        # 2. Класс/роль
        self.class_label.x = current_x
        self.class_label.y = self.y
        class_width = len(self.class_label.text) + 2  # Примерная ширина [R]
        current_x += class_width  #  Spacing не нужен 
        
        # 3. Уровень
        self.level_label.x = current_x
        self.level_label.y = self.y
        level_width = len(self.level_label.text) + 2
        current_x += level_width

        # 4. HP
        self.hp_label.x = current_x
        self.hp_label.y = self.y
        current_x += self.hp_label.width + 2
        
        # 5. Energy
        self.energy_label.x = current_x
        self.energy_label.y = self.y

    def render(self, renderer: Renderer) -> None:
        """Отрисовка базовой панели юнита в одну строку."""
        if not self.character:
            # Если персонаж не установлен, отображаем заглушку
            placeholder_text = "Нет данных"
            display_text = placeholder_text.ljust(self.width)[:self.width]
            try:
                renderer.draw_text(display_text, self.x, self.y, color=Color.GRAY)
            except curses.error:
                pass
            return

        # Пересчитываем позиции виджетов перед отрисовкой
        self._update_widgets_positions()
        
        # Отрисовываем все виджеты
        self.name_label.render(renderer)
        self.class_label.render(renderer)
        self.level_label.render(renderer)
        self.hp_label.render(renderer)
        self.energy_label.render(renderer)
            
        # Заполняем оставшееся пространство пробелами для затирания предыдущего содержимого
        # last_widget_end_x = self.energy_label.x + len(self.energy_label.text) if self.energy_label.text else \
        #                   (self.hp_label.x + len(self.hp_label.text))
        # if last_widget_end_x < self.x + self.width:
        #     remaining_width = (self.x + self.width) - last_widget_end_x
        #     try:
        #         renderer.draw_text(" " * remaining_width, last_widget_end_x, self.y)
        #     except curses.error:
        #         pass


class EnemyUnitPanel(UnitPanel):
    """Панель для отображения одного врага."""

    def __init__(self, x: int, y: int, width: int, height: int, monster: 'Monster') -> None:
        """Инициализация панели врага.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (должна быть 1).
            monster: Объект Monster для отображения.
        """
        super().__init__(monster, x, y, width, height)


class PlayerUnitPanel(UnitPanel):
    """Панель для отображения одного игрока."""

    def __init__(self, x: int, y: int, width: int, height: int, player: 'Player') -> None:
        """Инициализация панели игрока.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (должна быть 1).
            player: Объект Player для отображения.
        """
        super().__init__(player, x, y, width, height)


class GroupPanel(Renderable):
    """Базовая панель для отображения группы юнитов без внешнего обрамления."""

    def __init__(self, x: int, y: int, width: int, height: int) -> None:
        """Инициализация базовой панели группы.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели.
        """
        super().__init__(x, y)
        self.width = width
        self.height = height
        # Этот список будет заполняться в подклассах
        self.panels: List[UnitPanel] = []

    def update_size(self, max_width: int, max_height: int) -> None:
        """
        Обновление размеров панели и её компонентов.
        Args:
            max_width: Максимальная ширина экрана.
            max_height: Максимальная высота экрана.
        """
        # Обновление размеров дочерних панелей
        if self.panels:
            # Рассчитываем ширину для каждой панели
            panel_count = len(self.panels)
            new_panel_width = max(10, self.width // panel_count) if panel_count > 0 else self.width

            for i, panel in enumerate(self.panels):
                panel.width = new_panel_width
                panel.height = 1  # Высота панели юнита должна быть 1
                panel.update_size(new_panel_width, 1)  # Обновляем размеры внутренних виджетов

    def render(self, renderer: Renderer) -> None:
        """Отрисовка панели группы без внешнего обрамления."""
        # НЕ отрисовываем рамку вокруг группы
        # Отрисовка каждой панели юнита
        for panel in self.panels:
            panel.render(renderer)


class EnemyGroupPanel(GroupPanel):
    """Панель для отображения группы врагов."""

    def __init__(self, x: int, y: int, width: int, height: int, enemies: List['Monster']) -> None:
        """Инициализация панели группы врагов.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (ожидается 5).
            enemies: Список объектов Monster для отображения.
        """
        # Инициализируем базовую панель группы
        super().__init__(x, y, width, height)
        # Сохраняем ссылку на список объектов Monster
        self.enemies = enemies
        # Обновляем панели на основе переданных объектов
        self._update_panels()

    def _update_panels(self) -> None:
        """Обновление списка панелей на основе объектов врагов."""
        self.panels = []
        
        for i, monster in enumerate(self.enemies):
            # Каждая панель размещается на отдельной строке
            panel_x = self.x
            panel_y = self.y + i  # Одна строка на панель
            panel_width = self.width
            panel_height = 1  # Фиксированная высота 1 строка
            
            # Создаем панель, передавая объект Monster
            panel = EnemyUnitPanel(panel_x, panel_y, panel_width, panel_height, monster)
            self.panels.append(panel)


class PlayerGroupPanel(GroupPanel):
    """Панель для отображения группы игроков."""

    def __init__(self, x: int, y: int, width: int, height: int, players: List['Player']) -> None:
        """Инициализация панели группы игроков.
        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели (ожидается 5).
            players: Список объектов Player для отображения.
        """
        # Инициализируем базовую панель группы
        super().__init__(x, y, width, height)
        # Сохраняем ссылку на список объектов Player
        self.players = players
        # Обновляем панели на основе переданных объектов
        self._update_panels()

    def _update_panels(self) -> None:
        """Обновление списка панелей на основе объектов игроков."""
        self.panels = []
        
        for i, player in enumerate(self.players):
            # Каждая панель размещается на отдельной строке
            panel_x = self.x
            panel_y = self.y + i  # Одна строка на панель
            panel_width = self.width
            panel_height = 1  # Фиксированная высота 1 строка
            
            # Создаем панель, передавая объект Player
            panel = PlayerUnitPanel(panel_x, panel_y, panel_width, panel_height, player)
            self.panels.append(panel)


class BattleLog(Renderable):
    """Лог боя в нижней части экрана с прокруткой и обрамлением."""

    def __init__(self, x: int, y: int, width: int, height: int) -> None:
        super().__init__(x, y)
        self.width = width
        self.height = height
        # TODO: Получать реальные сообщения из игровой логики
        self.messages: List[str] = [
            "Битва начинается!",
            "Герой вступает в бой с Драконом.",
            "Дракон издает грозный рык.",
            "Герой атакует Дракона!",
            "Дракон получает 25 урона.",
            "Дракон атакует Героя!",
            "Герой получает 15 урона.",
            "Герой использует зелье лечения.",
            "Герой восстанавливает 30 HP.",
            "Дракон готовится к мощной атаке!",
            "Герой защищается.",
            "Мощная атака Дракона отражена!",
        ]
        self.scroll_offset = 0 # Смещение прокрутки (0 = последние сообщения внизу)

    def add_message(self, message: str) -> None:
        """Добавление сообщения в лог.
        Args:
            message: Текст сообщения.
        """
        self.messages.append(message)
        # При добавлении нового сообщения сбрасываем прокрутку вниз
        self.scroll_offset = 0

    def scroll_up(self) -> None:
        """Прокрутка лога вверх."""
        # Максимальное смещение - это количество строк, которые не помещаются
        max_offset = max(0, len(self.messages) - self.height)
        if self.messages:
            self.scroll_offset = min(max_offset, self.scroll_offset + 1)

    def scroll_down(self) -> None:
        """Прокрутка лога вниз."""
        if self.messages:
            self.scroll_offset = max(0, self.scroll_offset - 1)

    def update_size(self, total_width: int, total_height: int) -> None:
        """Обновление размеров лога.
        Args:
            total_width: Общая ширина экрана.
            total_height: Общая высота экрана.
        """
        # Занимает всю ширину экрана (с отступами)
        self.width = max(10, total_width - 2) # -2 для отступов
        # Высота динамическая, устанавливается в BattleScreen._update_component_sizes
        # Пока оставим пустую реализацию или базовую
        pass

    def render(self, renderer: Renderer) -> None:
        """Отрисовка лога боя с обрамлением."""
        # Отрисовка рамки лога (она остается)
        try:
            renderer.draw_borderless_log_box(self.x, self.y, self.width, self.height)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass

        # Определяем, какие сообщения отображать с учетом прокрутки
        # scroll_offset = 0 означает, что последние сообщения внизу
        start_index = max(0, len(self.messages) - self.height - self.scroll_offset)
        end_index = start_index + self.height
        visible_messages = self.messages[start_index:end_index]

        # Отрисовка сообщений
        for i, message in enumerate(visible_messages):
            # Позиция Y для текущего сообщения
            msg_y = self.y + 1 + i
            # Позиция X (с небольшим отступом)
            msg_x = self.x + 1

            # Отрисовка текста сообщения
            try:
                # TODO: Добавить цвета/стили для разных типов сообщений (урон, лечение, и т.д.)
                renderer.draw_text(message, msg_x, msg_y, color=Color.WHITE)
            except curses.error:
                # Игнорируем ошибки выхода за границы экрана
                pass


================================================================================
Файл: game/ui/widgets/labels.py
================================================================================

# game/ui/widgets/labels.py
"""Базовые текстовые метки для отображения информации.
Эти компоненты могут использоваться в различных частях интерфейса,
например, для отображения имени, уровня, класса персонажа и другой информации."""

from typing import Optional, TYPE_CHECKING, Any, Dict, Tuple

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import Color

if TYPE_CHECKING:
    from game.entities.character import Character


class TextLabel(Renderable):
    """Базовая текстовая метка."""

    def __init__(
        self, 
        x: int = 0, 
        y: int = 0, 
        text: str = "", 
        color: Color = Color.DEFAULT,
        bold: bool = False,
        dim: bool = False
    ) -> None:
        """
        Инициализация текстовой метки.

        Args:
            x: Координата X.
            y: Координата Y.
            text: Отображаемый текст.
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        super().__init__(x, y)

        self.text = text
        self.color = color
        self.bold = bold
        self.dim = dim
        

    def render(self, renderer: Renderer) -> None:
        """Отрисовка текстовой метки."""
        if self.text:
            renderer.draw_text(self.text, self.x, self.y, self.bold, self.dim, self.color)


class CharacterNameLabel(TextLabel):
    """Метка для отображения имени персонажа."""

    def __init__(
        self,
        character: 'Character', 
        x: int = 0, 
        y: int = 0,
        max_width: int = 0,
        color: Color = Color.DEFAULT,
        bold: bool = False,
        dim: bool = False
    ) -> None:
        """
        Инициализация метки имени персонажа.

        Args:
            x: Координата X.
            y: Координата Y.
            character: Объект персонажа, имя которого нужно отобразить.
            max_width: Максимальная ширина текста (для обрезки/усечения).
            color: Цвет текста.
            bold: Жирный шрифт.
            dim: Тусклый шрифт.
        """
        # Инициализируем с пустым текстом, он будет обновлен в update_from_character
        super().__init__(x, y, "", color, bold, dim)
        self.character = character
        self.max_width = max_width
        self._update_from_character()

    def _update_from_character(self) -> None:
        """Обновить текст метки из данных персонажа."""
        if self.character:
            name = getattr(self.character, 'name', 'Unknown')
            if self.max_width and len(name) > self.max_width:
                # Простое усечение, можно улучшить (например, добавить "...")
                self.text = name[:self.max_width]
            else:
                self.text = name
        else:
            self.text = "Unknown"


class TemplatedTextLabel(TextLabel):
    """Базовая метка для отрисовки текста с использованием шаблонов и цветов."""
    
    def __init__(self, x: int = 0, y: int = 0) -> None:
        """
        Инициализация метки с шаблонами.

        Args:
            x: Координата X.
            y: Координата Y.
        """
        super().__init__(x, y)

    def _create_bracketed_template(
        self, 
        content: str, 
        content_color: Color = Color.DEFAULT,
        bracket_color: Color = Color.WHITE
    ) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Создать шаблон вида [content] с разными цветами для скобок и содержимого.

        Args:
            content: Содержимое внутри скобок.
            content_color: Цвет содержимого.
            bracket_color: Цвет скобок.

        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        return (
            "%1%2%3",
            {
                "1": ("[", bracket_color, False, False),
                "2": (content, content_color, False, False),
                "3": ("]", bracket_color, False, False)
            }
        )

    def render(self, renderer: Renderer) -> None:
        """Отрисовка текста с использованием шаблона."""
        template, replacements = self._get_template_and_replacements()
        renderer.draw_template(template, replacements, self.x, self.y)
        
    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Получить шаблон и словарь замен для отрисовки.
        
        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        raise NotImplementedError("Subclasses must implement _get_template_and_replacements")


class CharacterClassLabel(TemplatedTextLabel):
    """Метка для отображения класса/роли персонажа в формате [Роль]."""

    def __init__(
        self,
        character: 'Character', 
        x: int = 0, 
        y: int = 0, 
    ) -> None:
        """
        Инициализация метки класса персонажа.

        Args:
            x: Координата X.
            y: Координата Y.
            character: Объект персонажа, класс которого нужно отобразить.
        """
        super().__init__(x, y)
        self.character = character
        self._update_from_character()

    def _update_from_character(self) -> None:
        """Обновить текст метки из данных персонажа."""
        if self.character:
            self.text = getattr(self.character, 'class_icon', "?")
            color = getattr(self.character, 'class_icon_color')
            self.color = Color[color] if color else self.color
   

    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """Определяем шаблон и замены для роли."""
        return self._create_bracketed_template(self.text, self.color)


class CharacterLevelLabel(TemplatedTextLabel):
    """Метка для отображения уровня персонажа в формате [1]."""

    def __init__(
        self,
        character: 'Character', 
        x: int = 0, 
        y: int = 0, 
        
    ) -> None:
        """
        Инициализация метки уровня персонажа.

        Args:
            x: Координата X.
            y: Координата Y.
            character: Объект персонажа, уровень которого нужно отобразить.
        """
        super().__init__(x, y)
        self.character = character
        self._update_from_character()

    def _update_from_character(self) -> None:
        if self.character:
            level = getattr(self.character, 'level', 1)
        else:
            level = 1
        self.text = str(level)

    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """Определяем шаблон и замены для уровня."""
        return self._create_bracketed_template(self.text, Color.YELLOW)


================================================================================
Файл: game/ui/widgets/__init__.py
================================================================================

# game/ui/widgets/__init__.py
"""Переиспользуемые UI компоненты."""

from .labels import (
    TextLabel,
    CharacterNameLabel,
    CharacterClassLabel,
    CharacterLevelLabel
)

from .bars import (
    ProgressBar,
    HealthBar,
    EnergyBar
)

from .character_card import (
    CharacterInfoPanel
)

__all__ = [
    'TextLabel',
    'CharacterNameLabel',
    'CharacterClassLabel',
    'CharacterLevelLabel',
    'ProgressBar',
    'HealthBar',
    'EnergyBar',
    'CharacterInfoPanel',
]

================================================================================
Файл: game/ui/widgets/bars.py
================================================================================

# game/ui/widgets/bars.py
"""Прогресс-бары для отображения различных параметров (HP, Energy и т.д.).
Эти компоненты могут использоваться в различных частях интерфейса,
например, на экране боя, экране персонажа и т.д."""

from typing import Optional, TYPE_CHECKING, Dict, Tuple
from abc import ABC, abstractmethod

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import Color

if TYPE_CHECKING:
    from game.entities.character import Character


class ProgressBar(Renderable, ABC):
    """Базовый класс для отрисовки прогресс-бара с использованием шаблонов."""

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 20,
        character: Optional['Character'] = None
    ) -> None:
        """
        Инициализация базового прогресс-бара.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина прогресс-бара в символах.
            character: Объект персонажа для отслеживания значений.
        """
        super().__init__(x, y)
        self.width = width
        self.character = character

    @abstractmethod
    def _get_current_value(self) -> int:
        """Получить текущее значение из персонажа."""
        pass

    @abstractmethod
    def _get_max_value(self) -> int:
        """Получить максимальное значение из персонажа."""
        pass

    @abstractmethod
    def _get_fill_color(self) -> Color:
        """Получить цвет заполненной части прогресс-бара."""
        pass

    @abstractmethod
    def _get_empty_color(self) -> Color:
        """Получить цвет пустой части прогресс-бара."""
        pass

    def set_character(self, character: Optional['Character']) -> None:
        """
        Установить персонажа для отслеживания значений.

        Args:
            character: Объект персонажа или None.
        """
        self.character = character

    def _create_progress_template(
        self,
        filled_count: int,
        empty_count: int
    ) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Создать шаблон и словарь замен для отрисовки прогресс-бара.

        Args:
            filled_count: Количество заполненных символов.
            empty_count: Количество пустых символов.

        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        # Создаем строки заполнения
        filled_part = "■" * filled_count  # Полностью заполненные символы
        empty_part = "□" * empty_count    # Пустые символы

        # Создаем шаблон
        # %1 - открывающая скобка, %2 - заполненная часть, %3 - пустая часть, %4 - закрывающая скобка
        template = "%1%2%3%4"
        
        replacements = {
            "1": ("[", Color.WHITE, False, False),      # Открывающая скобка
            "2": (filled_part, self._get_fill_color(), False, False),  # Заполненная часть
            "3": (empty_part, self._get_empty_color(), False, False),  # Пустая часть
            "4": ("]", Color.WHITE, False, False)       # Закрывающая скобка
        }
        
        return template, replacements

    def render(self, renderer: Renderer) -> None:
        """Отрисовка прогресс-бара с использованием шаблона."""
        template, replacements = self._get_template_and_replacements()
        renderer.draw_template(template, replacements, self.x, self.y)

    def _get_template_and_replacements(self) -> Tuple[str, Dict[str, Tuple[str, Color, bool, bool]]]:
        """
        Создать шаблон и словарь замен для отрисовки прогресс-бара.

        Returns:
            Кортеж (шаблон, словарь_замен).
        """
        # Получаем значения из персонажа
        if self.character:
            current_value = self._get_current_value()
            max_value = self._get_max_value()
        else:
            current_value = 0
            max_value = 1

        # Рассчитываем количество заполненных и пустых символов
        if max_value <= 0:
            filled_count = 0
        else:
            # Используем пропорцию: filled_count / self.width = current_value / max_value
            filled_count = int((current_value / max_value) * self.width)
        
        # Убеждаемся, что значения в допустимых пределах
        filled_count = max(0, min(filled_count, self.width))
        empty_count = self.width - filled_count

        # Используем общий метод для создания шаблона
        return self._create_progress_template(filled_count, empty_count)


class HealthBar(ProgressBar):
    """Прогресс-бар для отображения здоровья (HP)."""

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 20,
        character: Optional['Character'] = None
    ) -> None:
        """
        Инициализация прогресс-бара здоровья.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина прогресс-бара в символах.
            character: Объект персонажа для отслеживания HP.
        """
        super().__init__(x, y, width, character)

    def _get_current_value(self) -> int:
        """Получить текущее значение HP из персонажа."""
        if self.character:
            return getattr(self.character, 'hp', 0)
        return 0

    def _get_max_value(self) -> int:
        """Получить максимальное значение HP из персонажа."""
        if self.character:
            attributes = getattr(self.character, 'attributes', None)
            if attributes:
                # Используем consistent fallback: 1 как минимальное значение
                return max(1, getattr(attributes, 'max_hp', 1))
        # Если персонажа нет или атрибуты не определены, возвращаем 1 как fallback
        return 1

    def _get_fill_color(self) -> Color:
        """Получить цвет заполненной части для HP (зеленый)."""
        if not self.character:
            return Color.GREEN
            
        # Получаем значения для расчета цвета
        current = self._get_current_value()
        max_val = self._get_max_value()
        
        ratio: float = 0
        if max_val > 0:
            ratio = current / max_val
            
        if ratio < 0.25:
            return Color.RED
        elif ratio < 0.5:
            return Color.YELLOW
        else:
            return Color.GREEN

    def _get_empty_color(self) -> Color:
        """Получить цвет пустой части для HP (темно-серый/серый)."""
        return Color.GRAY


class EnergyBar(ProgressBar):
    """Прогресс-бар для отображения энергии (Energy/MP)."""

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 20,
        character: Optional['Character'] = None
    ) -> None:
        """
        Инициализация прогресс-бара энергии.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина прогресс-бара в символах.
            character: Объект персонажа для отслеживания энергии.
        """
        super().__init__(x, y, width, character)

    def _get_current_value(self) -> int:
        """Получить текущее значение энергии из персонажа."""
        if self.character:
            return getattr(self.character, 'energy', 0)
        return 0

    def _get_max_value(self) -> int:
        """Получить максимальное значение энергии из персонажа."""
        if self.character:
            attributes = getattr(self.character, 'attributes', None)
            if attributes:
                # Используем consistent fallback: 0 как минимальное значение (если энергия не используется)
                return max(0, getattr(attributes, 'max_energy', 0))
        # Если персонажа нет или атрибуты не определены, возвращаем 0 как fallback
        return 0

    def _get_fill_color(self) -> Color:
        """Получить цвет заполненной части для энергии (синий)."""
        return Color.BLUE

    def _get_empty_color(self) -> Color:
        """Получить цвет пустой части для энергии (темно-серый/серый)."""
        return Color.GRAY


================================================================================
Файл: game/ui/widgets/character_card.py
================================================================================

# game/ui/widgets/character_card.py
"""Виджет для отображения сводной информации о персонаже.
Содержит имя, уровень, класс/роль, HP и энергию в компактном виде."""

from typing import Optional, TYPE_CHECKING, List

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.widgets.labels import CharacterNameLabel, CharacterLevelLabel, CharacterClassLabel
from game.ui.widgets.bars import HealthBar, EnergyBar

if TYPE_CHECKING:
    from game.entities.character import Character


class CharacterInfoPanel(Renderable):
    """Панель с информацией о персонаже, объединяющая несколько виджетов."""
    
    # Константы для макета
    CLASS_LABEL_X_OFFSET = 0
    NAME_LABEL_X_OFFSET = 5
    LEVEL_LABEL_X_OFFSET = -5  # Отрицательное значение для позиционирования справа
    MIN_NAME_LABEL_WIDTH = 10

    def __init__(
        self,
        x: int = 0,
        y: int = 0,
        width: int = 30,
        height: int = 5,
        character: Optional['Character'] = None,
        show_name: bool = True,
        show_class: bool = True,
        show_level: bool = True,
        show_health_bar: bool = True,
        show_energy_bar: bool = True
    ) -> None:
        """
        Инициализация панели информации о персонаже.

        Args:
            x: Координата X.
            y: Координата Y.
            width: Ширина панели.
            height: Высота панели.
            character: Объект персонажа для отображения.
            show_class: Показывать ли метку класса/роли.
            show_name: Показывать ли метку имени.
            show_level: Показывать ли метку уровня.
            show_health_bar: Показывать ли полосу здоровья.
            show_energy_bar: Показывать ли полосу энергии.
        """
        super().__init__(x, y)
        self.width = width
        self.height = height
        self.character = character
        
        # Флаги отображения компонентов
        self.show_name = show_name
        self.show_class = show_class
        self.show_level = show_level
        self.show_health_bar = show_health_bar
        self.show_energy_bar = show_energy_bar

        # Создаем дочерние виджеты (они могут быть неактивны, если show_* = False)
        self.class_label: Optional[CharacterClassLabel] = None
        self.name_label: Optional[CharacterNameLabel] = None
        self.level_label: Optional[CharacterLevelLabel] = None
        self.health_bar: Optional[HealthBar] = None
        self.energy_bar: Optional[EnergyBar] = None
        
        # Инициализируем виджеты в зависимости от флагов
        self._initialize_widgets()
        
        # Если передан персонаж, устанавливаем его для всех виджетов
        if self.character:
            self.set_character(self.character)

    def _initialize_widgets(self) -> None:
        """Инициализировать дочерние виджеты в зависимости от флагов отображения."""
        if self.show_name:
            self.name_label = CharacterNameLabel(
                x=self.x + self.NAME_LABEL_X_OFFSET, 
                y=self.y, 
                max_width=max(self.MIN_NAME_LABEL_WIDTH, self.width - self.NAME_LABEL_X_OFFSET + self.LEVEL_LABEL_X_OFFSET)
            )

        if self.show_class:
            self.class_label = CharacterClassLabel(x=self.x + self.CLASS_LABEL_X_OFFSET, y=self.y)
            
        if self.show_level:
            self.level_label = CharacterLevelLabel(x=self.x + self.width + self.LEVEL_LABEL_X_OFFSET, y=self.y)
            
        if self.show_health_bar:
            self.health_bar = HealthBar(x=self.x, y=self.y + 1, width=self.width)
            
        if self.show_energy_bar:
            self.energy_bar = EnergyBar(x=self.x, y=self.y + 2, width=self.width)

    def set_character(self, character: Optional['Character']) -> None:
        """
        Установить персонажа для отображения во всех дочерних виджетах.

        Args:
            character: Объект персонажа или None.
        """
        self.character = character
        
        # Устанавливаем персонажа только для активных виджетов
        if self.class_label and self.show_class:
            self.class_label.set_character(character)
        if self.name_label and self.show_name:
            self.name_label.set_character(character)
        if self.level_label and self.show_level:
            self.level_label.set_character(character)
        if self.health_bar and self.show_health_bar:
            self.health_bar.set_character(character)
        if self.energy_bar and self.show_energy_bar:
            self.energy_bar.set_character(character)

    def update_size(self, width: int, height: int) -> None:
        """
        Обновить размеры панели и пересчитать позиции дочерних элементов.

        Args:
            width: Новая ширина панели.
            height: Новая высота панели.
        """
        self.width = width
        self.height = height
        
        # Пересчитываем позиции активных дочерних виджетов
        if self.class_label and self.show_class:
            self.class_label.x = self.x + self.CLASS_LABEL_X_OFFSET
            self.class_label.y = self.y
            
        if self.name_label and self.show_name:
            self.name_label.x = self.x + self.NAME_LABEL_X_OFFSET
            self.name_label.y = self.y
            # Обновляем максимальную ширину имени с учетом новых размеров
            calculated_max_width = self.width - self.NAME_LABEL_X_OFFSET + self.LEVEL_LABEL_X_OFFSET
            self.name_label.max_width = max(self.MIN_NAME_LABEL_WIDTH, calculated_max_width)
            
        if self.level_label and self.show_level:
            self.level_label.x = self.x + self.width + self.LEVEL_LABEL_X_OFFSET  # Позиционируем уровень справа
            self.level_label.y = self.y
            
        if self.health_bar and self.show_health_bar:
            self.health_bar.x = self.x
            self.health_bar.y = self.y + 1
            self.health_bar.width = self.width
            
        if self.energy_bar and self.show_energy_bar:
            self.energy_bar.x = self.x
            self.energy_bar.y = self.y + 2
            self.energy_bar.width = self.width

    def render(self, renderer: Renderer) -> None:
        """
        Отрисовка панели информации о персонаже.
        
        Args:
            renderer: Рендерер для отрисовки.
        """
        # Отрисовываем только активные дочерние виджеты
        renderable_widgets: List[Renderable] = []
        
        if self.class_label and self.show_class:
            renderable_widgets.append(self.class_label)
        if self.name_label and self.show_name:
            renderable_widgets.append(self.name_label)
        if self.level_label and self.show_level:
            renderable_widgets.append(self.level_label)
        if self.health_bar and self.show_health_bar:
            renderable_widgets.append(self.health_bar)
        if self.energy_bar and self.show_energy_bar:
            renderable_widgets.append(self.energy_bar)
            
        # Отрисовываем все активные виджеты
        for widget in renderable_widgets:
            widget.render(renderer)


================================================================================
Файл: tests/__init__.py
================================================================================



================================================================================
Файл: tests/test_command_system.py
================================================================================

# tests/test_command_system.py
"""Тесты для системы команд."""

from typing import Any, Optional
from unittest.mock import MagicMock, patch

from game.ui.command_system.command import Command, CommandRegistry


class CommandTest(Command):
    """Тестовая реализация команды."""

    def __init__(self, name: str = "Test", description: str = "A test command", keys: Optional[list] = None) -> None:
        """
        Инициализация тестовой команды.

        Args:
            name: Название команды.
            description: Описание команды.
            keys: Список клавиш.
        """
        if keys is None:
            keys = ['t']
        super().__init__(name, description, keys)
        self.executed: bool = False
        self.context: Any = None

    def execute(self, context: Any = None) -> None:
        """
        Выполнение тестовой команды.

        Args:
            context: Контекст выполнения.
        """
        self.executed = True
        self.context = context


class CommandWithIntKeyTest(Command):
    """Тестовая реализация команды с целочисленным кодом клавиши."""

    def __init__(self) -> None:
        """Инициализация команды с целочисленным кодом клавиши."""
        # Имитируем ситуацию, когда ключ передан как число
        super().__init__("Int Key Cmd", "Command with int key", [10])  # Enter key code
        self.executed: bool = False

    def execute(self, context: Any = None) -> None:
        """
        Выполнение команды с целочисленным кодом клавиши.

        Args:
            context: Контекст выполнения.
        """
        self.executed = True


def test_command_initialization() -> None:
    """Тест инициализации команды."""
    cmd = CommandTest("MyCmd", "My Description", ['m', 'M'])
    assert cmd.name == "MyCmd"
    assert cmd.description == "My Description"
    assert cmd.keys == ['m', 'M']


def test_command_get_key_codes_case_insensitive() -> None:
    """Тест получения кодов клавиш с учетом регистра."""
    cmd1 = CommandTest("Test1", "Desc", ['a'])  # lowercase
    cmd2 = CommandTest("Test2", "Desc", ['A'])  # uppercase

    assert cmd1.get_key_codes() != cmd2.get_key_codes()
    assert cmd1.get_key_codes() == {ord('a')}  # Проверяем, что это код 'a'


def test_command_registry_register_command() -> None:
    """Тест регистрации команды в реестре."""
    registry = CommandRegistry()
    cmd = CommandTest()

    registry.register_command(cmd)

    assert cmd in registry._commands
    assert ord('t') in registry._key_to_command
    assert registry._key_to_command[ord('t')] == cmd


def test_command_registry_execute_command_success() -> None:
    """Тест успешного выполнения команды из реестра."""
    registry = CommandRegistry()
    cmd = CommandTest()
    registry.register_command(cmd)

    result = registry.execute_command(ord('t'), "test_context")

    assert result is True
    assert cmd.executed is True
    assert cmd.context == "test_context"


def test_command_registry_execute_command_failure() -> None:
    """Тест неуспешного выполнения команды из реестра."""
    registry = CommandRegistry()
    cmd = CommandTest()
    registry.register_command(cmd)

    result = registry.execute_command(ord('x'), "test_context")  # 'x' не зарегистрирован

    assert result is False
    assert cmd.executed is False  # Команда не должна выполниться


def test_command_registry_get_all_commands() -> None:
    """Тест получения всех команд из реестра."""
    registry = CommandRegistry()
    cmd1 = CommandTest("Cmd1", "Desc1", ['1'])
    cmd2 = CommandTest("Cmd2", "Desc2", ['2'])

    registry.register_command(cmd1)
    registry.register_command(cmd2)

    all_commands = registry.get_all_commands()

    assert len(all_commands) == 2
    assert cmd1 in all_commands
    assert cmd2 in all_commands
    # Проверяем, что возвращается копия
    assert all_commands is not registry._commands


def test_command_registry_get_command_by_key() -> None:
    """Тест получения команды по коду клавиши из реестра."""
    registry = CommandRegistry()
    cmd = CommandTest()
    registry.register_command(cmd)

    found_cmd = registry.get_command_by_key(ord('t'))
    not_found_cmd = registry.get_command_by_key(ord('x'))

    assert found_cmd == cmd
    assert not_found_cmd is None


def test_command_with_int_key_in_registry() -> None:
    """Тест работы реестра с командой, имеющей целочисленный код клавиши."""
    # Проверяем, как реестр обрабатывает команды с int ключами
    registry = CommandRegistry()
    cmd = CommandWithIntKeyTest()  # Эта команда в keys имеет [10]

    # Регистрируем команду через реестр, который должен корректно обработать int ключ
    registry.register_command(cmd)

    # Выполняем команду по её int коду
    result = registry.execute_command(10, "context")

    assert result is True
    assert cmd.executed is True


================================================================================
Файл: tests/test_game_manager.py
================================================================================

# tests/test_game_manager.py
"""Тесты для модуля game.game_manager, включая класс GameManager и функцию get_game_manager."""

import pytest
from unittest.mock import patch, MagicMock
from game.game_manager import GameManager, get_game_manager

class TestGameManager:
    """Тесты для класса GameManager."""

    def test_singleton_instance_via_get_game_manager(self) -> None:
        """
        Тест: Функция get_game_manager возвращает один и тот же экземпляр GameManager.
        Проверяет реализацию паттерна Singleton.
        """
        manager1 = get_game_manager()
        manager2 = get_game_manager()
        assert manager1 is manager2

    @patch('game.game_manager.get_config')
    def test_initialization_with_config(self, mock_get_config) -> None:
        """
        Тест: Инициализация GameManager корректно загружает конфигурацию.
        """
        # --- Ключевое исправление: Сброс Singleton перед тестом ---
        GameManager._instance = None

        # Настройка моков
        mock_config_instance = MagicMock()
        mock_get_config.return_value = mock_config_instance

        # Вызов тестируемой функциональности
        manager = get_game_manager()

        # Проверки
        mock_get_config.assert_called_once()

    def test_get_player_group(self) -> None:
        """
        Тест: Метод get_player_group возвращает список игроков.
        """
        manager = get_game_manager()

        # Создание мок-игроков и установка их в менеджер
        mock_player1 = MagicMock()
        mock_player2 = MagicMock()
        manager.player_group = [mock_player1, mock_player2]

        # Вызов тестируемой функциональности
        player_group = manager.get_player_group()

        # Проверки
        assert player_group == [mock_player1, mock_player2]
        assert len(player_group) == 2


================================================================================
Файл: tests/test_template_namer.py
================================================================================

# tests/test_template_namer.py
"""Тесты для генератора имен монстров."""

import os
import json
import pytest
from unittest.mock import patch, mock_open

from game.naming.template_namer import TemplateMonsterNamer

class TestTemplateMonsterNamer:
    """Тесты для класса TemplateMonsterNamer."""

    def test_init_with_default_directory(self):
        """Тест инициализации с директорией по умолчанию."""
        namer = TemplateMonsterNamer()
        assert isinstance(namer, TemplateMonsterNamer)
        # Проверяем, что word_data инициализирован как словарь
        assert isinstance(namer.word_data, dict)

    @patch('os.path.exists')
    @patch('builtins.open')
    def test_load_word_data_io_error(self, mock_file, mock_exists):
        """Тест загрузки данных при ошибке ввода-вывода."""
        mock_exists.return_value = True
        mock_file.side_effect = IOError("File error")
        with patch('builtins.print') as mock_print:
            namer = TemplateMonsterNamer(data_directory="/fake/path")
            mock_print.assert_called()  # Должно быть сообщение об ошибке
        expected_keys = ["adjectives", "nouns", "prefixes", "suffixes"]
        for key in expected_keys:
            assert key in namer.word_data
            assert namer.word_data[key] == []  # Должен быть пустой список

    @patch('os.path.exists')
    @patch('builtins.open')
    def test_load_word_data_json_decode_error(self, mock_file, mock_exists):
        """Тест загрузки данных при ошибке JSON."""
        mock_exists.return_value = True
        mock_file.side_effect = json.JSONDecodeError("Invalid JSON", "doc", 1)
        with patch('builtins.print') as mock_print:
            namer = TemplateMonsterNamer(data_directory="/fake/path")
            mock_print.assert_called()  # Должно быть сообщение об ошибке
        expected_keys = ["adjectives", "nouns", "prefixes", "suffixes"]
        for key in expected_keys:
            assert namer.word_data[key] == []  # Должен быть пустой список

    def test_get_words_existing_category(self):
        """Тест получения слов для существующей категории."""
        namer = TemplateMonsterNamer()
        namer.word_data = {"adjectives": ["страшный", "мощный"]}
        result = namer._get_words("adjectives")
        assert result == ["страшный", "мощный"]

    def test_get_words_non_existing_category(self):
        """Тест получения слов для несуществующей категории."""
        namer = TemplateMonsterNamer()
        namer.word_data = {"adjectives": ["страшный"]}
        result = namer._get_words("nouns")
        assert result == []

    @patch('random.choice')
    def test_generate_name_success(self, mock_random_choice):
        """Тест успешной генерации имени."""
        mock_random_choice.side_effect = lambda x: x[0] if x else ""
        namer = TemplateMonsterNamer()
        namer.word_data = {
            "adjectives": ["страшный"],
            "nouns": ["гоблин"],
            "prefixes": ["супер"],
            "suffixes": ["младший"]
        }
        result = namer.generate_name("goblin")
        # Проверяем, что результат не пустой и содержит ожидаемые слова
        assert "страшный" in result or "гоблин" in result or "супер" in result or "младший" in result
        assert isinstance(result, str)
        assert len(result) > 0

    def test_generate_name_empty_data(self):
        """Тест генерации имени с пустыми данными."""
        namer = TemplateMonsterNamer()
        namer.word_data = {"adjectives": [], "nouns": [], "prefixes": [], "suffixes": []}
        result = namer.generate_name("test_monster")
        # Должно вернуться имя по умолчанию
        assert "Монстр" in result or len(result) > 0

    def test_generate_name_with_various_templates(self):
        """Тест генерации имен с разными шаблонами."""
        namer = TemplateMonsterNamer()
        namer.word_data = {
            "adjectives": ["страшный", "мощный"],
            "nouns": ["гоблин", "дракон"],
            "prefixes": ["супер", "мега"],
            "suffixes": ["младший", "старший"]
        }
        # Тестируем несколько раз для разных результатов
        results = set()
        for i in range(5):
            with patch('random.choice') as mock_choice:
                # Фиксируем выбор для воспроизводимости
                mock_choice.side_effect = lambda x: x[i % len(x)] if x else ""
                result = namer.generate_name("goblin")
                results.add(result)
        # Проверяем, что получаем разные результаты
        assert len(results) >= 1


class TestIntegration:
    """Интеграционные тесты."""

    def test_basic_functionality(self):
        """Тест базовой функциональности."""
        namer = TemplateMonsterNamer()
        assert isinstance(namer.word_data, dict)
        # Даже с пустыми данными должен возвращать имя
        name = namer.generate_name("test_monster")
        assert isinstance(name, str)
        assert len(name) > 0


if __name__ == "__main__":
    pytest.main([__file__])

================================================================================
Файл: tests/test_character.py
================================================================================

# tests/entities/test_character.py
"""Базовые тесты для класса Character."""

from typing import Dict, Any
from unittest.mock import Mock, patch, MagicMock
import pytest

from game.entities.character import Character, SimpleStats, SimpleAttributes, CharacterConfig
from game.results import ActionResult, DamageTakenResult, HealedResult


# ==================== Фикстуры ====================

@pytest.fixture
def character_config() -> CharacterConfig:
    """Фикстура с конфигом для создания персонажа."""
    return CharacterConfig(
        name="TestCharacter",
        role="warrior",
        base_stats={
            'strength': 10,
            'agility': 10,
            'intelligence': 10,
            'vitality': 10
        },
        growth_rates={
            'strength': 1.0,
            'agility': 1.0,
            'intelligence': 1.0,
            'vitality': 1.0
        },
        level=1
    )


@pytest.fixture
def mock_config() -> Mock:
    """Фикстура с моком конфига."""
    config = Mock()
    config.character.base_max_hp = 50
    config.character.hp_per_vitality = 5
    config.character.base_max_energy = 20
    config.character.energy_per_intelligence = 3
    config.character.attack_per_strength = 2
    config.character.defense_per_agility = 1.5
    return config


# ==================== Тесты ====================

class TestCharacterConfig:
    """Тесты для CharacterConfig."""

    def test_character_config_initialization(self, character_config: CharacterConfig):
        """Тест инициализации конфига персонажа."""
        assert character_config.name == "TestCharacter"
        assert character_config.role == "warrior"
        assert character_config.level == 1
        assert character_config.is_player is False
        assert character_config.base_stats['strength'] == 10
        assert character_config.growth_rates['agility'] == 1.0


class TestSimpleStats:
    """Тесты для SimpleStats."""

    def test_simple_stats_initialization(self):
        """Тест инициализации SimpleStats."""
        stats = SimpleStats()
        assert stats.strength == 0
        assert stats.agility == 0
        assert stats.intelligence == 0
        assert stats.vitality == 0

    def test_simple_stats_with_values(self):
        """Тест инициализации SimpleStats с заданными значениями."""
        stats = SimpleStats(strength=15, agility=12, intelligence=8, vitality=20)
        assert stats.strength == 15
        assert stats.agility == 12
        assert stats.intelligence == 8
        assert stats.vitality == 20


class TestSimpleAttributes:
    """Тесты для SimpleAttributes."""

    def test_simple_attributes_initialization(self):
        """Тест инициализации SimpleAttributes."""
        attributes = SimpleAttributes()
        assert attributes.max_hp == 0
        assert attributes.max_energy == 0
        assert attributes.attack_power == 0
        assert attributes.defense == 0

    @patch('game.entities.character.get_config')
    def test_simple_attributes_recalculate(self, mock_get_config, mock_config: Mock):
        """Тест пересчета атрибутов."""
        mock_get_config.return_value = mock_config
        
        stats = SimpleStats()
        stats.strength = 10
        stats.agility = 10
        stats.intelligence = 10
        stats.vitality = 10
        
        attributes = SimpleAttributes()
        attributes.recalculate(stats, mock_config)

        # Проверяем расчеты
        expected_max_hp = 50 + (10 * 5)  # base_max_hp + (vitality * hp_per_vitality)
        expected_max_energy = 20 + (10 * 3)  # base_max_energy + (intelligence * energy_per_intelligence)
        expected_attack_power = 10 * 2  # strength * attack_per_strength
        expected_defense = int(10 * 1.5)  # int(agility * defense_per_agility)

        assert attributes.max_hp == expected_max_hp
        assert attributes.max_energy == expected_max_energy
        assert attributes.attack_power == expected_attack_power
        assert attributes.defense == expected_defense


class TestCharacter:
    """Базовые тесты для Character."""

    @patch('game.entities.character.get_config')
    def test_character_initialization(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест инициализации персонажа."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)

        assert character.name == "TestCharacter"
        assert character.role == "warrior"
        assert character.level == 1
        assert character.is_player is False
        assert character.alive is True
        assert hasattr(character, 'stats')
        assert hasattr(character, 'attributes')
        assert isinstance(character.stats, SimpleStats)
        assert isinstance(character.attributes, SimpleAttributes)

    @patch('game.entities.character.get_config')
    def test_character_initialization_with_factories(self, mock_get_config, mock_config: Mock):
        """Тест инициализации персонажа с кастомными фабриками."""
        mock_get_config.return_value = mock_config
        
        # Создаем кастомные фабрики
        def custom_stats_factory(role, level, base_stats, growth_rates):
            stats = SimpleStats()
            stats.strength = base_stats.get('strength', 0) + 5
            stats.agility = base_stats.get('agility', 0) + 5
            stats.intelligence = base_stats.get('intelligence', 0) + 5
            stats.vitality = base_stats.get('vitality', 0) + 5
            return stats

        def custom_attributes_factory(stats, config_obj):
            attributes = SimpleAttributes()
            attributes.max_hp = 200
            attributes.max_energy = 100
            attributes.attack_power = 50
            attributes.defense = 25
            return attributes

        config = CharacterConfig(
            name="CustomCharacter",
            role="mage",
            base_stats={'strength': 5, 'agility': 5, 'intelligence': 15, 'vitality': 8},
            growth_rates={'strength': 1.0, 'agility': 1.0, 'intelligence': 1.0, 'vitality': 1.0},
            stats_factory=custom_stats_factory,
            attributes_factory=custom_attributes_factory
        )

        character = Character(config)

        assert character.name == "CustomCharacter"
        assert character.stats.strength == 10  # 5 + 5
        assert character.attributes.max_hp == 200

    @patch('game.entities.character.get_config')
    def test_is_alive(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест проверки жив ли персонаж."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
            
        assert character.is_alive() is True
        character.alive = False
        assert character.is_alive() is False

    @patch('game.entities.character.get_config')
    def test_get_level(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест получения уровня персонажа."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
            
        assert character.get_level() == 1
        character.level = 5
        assert character.get_level() == 5

    @patch('game.entities.character.get_config')
    def test_level_up(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест повышения уровня персонажа."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        initial_level = character.level
        initial_max_hp = character.attributes.max_hp

        results = character.level_up()

        assert character.level == initial_level + 1
        assert len(results) == 1
        assert isinstance(results[0], ActionResult)
        assert results[0].type == "level_up"
        # HP и энергия должны быть восстановлены до новых максимумов
        assert character.hp == character.attributes.max_hp
        assert character.energy == character.attributes.max_energy

    @patch('game.entities.character.get_config')
    def test_take_damage(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест получения урона."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.attributes.defense = 4
        character.hp = 100
        initial_hp = character.hp

        # Урон 20, защита 4, фактический урон = max(1, 20 - 4//2) = 18
        results = character.take_damage(20)

        assert len(results) == 1
        assert isinstance(results[0], DamageTakenResult)
        assert results[0].damage == 18
        assert character.hp == initial_hp - 18
        assert character.alive is True

    @patch('game.entities.character.get_config')
    def test_take_damage_death(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест смерти персонажа от урона."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.hp = 5
        character.attributes.defense = 0

        results = character.take_damage(10)

        assert len(results) >= 1
        assert character.hp == 0
        assert character.alive is False
        # Проверяем, что есть результат о смерти
        death_found = False
        for result in results:
            if hasattr(result, 'type') and result.type == "death":
                death_found = True
                break
        assert death_found is True

    @patch('game.entities.character.get_config')
    def test_take_heal(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест исцеления персонажа."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.attributes.max_hp = 100
        character.hp = 50
        initial_hp = character.hp

        results = character.take_heal(30)

        assert len(results) == 1
        assert isinstance(results[0], HealedResult)
        assert results[0].heal_amount == 30
        assert character.hp == initial_hp + 30

    @patch('game.entities.character.get_config')
    def test_take_heal_over_max(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест исцеления выше максимального HP."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.attributes.max_hp = 100
        character.hp = 90

        results = character.take_heal(20)

        assert results[0].heal_amount == 10  # Только 10 до максимума
        assert character.hp == 100

    @patch('game.entities.character.get_config')
    def test_restore_energy(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест восстановления энергии."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.attributes.max_energy = 100
        character.energy = 50
        initial_energy = character.energy

        results = character.restore_energy(amount=30)

        assert len(results) == 1
        assert isinstance(results[0], ActionResult)
        assert results[0].type == "energy_restored"
        assert character.energy == initial_energy + 30

    @patch('game.entities.character.get_config')
    def test_restore_energy_over_max(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест восстановления энергии выше максимального значения."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.attributes.max_energy = 100
        character.energy = 90

        results = character.restore_energy(amount=30)

        assert character.energy == 100  # Не должно превышать максимум

    @patch('game.entities.character.get_config')
    def test_spend_energy_success(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест успешной траты энергии."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.energy = 50

        result = character.spend_energy(20)

        assert result is True
        assert character.energy == 30

    @patch('game.entities.character.get_config')
    def test_spend_energy_fail(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест неудачной траты энергии."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)
        character.energy = 10

        result = character.spend_energy(20)

        assert result is False
        assert character.energy == 10  # Энергия не изменилась

    @patch('game.entities.character.get_config')
    def test_add_ability_without_manager(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест добавления способности без менеджера."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)

        results = character.add_ability("test_ability", Mock())

        assert len(results) == 0  # Нет менеджера, результатов нет

    @patch('game.entities.character.get_config')
    def test_use_ability_without_manager(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест использования способности без менеджера."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)

        results = character.use_ability("test_ability", [])

        assert len(results) == 0  # Нет менеджера, результатов нет

    @patch('game.entities.character.get_config')
    def test_add_status_effect_without_manager(self, mock_get_config, character_config: CharacterConfig, mock_config: Mock):
        """Тест добавления статус-эффекта без менеджера."""
        mock_get_config.return_value = mock_config
        
        character = Character(character_config)

        results = character.add_status_effect(Mock())

        assert len(results) == 0  # Нет менеджера, результатов нет

================================================================================
Файл: tests/test_ui/test_widgets.py
================================================================================

# tests/test_ui/test_widgets.py
"""Тесты для UI виджетов."""

from typing import Any, Dict, List
from unittest.mock import Mock, patch, MagicMock

import pytest

from game.ui.rendering.renderer import Renderer
from game.ui.widgets.labels import (
    TextLabel, CharacterNameLabel, CharacterClassLabel, CharacterLevelLabel
)
from game.ui.widgets.bars import ProgressBar, HealthBar, EnergyBar
from game.ui.widgets.character_card import CharacterInfoPanel


# ==================== Фикстуры ====================

@pytest.fixture
def mock_renderer() -> Mock:
    """Фикстура для создания мок-рендерера."""
    return Mock(spec=Renderer)


@pytest.fixture
def mock_character() -> Mock:
    """Фикстура для создания мок-персонажа."""
    character = Mock()
    character.name = "Test Character"
    character.role = "warrior"
    character.level = 5
    character.class_icon = "W"
    character.class_icon_color = "CYAN"  # Используем строковое значение цвета
    return character


@pytest.fixture
def mock_player_with_class() -> Mock:
    """Фикстура для создания мок-игрока с классом."""
    player = Mock()
    player.name = "Test Player"
    player.role = "player"
    player.level = 3
    player.class_name = "Warrior"
    player.class_icon = "P"
    player.class_icon_color = "BLUE"  # Используем строковое значение цвета
    return player


# ==================== Тесты TextLabel ====================

class TestTextLabel:
    """Тесты для TextLabel."""

    def test_initialization(self, mock_renderer: Mock) -> None:
        """Тест инициализации TextLabel."""
        label = TextLabel(x=1, y=2, text="Test")
        assert label.x == 1
        assert label.y == 2
        assert label.text == "Test"

    def test_render(self, mock_renderer: Mock) -> None:
        """Тест отрисовки TextLabel."""
        label = TextLabel(x=3, y=4, text="Render Test")
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Render Test", 3, 4)


# ==================== Тесты CharacterNameLabel ====================

class TestCharacterNameLabel:
    """Тесты для CharacterNameLabel."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации CharacterNameLabel."""
        label = CharacterNameLabel(x=0, y=0, character=mock_character)
        assert label.x == 0
        assert label.y == 0
        assert label.character == mock_character
        assert label.text == "Test Character"

    def test_set_character(self, mock_character: Mock) -> None:
        """Тест установки персонажа."""
        label = CharacterNameLabel(x=0, y=0, character=mock_character)
        # Создаем нового мок-персонажа
        new_character = Mock()
        new_character.name = "New Character"
        label.character = new_character
        assert label.character == new_character
        assert label.text == "New Character"

    def test_render_with_character(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки с персонажем."""
        label = CharacterNameLabel(x=1, y=1, character=mock_character)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Test Character", 1, 1)

    def test_render_no_character(self, mock_renderer: Mock) -> None:
        """Тест отрисовки без персонажа."""
        # Создаем мок-персонажа как None
        label = CharacterNameLabel(x=3, y=3, character=None)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Unknown", 3, 3)


# ==================== Тесты CharacterClassLabel ====================

class TestCharacterClassLabel:
    """Тесты для CharacterClassLabel."""

    def test_initialization_with_role(self, mock_character: Mock) -> None:
        """Тест инициализации с ролью."""
        label = CharacterClassLabel(x=1, y=1, character=mock_character)
        assert label.x == 1
        assert label.y == 1
        assert label.character == mock_character
        assert label.text == "[W]"

    def test_render_with_role(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки с ролью."""
        label = CharacterClassLabel(x=4, y=4, character=mock_character)
        label.render(mock_renderer)
        # Проверяем, что draw_text был вызван с правильными аргументами
        # Мы не можем точно проверить цвет, так как он преобразуется в enum
        mock_renderer.draw_text.assert_called_once()
        args, kwargs = mock_renderer.draw_text.call_args
        assert args[0] == "[W]"  # text
        assert args[1] == 4      # x
        assert args[2] == 4      # y

    def test_render_with_player_class(self, mock_renderer: Mock, mock_player_with_class: Mock) -> None:
        """Тест отрисовки с классом игрока."""
        label = CharacterClassLabel(x=5, y=5, character=mock_player_with_class)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once()
        args, kwargs = mock_renderer.draw_text.call_args
        assert args[0] == "[P]"  # text
        assert args[1] == 5      # x
        assert args[2] == 5      # y

    def test_render_no_character(self, mock_renderer: Mock) -> None:
        """Тест отрисовки без персонажа."""
        label = CharacterClassLabel(x=6, y=6, character=None)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("[?]", 6, 6)


# ==================== Тесты CharacterLevelLabel ====================

class TestCharacterLevelLabel:
    """Тесты для CharacterLevelLabel."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации CharacterLevelLabel."""
        label = CharacterLevelLabel(x=2, y=2, character=mock_character)
        assert label.x == 2
        assert label.y == 2
        assert label.character == mock_character
        assert label.text == "Lvl: 5"

    def test_render_with_character(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки с персонажем."""
        label = CharacterLevelLabel(x=7, y=7, character=mock_character)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Lvl: 5", 7, 7)

    def test_render_no_character(self, mock_renderer: Mock) -> None:
        """Тест отрисовки без персонажа."""
        label = CharacterLevelLabel(x=8, y=8, character=None)
        label.render(mock_renderer)
        mock_renderer.draw_text.assert_called_once_with("Lvl: ?", 8, 8)


# ==================== Тесты ProgressBar ====================

class TestProgressBar:
    """Тесты для ProgressBar."""

    def test_initialization(self) -> None:
        """Тест инициализации ProgressBar."""
        bar = ProgressBar(x=0, y=0, width=10, current=50, maximum=100)
        assert bar.x == 0
        assert bar.y == 0
        assert bar.width == 10
        assert bar.current == 50
        assert bar.maximum == 100

    def test_render(self, mock_renderer: Mock) -> None:
        """Тест отрисовки ProgressBar."""
        bar = ProgressBar(x=1, y=1, width=20, current=30, maximum=100)
        bar.render(mock_renderer)
        # Проверяем, что draw_template был вызван
        mock_renderer.draw_template.assert_called_once()


# ==================== Тесты HealthBar ====================

class TestHealthBar:
    """Тесты для HealthBar."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации HealthBar."""
        # Настраиваем мок персонажа для HealthBar
        mock_character.hp = 75
        mock_character.attributes.max_hp = 100
        
        bar = HealthBar(x=0, y=0, width=10, character=mock_character)
        assert bar.x == 0
        assert bar.y == 0
        assert bar.width == 10
        assert bar.character == mock_character
        assert bar.current == 75
        assert bar.maximum == 100

    def test_update_values(self, mock_character: Mock) -> None:
        """Тест обновления значений HealthBar."""
        # Настраиваем мок персонажа для HealthBar
        mock_character.hp = 75
        mock_character.attributes.max_hp = 100
        
        bar = HealthBar(x=1, y=1, width=15, character=mock_character)
        assert bar.current == 75
        assert bar.maximum == 100
        
        # Обновляем значения персонажа
        mock_character.hp = 50
        mock_character.attributes.max_hp = 150
        bar._update_values()
        assert bar.current == 50
        assert bar.maximum == 150

    def test_render(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки HealthBar."""
        # Настраиваем мок персонажа для HealthBar
        mock_character.hp = 60
        mock_character.attributes.max_hp = 100
        
        bar = HealthBar(x=2, y=2, width=20, character=mock_character)
        bar.render(mock_renderer)
        mock_renderer.draw_template.assert_called_once()


# ==================== Тесты EnergyBar ====================

class TestEnergyBar:
    """Тесты для EnergyBar."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации EnergyBar."""
        # Настраиваем мок персонажа для EnergyBar
        mock_character.energy = 40
        mock_character.attributes.max_energy = 80
        
        bar = EnergyBar(x=0, y=0, width=10, character=mock_character)
        assert bar.x == 0
        assert bar.y == 0
        assert bar.width == 10
        assert bar.character == mock_character
        assert bar.current == 40
        assert bar.maximum == 80

    def test_update_values(self, mock_character: Mock) -> None:
        """Тест обновления значений EnergyBar."""
        # Настраиваем мок персонажа для EnergyBar
        mock_character.energy = 40
        mock_character.attributes.max_energy = 80
        
        bar = EnergyBar(x=1, y=1, width=15, character=mock_character)
        assert bar.current == 40
        assert bar.maximum == 80
        
        # Обновляем значения персонажа
        mock_character.energy = 60
        mock_character.attributes.max_energy = 100
        bar._update_values()
        assert bar.current == 60
        assert bar.maximum == 100

    def test_render(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки EnergyBar."""
        # Настраиваем мок персонажа для EnergyBar
        mock_character.energy = 30
        mock_character.attributes.max_energy = 100
        
        bar = EnergyBar(x=2, y=2, width=20, character=mock_character)
        bar.render(mock_renderer)
        mock_renderer.draw_template.assert_called_once()


# ==================== Тесты CharacterInfoPanel ====================

class TestCharacterInfoPanel:
    """Тесты для CharacterInfoPanel."""

    def test_initialization(self, mock_character: Mock) -> None:
        """Тест инициализации CharacterInfoPanel."""
        panel = CharacterInfoPanel(x=1, y=1, width=30, height=5, character=mock_character)
        assert panel.x == 1
        assert panel.y == 1
        assert panel.width == 30
        assert panel.height == 5
        assert panel.character == mock_character

    def test_set_character(self, mock_character: Mock) -> None:
        """Тест установки персонажа."""
        panel = CharacterInfoPanel(x=0, y=0, width=20, height=3, character=mock_character)
        # Создаем нового мок-персонажа
        new_character = Mock()
        new_character.name = "New Character"
        new_character.role = "mage"
        new_character.level = 2
        new_character.class_icon = "M"
        new_character.class_icon_color = "MAGENTA"
        new_character.hp = 60
        new_character.attributes.max_hp = 80
        new_character.energy = 40
        new_character.attributes.max_energy = 60
        
        panel.character = new_character
        assert panel.character == new_character

    def test_render(self, mock_renderer: Mock, mock_character: Mock) -> None:
        """Тест отрисовки панели."""
        # Настраиваем мок персонажа
        mock_character.hp = 80
        mock_character.attributes.max_hp = 100
        mock_character.energy = 50
        mock_character.attributes.max_energy = 100
        
        panel = CharacterInfoPanel(x=5, y=5, width=25, height=4, character=mock_character)
        panel.render(mock_renderer)
        # Проверяем, что render был вызван хотя бы один раз (для дочерних элементов)
        assert mock_renderer.draw_text.call_count >= 1 or mock_renderer.draw_template.call_count >= 1

    def test_update_size(self) -> None:
        """Тест обновления размеров панели."""
        # Создаем мок-персонажа
        mock_character = Mock()
        mock_character.name = "Resize Test"
        mock_character.role = "archer"
        mock_character.level = 4
        mock_character.class_icon = "A"
        mock_character.class_icon_color = "GREEN"
        mock_character.hp = 70
        mock_character.attributes.max_hp = 90
        mock_character.energy = 60
        mock_character.attributes.max_energy = 80
        
        panel = CharacterInfoPanel(x=0, y=0, width=20, height=3, character=mock_character)
        original_width = panel.width
        original_height = panel.height
        
        panel.update_size(30, 6)
        assert panel.width == 30
        assert panel.height == 6

================================================================================
Файл: tests/test_ui/test_base_screen.py
================================================================================

# tests/test_ui/test_base_screen.py
"""Тесты для game/ui/base_screen.py"""

import unittest
from unittest.mock import Mock, patch, MagicMock, call
import curses

# Импортируем тестируемый класс
# Поскольку BaseScreen абстрактный, мы создадим фиктивный подкласс для тестирования
from game.ui.base_screen import BaseScreen


class TestBaseScreen(unittest.TestCase):
    """Тесты для базового класса экрана."""

    def setUp(self) -> None:
        """Настройка тестового окружения перед каждым тестом."""
        # Мокаем зависимости
        self.mock_screen_manager = Mock()
        self.mock_renderer = Mock()
        # Явно мокаем методы clear и refresh у renderer
        self.mock_renderer.clear = Mock()
        self.mock_renderer.refresh = Mock()
        self.mock_screen_manager.renderer = self.mock_renderer

        # Мокаем функцию получения команд
        patcher_get_screen_commands = patch('game.ui.base_screen.get_screen_commands')
        self.mock_get_screen_commands = patcher_get_screen_commands.start()
        self.addCleanup(patcher_get_screen_commands.stop)

        # Мокаем класс CommandRegistry
        patcher_command_registry_class = patch('game.ui.base_screen.CommandRegistry')
        self.mock_command_registry_class = patcher_command_registry_class.start()
        self.addCleanup(patcher_command_registry_class.stop)

        # Создаем мок для экземпляра CommandRegistry
        self.mock_command_registry_instance = Mock()
        self.mock_command_registry_class.return_value = self.mock_command_registry_instance

        # Создаем фиктивный подкласс, чтобы обойти абстрактность BaseScreen
        # Это нужно только для вызова __init__
        class ConcreteBaseScreen(BaseScreen):
            def _setup_elements(self) -> None:
                pass # Реализация для обхода абстрактности
            
            def _setup_commands(self) -> None:
                pass # Реализация для обхода абстрактности

        self.ConcreteBaseScreen = ConcreteBaseScreen

    def test_init_initializes_attributes(self) -> None:
        """Тест инициализации атрибутов в __init__."""
        # Настройка моков
        mock_commands = [Mock(), Mock()]
        self.mock_get_screen_commands.return_value = mock_commands

        # Создание экземпляра
        screen = self.ConcreteBaseScreen(self.mock_screen_manager)

        # Проверки
        self.assertEqual(screen.manager, self.mock_screen_manager)
        self.assertEqual(screen.renderer, self.mock_renderer)
        self.mock_command_registry_class.assert_called_once()
        self.assertEqual(screen.command_registry, self.mock_command_registry_instance)
        # Проверяем, что get_screen_commands был вызван с правильным классом
        self.mock_get_screen_commands.assert_called_once_with(self.ConcreteBaseScreen)
        # Проверяем, что команды были зарегистрированы
        # Команды регистрируются через register_command
        expected_calls = [call(cmd) for cmd in mock_commands]
        self.mock_command_registry_instance.register_command.assert_has_calls(expected_calls, any_order=False)
        self.assertEqual(screen.elements, [])

    def test_handle_input_with_registered_command(self) -> None:
        """Тест handle_input при нажатии клавиши с зарегистрированной командой."""
        # Создание экземпляра
        screen = self.ConcreteBaseScreen(self.mock_screen_manager)

        # Настройка моков после создания экземпляра
        mock_command = Mock()
        # Мокаем execute_command так, чтобы он возвращал True
        screen.command_registry.execute_command = Mock(return_value=True)
        mock_key = 97 # ord('a')

        # Вызов тестируемого метода
        screen.handle_input(mock_key)

        # Проверки
        screen.command_registry.execute_command.assert_called_once_with(mock_key, screen)

    def test_handle_input_with_unregistered_command(self) -> None:
        """Тест handle_input при нажатии клавиши без зарегистрированной команды."""
        # Создание экземпляра
        screen = self.ConcreteBaseScreen(self.mock_screen_manager)

        # Настройка моков после создания экземпляра
        # Мокаем execute_command так, чтобы он возвращал False
        screen.command_registry.execute_command = Mock(return_value=False)
        mock_key = 98 # ord('b')
        
        # Заменяем _handle_unregistered_key на мок
        screen._handle_unregistered_key = Mock() # type: ignore[method-assign]

        # Вызов тестируемого метода
        screen.handle_input(mock_key)

        # Проверки
        screen.command_registry.execute_command.assert_called_once_with(mock_key, screen)
        screen._handle_unregistered_key.assert_called_once_with(mock_key) # type: ignore[attr-defined]

    # def test_render_draws_elements_and_refreshes(self) -> None:
    #     """Тест отрисовки экрана."""
    #     # Создание экземпляра
    #     screen = self.ConcreteBaseScreen(self.mock_screen_manager)
    #
    #     # Настройка элементов для отрисовки
    #     mock_element1 = Mock()
    #     mock_element2 = Mock()
    #     screen.elements = [mock_element1, mock_element2]
    #
    #     # Создаем мок stdscr
    #     mock_stdscr = Mock()
    #
    #     # Вызов тестируемого метода
    #     screen.render(mock_stdscr)
    #
    #     # Проверки
    #     self.mock_renderer.clear.assert_called_once()
    #     # Проверяем, что render был вызван на каждом элементе с renderer
    #     mock_element1.render.assert_called_once_with(self.mock_renderer)
    #     mock_element2.render.assert_called_once_with(self.mock_renderer)
    #     # Проверяем, что refresh был вызван у renderer
    #     self.mock_renderer.refresh.assert_called_once()


if __name__ == '__main__':
    unittest.main()

================================================================================
Файл: main.py
================================================================================

# main.py
"""Главная точка входа в игру."""

import curses
import sys
import traceback

from game.ui import ScreenManager
from game.game_manager import get_game_manager

# ВАЖНО: Импортируем команды, чтобы они зарегистрировались
import game.ui.commands.inventory_commands
import game.ui.commands.battle_commands
import game.ui.commands.main_screen_commands


def main(stdscr: curses.window) -> None:
    """Главная функция curses приложения."""
    try:
        # Настройка curses
        curses.curs_set(0)  # Скрыть курсор
        stdscr.keypad(True)  # Включить обработку специальных клавиш
        
        # Инициализация игрового состояния
        game_manager = get_game_manager()
        
        # Инициализация менеджера экранов
        manager = ScreenManager(stdscr, game_manager)
        manager.run()
        
    except KeyboardInterrupt:
        # Корректный выход по Ctrl+C
        pass
    except Exception as e:
        # Обработка критических ошибок
        curses.endwin()
        print(f"Критическая ошибка: {e}")
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    curses.wrapper(main)

================================================================================
Файл: guide/style_guide.md
================================================================================

# Руководство по стилю кода проекта Battler

Этот документ описывает принятые стандарты кодирования для проекта Battler. Следование этим правилам помогает обеспечить согласованность, читаемость и поддерживаемость кода.

## 1. Общие принципы

* **Язык:** Весь код, комментарии и docstrings пишутся на русском языке.
* **PEP 8:** Соблюдаем рекомендации [PEP 8](https://peps.python.org/pep-0008/) по оформлению кода Python.
* **Аннотации типов:** Используем аннотации типов (`typing`) для всех параметров функций, методов и возвращаемых значений.
* **Именование:**
  * Переменные, функции, методы: `snake_case`.
  * Классы: `PascalCase`.
  * Константы: `UPPER_CASE_WITH_UNDERSCORES`.
* **Пустые строки:** Используем пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
* **Константы:** Именуем константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.
* Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.

## 2. Структура файла

Файлы должны следовать этой структуре сверху вниз:

1. **Комментарий модуля (Docstring):** Первая строка файла. Подробно описывает назначение модуля.
2. **Импорты:**
   * Стандартная библиотека (например, `os`, `json`, `typing`).
   * Сторонние библиотеки (например, `curses`, `dataclasses`).
   * Локальные импорты (например, `from game.protocols import ...`).
   * Импорты внутри `if TYPE_CHECKING:` располагаются после основных импортов.
3. **Константы модуля:** Если используются.
4. **Классы и функции:** Основное содержимое модуля.

## 3. Комментарии и Docstrings

* **Язык:** Все комментарии и docstrings на русском языке.
* **Docstrings:** Используем docstrings для всех модулей, классов, функций и методов.
* **Стиль:** Docstring следует стилю Google, описывая `Args` для каждого параметра конструктора.
* При длинных списках параметров допускается перенос аргументов `__init__` на новые строки с выравниванием.

## 4. Функции и методы

* **Именование:** Использовать `snake_case`.
* **Docstrings:** Все публичные (не начинающиеся с `_`) функции и методы должны иметь docstring в стиле Google.
* **Аннотации типов:** Использовать аннотации типов для всех параметров и возвращаемых значений (см. `typing`).
* **Длина:** Функции и методы должны быть компактными и выполнять одну задачу. Избегать чрезмерной длины.

## 5. Классы

* **Именование:** Использовать `PascalCase`.
* **Docstrings:** Классы должны иметь docstring, описывающий их назначение и основные атрибуты/методы.
* **Атрибуты:** Атрибуты класса, если не очевидны из контекста, должны быть задокументированы в docstring класса или аннотированы типами.
* **Методы:** См. раздел "Функции и методы".

## 6. Обработка ошибок

* **Исключения:** Использовать встроенные исключения Python (`ValueError`, `TypeError`, `FileNotFoundError` и т.д.) при возможности. Создавать собственные исключения только при необходимости.
* **Блоки try/except:** Использовать для обработки ожидаемых ошибок. Не подавлять исключения без логгирования или обработки.
* **finally:** Использовать для кода, который должен выполниться в любом случае (например, закрытие файлов).

Пример обработки ошибок:

```python
try:
    with open("config.json", 'r', encoding='utf-8') as f:
        data = json.load(f)
    # ... обработка данных ...
except FileNotFoundError:
    # Обработка отсутствия файла
    print("Файл конфигурации не найден, используются значения по умолчанию.")
    data = {}
except json.JSONDecodeError as e:
    # Обработка ошибки парсинга JSON
    print(f"Ошибка чтения конфигурации: Некорректный JSON. {e}")
    data = {}
except Exception as e:
    # Логирование или обработка других исключений
    # Пока просто выходим
    print(f"Критическая ошибка: {e}")
    exit()
```
## 7. Написание тестов

Тесты обеспечивают надежность и корректность кода. Для проекта Battler установлены следующие правила написания тестов с использованием `pytest`:

* **Фреймворк:** Использовать `pytest` для написания тестов. Все тесты должны находиться в директории `tests/`. Тесты должны быть простыми - и выдавать максимальное покрытие
* **Структура файлов тестов:**
  * Файлы тестов должны называться `test_<имя_модуля>.py`, где `<имя_модуля>` соответствует тестируемому файлу в основном коде (например, тесты для `game/entities/character.py` находятся в `tests/test_character.py`).
  * Внутри файлов тестов классы тестов именуются как `Test<ИмяКласса>` или `Test<ОписаниеФункционала>`.
  * Отдельные тестовые методы именуются как `test_<описание_теста>`.
* **Покрытие:**
  * Стремиться к высокому покрытию кода тестами, особенно для бизнес-логики.
  * Тестировать как нормальные сценарии, так и граничные условия и возможные ошибки.
* **Читаемость тестов:**
  * Тесты должны быть легко читаемыми и понятными.
  * Использовать понятные имена для переменных внутри тестов.
  * Комментарии в тестах допустимы для пояснения сложных сценариев подготовки данных.
* **Фикстуры:**
  * Использовать фикстуры `pytest` (`@pytest.fixture`) для подготовки и очистки общих ресурсов, объектов или данных, используемых в нескольких тестах.
  * Использовать декоратор `@pytest.mark.parametrize` для запуска одного и того же теста с разными наборами входных данных и ожидаемых результатов.
* **Маркировка тестов:**
  * Использовать марки (`@pytest.mark.slow`, `@pytest.mark.integration`) для классификации тестов и возможности выборочного запуска.
* **Docstrings для тестов:** Docstrings для тестов не обязательны, но могут быть полезны для сложных сценариев. Если используются, следовать стилю Google.

## 8. Прочее

* **Отступы:** 4 пробела.
* **Пробелы:** Следовать PEP 8 (пробелы вокруг операторов, после запятых и т.д.).
* **Пустые строки:** Использовать пустые строки для разделения логических блоков внутри функций/методов и между определениями классов/функций.
* **Константы:** Именовать константы модуля и класса в `UPPER_CASE_WITH_UNDERSCORES`.
* Этот стиль будет применяться ко всем файлам проекта для обеспечения согласованности.
* Не допускать магических чисел. Магические числа должны быть на именованные константы.

## 9. Принципы проектирования

* **SOLID и DRY:**
  * Следовать принципам [SOLID] для объектно-ориентированного проектирования.
    * **S** - Принцип единственной ответственности (Single Responsibility Principle).
    * **O** - Принцип открытости/закрытости (Open/Closed Principle).
    * **L** - Принцип подстановки Барбары Лисков (Liskov Substitution Principle).
    * **I** - Принцип разделения интерфейса (Interface Segregation Principle).
    * **D** - Принцип инверсии зависимостей (Dependency Inversion Principle).
  * Следовать принципу [DRY] (Don't Repeat Yourself) - избегать дублирования кода. Повторяющуюся логику следует выносить в функции, классы или модули.

* **KISS и YAGNI:**

  * Следовать принципу KISS  (Keep It Simple, Stupid) - стремиться к максимально простым решениям. Код должен быть понятен другим разработчикам без необходимости вникать в сложные абстракции.
  * Следовать принципу YAGNI  (You Aren't Gonna Need It) - реализовывать функциональность только тогда, когда она действительно нужна, а не потому, что "вдруг пригодится".

## 10. Рабочий процесс

* **Работа с TODO:**
  * **Перед началом работы:** Всегда уточнять, над какой конкретной задачей вы работаете.
  * **Поиск задачи:** Найти эту задачу в файле `PROJECT_TODO.md` в корне проекта.
  * **Если задачи нет:** Добавить новую задачу в секцию `## TODO` файла `PROJECT_TODO.md`, используя формат `<!-- TODO: Краткое описание задачи. -->`.
  * **Если задача есть:** Перед началом работы изменить тег задачи с `TODO` на `WIP` (Work In Progress) в файле `PROJECT_TODO.md`.
  * **После завершения:** Изменить тег задачи с `WIP` (или `TODO`, если забыли поменять) на `DONE` в файле `PROJECT_TODO.md`.

