/home/zumik/Documents/Battler_0.3/main.py
# main.py

import curses
from game.ui.screen_manager import ScreenManager
# ВАЖНО: Импортируем команды, чтобы они зарегистрировались
import game.ui.commands.inventory_commands
import game.ui.commands.battle_commands
import game.ui.commands.main_screen_commands


def main(stdscr: curses.window) -> None:
    curses.curs_set(0)  # Скрыть курсор
    manager = ScreenManager(stdscr)
    manager.run()


if __name__ == "__main__":
    curses.wrapper(main)

================================================================================

/home/zumik/Documents/Battler_0.3/tests/__init__.py

================================================================================

/home/zumik/Documents/Battler_0.3/tests/test_command_system.py
# tests/test_command_system.py
import curses
import pytest
from unittest.mock import MagicMock, patch
from game.ui.command_system.command import Command, CommandRegistry
from game.ui.base_screen import BaseScreen
from game.ui.screen_manager import ScreenManager

# Тестовая команда
class TestCommand(Command):
    def __init__(self, name="Test", description="A test command", keys=None):
        if keys is None:
            keys = ['t']
        super().__init__(name, description, keys)
        self.executed = False
        self.context = None

    def execute(self, context=None):
        self.executed = True
        self.context = context

class TestCommandWithIntKey(Command):
    def __init__(self):
        # Имитируем ситуацию, когда ключ передан как число
        super().__init__("Int Key Cmd", "Command with int key", [10]) # Enter key code
        self.executed = False

    def execute(self, context=None):
        self.executed = True


def test_command_initialization():
    cmd = TestCommand("MyCmd", "My Description", ['m', 'M'])
    assert cmd.name == "MyCmd"
    assert cmd.description == "My Description"
    assert cmd.keys == ['m', 'M']


def test_command_get_key_codes_case_insensitive():
    cmd1 = TestCommand("Test1", "Desc", ['a']) # lowercase
    cmd2 = TestCommand("Test2", "Desc", ['A']) # uppercase
    
    assert cmd1.get_key_codes() != cmd2.get_key_codes()
    assert cmd1.get_key_codes() == {ord('a')} # Проверяем, что это код 'a'


def test_command_registry_register_command():
    registry = CommandRegistry()
    cmd = TestCommand()
    
    registry.register_command(cmd)
    
    assert cmd in registry._commands
    assert ord('t') in registry._key_to_command
    assert registry._key_to_command[ord('t')] == cmd


def test_command_registry_execute_command_success():
    registry = CommandRegistry()
    cmd = TestCommand()
    registry.register_command(cmd)
    
    result = registry.execute_command(ord('t'), "test_context")
    
    assert result is True
    assert cmd.executed is True
    assert cmd.context == "test_context"


def test_command_registry_execute_command_failure():
    registry = CommandRegistry()
    cmd = TestCommand()
    registry.register_command(cmd)
    
    result = registry.execute_command(ord('x'), "test_context") # 'x' не зарегистрирован
    
    assert result is False
    assert cmd.executed is False # Команда не должна выполниться


def test_command_registry_get_all_commands():
    registry = CommandRegistry()
    cmd1 = TestCommand("Cmd1", "Desc1", ['1'])
    cmd2 = TestCommand("Cmd2", "Desc2", ['2'])
    
    registry.register_command(cmd1)
    registry.register_command(cmd2)
    
    all_commands = registry.get_all_commands()
    
    assert len(all_commands) == 2
    assert cmd1 in all_commands
    assert cmd2 in all_commands
    # Проверяем, что возвращается копия
    assert all_commands is not registry._commands


def test_command_registry_get_command_by_key():
    registry = CommandRegistry()
    cmd = TestCommand()
    registry.register_command(cmd)
    
    found_cmd = registry.get_command_by_key(ord('t'))
    not_found_cmd = registry.get_command_by_key(ord('x'))
    
    assert found_cmd == cmd
    assert not_found_cmd is None


def test_command_with_int_key_in_registry():
    # Проверяем, как реестр обрабатывает команды, если get_key_codes вернул int напрямую
    # (Это тест для случая, если бы get_key_codes возвращал int, но в текущей реализации так не бывает)
    # Но мы можем проверить, что реестр работает с int ключами
    registry = CommandRegistry()
    cmd = TestCommandWithIntKey() # Эта команда в keys имеет [10]
    
    # Мы должны убедиться, что get_key_codes правильно обрабатывает это
    # Но в текущей реализации Command.__init__ требует List[str]
    # Так что этот тест скорее гипотетический, если бы тип был Union[str, int]
    
    # Для текущей реализации, если мы хотим протестировать с int кодом,
    # мы можем напрямую добавить его в реестр
    registry._key_to_command[10] = cmd
    registry._commands.append(cmd)
    
    result = registry.execute_command(10, "context")
    
    assert result is True
    assert cmd.executed is True


================================================================================

/home/zumik/Documents/Battler_0.3/tests/test_player_system.py
# tests/test_player_system.py
"""
Тесты для системы персонажей и загрузки данных из JSON.
"""

import pytest
import os
from game.data.character_loader import create_player, load_player_class_data
from game.entities.player import Player, create_player_from_data


def test_load_player_class_data_existing():
    """Тест загрузки существующих данных класса."""
    # Тестируем загрузку данных Берсерка
    data = load_player_class_data("berserker")
    assert data is not None
    assert data["role"] == "berserker"
    assert data["name"] == "Берсерк"
    assert "strength" in data["base_stats"]
    assert "strength" in data["growth_rates"]

    # Тестируем загрузку данных Мага
    data = load_player_class_data("mage")
    assert data is not None
    assert data["role"] == "mage"
    assert data["name"] == "Маг"
    assert "intelligence" in data["base_stats"]
    assert "intelligence" in data["growth_rates"]


def test_load_player_class_data_nonexistent():
    """Тест загрузки несуществующих данных класса."""
    # Тестируем загрузку несуществующего класса
    data = load_player_class_data("nonexistent_class")
    assert data is None


def test_create_player_from_data_valid():
    """Тест создания игрока из корректных данных."""
    player = create_player_from_data("Тестовый Герой", "berserker", level=1)
    assert player is not None
    assert isinstance(player, Player)
    assert player.name == "Тестовый Герой"
    assert player.role == "berserker"
    assert player.level == 1
    # Проверяем, что характеристики загружены
    assert "strength" in player.base_stats_dict
    assert "strength" in player.growth_rates_dict


def test_create_player_from_data_invalid_role():
    """Тест создания игрока с некорректной ролью."""
    player = create_player_from_data("Тестовый Герой", "invalid_role", level=1)
    assert player is None


def test_create_player_loader_function():
    """Тест фабричной функции create_player из character_loader."""
    player = create_player("Тестовый Маг", "mage", level=5)
    assert player is not None
    assert isinstance(player, Player)
    assert player.name == "Тестовый Маг"
    assert player.role == "mage"
    assert player.level == 5


def test_player_level_up():
    """Тест повышения уровня игрока."""
    player = create_player_from_data("Тест", "berserker", level=1)
    assert player is not None
    
    initial_level = player.level
    initial_max_hp = player.attributes.max_hp
    initial_max_energy = player.attributes.max_energy
    initial_exp = player.exp
    initial_exp_to_next = player.exp_to_next_level

    # Добавляем достаточно опыта для повышения уровня
    results = player.add_exp(initial_exp_to_next + 10)

    # Проверяем, что уровень повысился
    assert player.level == initial_level + 1
    # Проверяем, что HP и энергия восстановились (в стандартном обработчике)
    assert player.hp == player.attributes.max_hp
    assert player.energy == player.attributes.max_energy
    # Проверяем, что характеристики пересчитались (косвенно через HP/энергию)
    assert player.attributes.max_hp >= initial_max_hp
    assert player.attributes.max_energy >= initial_max_energy
    # Проверяем, что опыт обновился
    assert player.exp == 10 # Остаток после повышения
    assert player.exp_to_next_level > initial_exp_to_next # Следующий уровень требует больше опыта

    # Проверяем результаты
    level_up_messages = [r for r in results if r.get("type") == "level_up"]
    heal_messages = [r for r in results if r.get("type") == "level_up_heal"]
    assert len(level_up_messages) == 1
    assert len(heal_messages) == 1


def test_player_exp_progress():
    """Тест расчета прогресса до следующего уровня."""
    player = create_player_from_data("Тест", "mage", level=1)
    assert player is not None

    # Начальный прогресс должен быть 0%
    progress = player.get_exp_progress()
    assert progress == 0

    # Добавляем половину опыта до следующего уровня
    exp_for_next = player.exp_to_next_level
    player.add_exp(exp_for_next // 2)
    progress = player.get_exp_progress()
    # Проверяем, что прогресс примерно 50% (с точностью до 1%)
    assert 49 <= progress <= 51

    # Добавляем еще немного, чтобы быть ближе к 100%
    player.add_exp(exp_for_next // 2 - 1)
    progress = player.get_exp_progress()
    # Прогресс должен быть 99%
    assert progress == 99

    # Добавляем последний пункт опыта для повышения уровня
    results = player.add_exp(1)
    # После повышения уровня прогресс снова 0%
    progress = player.get_exp_progress()
    assert progress == 0


# УБРАЛИ ТЕСТ test_concrete_player_classes, так как классы Berserker и Mage 
# теперь создаются только через JSON и не определены напрямую в player.py
================================================================================

/home/zumik/Documents/Battler_0.3/game/__init__.py

================================================================================

/home/zumik/Documents/Battler_0.3/game/protocols.py
# game/protocols.py
"""Протоколы (интерфейсы) для взаимодействия компонентов игры."""

from typing import Protocol, List, Dict, Any, Optional, TYPE_CHECKING, Callable

# Используем TYPE_CHECKING, чтобы избежать циклических импортов в аннотациях
if TYPE_CHECKING:
    from game.entities.character import Character

# --- Протоколы для подсистем ---

class Ability(Protocol):
    """Протокол для способности."""
    name: str
    description: str
    energy_cost: int
    # Можно добавить другие общие атрибуты
    
    def can_use(self, user: 'Character') -> bool: ...
    def use(self, user: 'Character', targets: List['Character'], **kwargs) -> Any: ...

class StatusEffect(Protocol):
    """Протокол для статус-эффекта."""
    name: str
    description: str
    duration: int # Оставшаяся продолжительность
    
    def apply(self, target: 'Character') -> Dict[str, Any]: # Возвращает словарь с сообщением или результатом
        """Применить эффект к цели."""
        ...
    def update(self, target: 'Character') -> Dict[str, Any]: # Возвращает словарь с сообщением или результатом
        """Обновить эффект (например, нанести урон от отравления)."""
        ...
    def remove(self, target: 'Character') -> Dict[str, Any]: # Возвращает словарь с сообщением или результатом
        """Удалить эффект с цели."""
        ...
    def is_expired(self) -> bool: ...

class Stats(Protocol):
    """Протокол для базовых характеристик."""
    strength: int
    agility: int
    intelligence: int
    vitality: int
    # ... другие базовые характеристики

class Attributes(Protocol): # <-- ИЗМЕНЕНО: DerivedStats -> Attributes
    """Протокол для атрибутов персонажа."""
    max_hp: int
    max_energy: int
    attack_power: int
    defense: int
    # ... другие атрибуты

# --- Протоколы для менеджеров ---

class AbilityManagerProtocol(Protocol):
    """Протокол для менеджера способностей."""
    def add_ability(self, name: str, ability: Ability) -> None: ...
    def get_available_abilities(self, character: 'Character') -> List[str]: ...
    def use_ability(self, name: str, user: 'Character', targets: List['Character'], **kwargs) -> Any: ...
    def update_cooldowns(self) -> None: ...

class StatusEffectManagerProtocol(Protocol):
    """Протокол для менеджера статус-эффектов."""
    def add_effect(self, effect: StatusEffect) -> Dict[str, Any]: ...
    def remove_effect(self, effect_name: str) -> bool: ...
    def update_effects(self) -> List[Dict[str, Any]]: # Возвращает список сообщений/результатов
        """Обновить все эффекты и вернуть список результатов."""
        ...
    def has_effect(self, effect_name: str) -> bool: ...
    def get_all_effects(self) -> List[StatusEffect]: ...
    def clear_all_effects(self) -> List[Dict[str, Any]]: # Возвращает список сообщений/результатов
        """Очистить все эффекты и вернуть список результатов."""
        ...

# --- Протоколы для системы уровней/опыта ---
# Эти протоколы позволят нам в будущем легко подменить систему роста

class ExperienceCalculatorProtocol(Protocol):
    """Протокол для калькулятора опыта."""
    def calculate_exp_for_next_level(self, current_level: int) -> int: ...
    def calculate_stat_increase(self, base_stat: int, growth_rate: float, level: int) -> int: ...

class LevelUpHandlerProtocol(Protocol):
    """Протокол для обработчика повышения уровня."""
    def handle_level_up(self, character: 'Character') -> List[Dict[str, Any]]:
        """Обработать повышение уровня и вернуть список результатов."""
        ...

================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/screen_manager.py
# game/ui/screen_manager.py
import curses
from typing import Dict, Type, List
from game.ui.base_screen import BaseScreen
from game.ui.main_screen import MainScreen
from game.ui.battle_screen import BattleScreen
from game.ui.inventory_screen import InventoryScreen
from game.ui.rendering.renderer import Renderer
from game.ui.rendering.color_manager import ColorManager

class ScreenManager:
    """Управление экранами игры с использованием паттерна состояние."""
    def __init__(self, stdscr: curses.window):
        self.stdscr = stdscr
        self.color_manager = ColorManager()
        self.color_manager.initialize(stdscr)
        # Инициализируем renderer, он получит начальный размер
        self.renderer = Renderer(stdscr, self.color_manager)
        self.screens: Dict[str, Type[BaseScreen]] = {
            "main": MainScreen,
            "battle": BattleScreen,
            "inventory": InventoryScreen,
        }
        self.screen_stack: List[BaseScreen] = []
        # Начинаем с главного экрана
        initial_screen = self.screens["main"](self)
        self.screen_stack.append(initial_screen)

    @property
    def current_screen(self) -> BaseScreen:
        """Текущий экран - верхний элемент стека."""
        return self.screen_stack[-1]

    def change_screen(self, screen_name: str) -> None:
        """Переход на новый экран (добавление в стек)."""
        if screen_name in self.screens:
            new_screen = self.screens[screen_name](self)
            self.screen_stack.append(new_screen)
        else:
            raise ValueError(f"Неизвестный экран: {screen_name}")

    def go_back(self) -> None:
        """Возврат к предыдущему экрану (выход из стека)."""
        if len(self.screen_stack) > 1:
            self.screen_stack.pop()
        else:
            # Если это последний экран - выходим из приложения
            exit()

    def _update_renderer_for_all_screens(self) -> None:
        """Обновляет renderer для всех экранов в стеке."""
        # Создаём новый экземпляр renderer с текущими размерами stdscr
        self.renderer = Renderer(self.stdscr, self.color_manager)
        # Обновляем renderer у всех экранов в стеке
        for screen in self.screen_stack:
            screen.renderer = self.renderer # type: ignore # BaseScreen.renderer аннотирован как Renderer

    def run(self) -> None:
        """Основной цикл отображения текущего экрана."""
        while True:
            self.current_screen.render(self.stdscr)
            key = self.stdscr.getch()

            # Проверяем, является ли нажатая клавиша сигналом изменения размера
            if key == curses.KEY_RESIZE:
                # Сообщаем curses об изменении размера (иногда помогает)
                # h, w = self.stdscr.getmaxyx() # Не всегда нужно, но можно попробовать
                # curses.resizeterm(h, w) # Не всегда нужно, но можно попробовать

                # Обновляем renderer у менеджера и всех экранов
                self._update_renderer_for_all_screens()
                # Продолжаем цикл для перерисовки с новым renderer'ом
                continue # Переход к следующей итерации цикла, что вызовет перерисовку

            # Если это не изменение размера, обрабатываем ввод как обычно
            self.current_screen.handle_input(key)

================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/base_screen.py
# game/ui/base_screen.py
import curses
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, List
from game.ui.rendering.renderable import Renderable
from game.ui.rendering.renderer import Renderer
from game.ui.command_system import CommandRegistry
from game.ui.command_system.screen_command_registry import get_screen_commands

if TYPE_CHECKING:
    from game.ui.screen_manager import ScreenManager
    from game.ui.command_system.command import Command # Импортируем Command для аннотаций

class BaseScreen(ABC):
    """Абстрактный базовый класс для всех экранов."""
    def __init__(self, manager: 'ScreenManager'):
        self.manager = manager
        self.elements: List[Renderable] = []
        self.renderer: Renderer = manager.renderer
        self.command_registry = CommandRegistry()
        self._setup_elements()
        self._setup_commands()
        self._setup_auto_commands()

    @abstractmethod
    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        pass

    @abstractmethod
    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        pass

    def _setup_auto_commands(self) -> None:
        """Автоматическая регистрация команд из реестра."""
        # Явно аннотируем тип возвращаемого значения get_screen_commands
        commands: List['Command'] = get_screen_commands(self.__class__)
        # Явно аннотируем тип переменной command в цикле
        command: 'Command'
        for command in commands:
            self.add_command(command) # <-- Эта строка вызывала ошибку mypy

    def add_command(self, command: 'Command') -> None: # <-- Убедитесь, что тип команды аннотирован здесь
        """
        Добавление команды на экран.
        Args:
            command: Команда для добавления
        """
        self.command_registry.register_command(command)

    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
        # Базовый класс НЕ отрисовывает команды.
        # Это responsibility конкретных экранов или миксинов.
        # Отрисовка команд убрана отсюда.

    def handle_input(self, key: int) -> None:
        """
        Обработка ввода пользователя.
        Args:
            key: Нажатая клавиша
        """
        # Пытаемся выполнить команду, если не удалось - вызываем обработчик по умолчанию
        if not self.command_registry.execute_command(key, self):
            self._handle_unregistered_key(key)

    def _handle_unregistered_key(self, key: int) -> None:
        """
        Обработка назарегистрированных клавиш.
        Может быть переопределен в подклассах.
        """
        pass
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/main_screen.py
# game/ui/main_screen.py
"""
Главный экран игры.
Отображает главное меню с возможностью перехода в бой или инвентарь,
а также выход из игры.
"""
import curses
# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.ui.mixins import StandardLayoutMixin
# --------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class MainScreen(BaseScreen, StandardLayoutMixin):
    """Главный экран игры."""

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель, так как они теперь в миксине
        self.elements = [
            # Основные кнопки (визуальное отображение)
            # Смещаем Y на +2, так как шапка занимает первые 2 строки
            Text("[1] Начать бой", 5, 2, color=Color.GREEN, bold=True),
            Text("[2] Инвентарь", 5, 3, color=Color.YELLOW),
            Text("[3] Настройки", 5, 4, color=Color.MAGENTA, dim=True),
            # Separator(6, color=Color.BLUE), # Убираем старый разделитель
            # Кнопка выхода
            Text("[q] Выйти из игры", 20, 6, color=Color.RED, dim=True),
            # Информационное сообщение
            Text("Используйте клавиши 1, 2, 3 для навигации", 2, 8, dim=True),
            Text("Нажмите 'q' для выхода", 2, 9, dim=True)
            # Нижний разделитель и команды теперь тоже из миксина
        ]

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Все команды добавятся автоматически из реестра!
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        
        # Отрисовка стандартного макета (шапка + подвал)
        self.render_standard_layout("=== ГЛАВНОЕ МЕНЮ ===")
        
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
            
        self.renderer.refresh() # Не забываем refresh в конце конкретного render

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        pass

================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/__init__.py
# game/ui/__init__.py
"""
Пакет пользовательского интерфейса игры.

Содержит все компоненты для отображения и взаимодействия с пользователем.
"""

# Импортируем основные компоненты для удобства
from .screen_manager import ScreenManager
from .base_screen import BaseScreen

__all__ = [
    'ScreenManager',
    'BaseScreen'
]
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/battle_screen.py
# game/ui/battle_screen.py
"""
Экран боя.
Отображает боевую сцену с возможностью взаимодействия.
"""
import curses
from typing import TYPE_CHECKING

# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.ui.mixins import StandardLayoutMixin
# --------------------------------
# --- ИМПОРТИРУЕМ НОВЫЕ КОМПОНЕНТЫ ---
from game.ui.components.battle_components import (
    PlayerUnitPanel, 
    EnemyUnitPanel, 
    GroupPanel, 
    BattleLog
)
# ------------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.color_manager import Color

# --- ДОБАВЛЯЕМ ИМПОРТ ДЛЯ TYPE_CHECKING ---
if TYPE_CHECKING:
    from game.ui.screen_manager import ScreenManager
# ------------------------------------------

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class BattleScreen(BaseScreen, StandardLayoutMixin):
    """Экран боя."""

    def __init__(self, manager: 'ScreenManager'):
        # Инициализируем атрибуты для компонентов
        self.player_group: GroupPanel = None # type: ignore # Будет инициализирован в _setup_elements
        self.enemy_group: GroupPanel = None # type: ignore
        self.battle_log: BattleLog = None # type: ignore
        super().__init__(manager)

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель, так как они теперь в миксине
        self.elements = [] # Очищаем список, так как компоненты будут отрисовываться напрямую
        
        # --- НАСТРОЙКА КОМПОНЕНТОВ ---
        # Инициализируем компоненты с начальными размерами
        # Они будут обновлены в render/update_size
        header_height = 2
        initial_group_height = 6 # Примерная высота для группы (может быть динамической)
        player_group_x = 1
        player_group_y = header_height
        # enemy_group_x будет рассчитан в update_size
        enemy_group_y = header_height
        log_x = 1
        # log_y будет рассчитан в update_size
        log_width = max(10, self.renderer.width - 2)
        # log_height будет рассчитан в update_size
        
        # Создаем группы и лог с начальными параметрами
        self.player_group = GroupPanel(
            player_group_x, player_group_y, 
            self.renderer.width // 2 - 1, initial_group_height, 
            "Игроки"
        )
        # Временные координаты для enemy_group, будут обновлены в update_size
        self.enemy_group = GroupPanel(
            self.renderer.width // 2 + 1, enemy_group_y, 
            self.renderer.width // 2 - 1, initial_group_height, 
            "Враги"
        )
        
        # Добавляем тестовые панели юнитов
        # В реальной игре это будет делаться на основе данных о бое
        player1 = PlayerUnitPanel(0, 0, 30, "Герой", 100, 100, 50, 50)
        player2 = PlayerUnitPanel(0, 0, 30, "Соратник", 80, 80, 30, 30)
        self.player_group.add_unit_panel(player1)
        self.player_group.add_unit_panel(player2)
        
        enemy1 = EnemyUnitPanel(0, 0, 30, "Дракон", 150, 150)
        enemy2 = EnemyUnitPanel(0, 0, 30, "Гоблин", 40, 40)
        self.enemy_group.add_unit_panel(enemy1)
        self.enemy_group.add_unit_panel(enemy2)
        
        # Временные координаты для battle_log, будут обновлены в update_size
        self.battle_log = BattleLog(log_x, header_height + initial_group_height + 1, log_width, 10)
        
        # Обновляем размеры компонентов
        self._update_component_sizes()

    def _update_component_sizes(self) -> None:
        """Обновление размеров всех компонентов."""
        if not (self.player_group and self.enemy_group and self.battle_log):
            return
            
        # Обновляем размеры групп
        group_width = max(10, self.renderer.width // 2 - 1)
        # Высота групп может быть фиксированной или рассчитанной, пока фиксированная
        group_height = max(3, min(10, len(self.player_group.unit_panels) + 2, len(self.enemy_group.unit_panels) + 2))
        
        self.player_group.width = group_width
        self.player_group.height = group_height
        self.enemy_group.x = max(0, self.renderer.width // 2 + 1)
        self.enemy_group.width = group_width
        self.enemy_group.height = group_height
        
        # Обновляем размеры и позицию лога
        log_y = self.player_group.y + group_height + 1
        self.battle_log.x = 1
        self.battle_log.y = log_y
        self.battle_log.width = max(10, self.renderer.width - 2)
        # Лог занимает всё оставшееся пространство до подвала (2 строки)
        footer_height = 2
        self.battle_log.height = max(3, self.renderer.height - log_y - footer_height)
        
        # Обновляем размеры дочерних компонентов, если у них есть такой метод
        # (в данном случае GroupPanel сам управляет своими UnitPanel)
        # BattleLog и GroupPanel имеют свои методы update_size, но они простые
        # Для BattleLog update_size в текущей реализации пустой, но можно расширить
        # self.battle_log.update_size(self.renderer.width, self.renderer.height)
        # self.player_group.update_size(self.renderer.width, self.renderer.height)
        # self.enemy_group.update_size(self.renderer.width, self.renderer.height)

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Все команды добавятся автоматически из реестра!
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        # Обновляем размеры компонентов перед отрисовкой
        self._update_component_sizes()
        
        self.renderer.clear()
        # Отрисовка стандартного макета (шапка + подвал)
        self.render_standard_layout("=== БОЙ ===")
        
        # --- ОТРИСОВКА НОВЫХ КОМПОНЕНТОВ ---
        # Отрисовываем компоненты напрямую
        if self.player_group:
            self.player_group.render(self.renderer)
        if self.enemy_group:
            self.enemy_group.render(self.renderer)
        if self.battle_log:
            self.battle_log.render(self.renderer)
        # ------------------------------------
        
        self.renderer.refresh() # Не забываем refresh

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        # Обработка прокрутки лога
        if key == curses.KEY_UP:
            if self.battle_log:
                self.battle_log.scroll_up()
        elif key == curses.KEY_DOWN:
            if self.battle_log:
                self.battle_log.scroll_down()
        # Можно добавить отладочный вывод
        # print(f"BattleScreen: Нажата незарегистрированная клавиша: {key}") 

================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/inventory_screen.py
# game/ui/inventory_screen.py
"""
Экран инвентаря.
Отображает содержимое инвентаря игрока.
"""
import curses
# --- ДОБАВЛЯЕМ ИМПОРТ МИКСИНА ---
from game.ui.mixins import StandardLayoutMixin
# --------------------------------
from game.ui.base_screen import BaseScreen
from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color

# --- НАСЛЕДУЕМСЯ ОТ StandardLayoutMixin ---
class InventoryScreen(BaseScreen, StandardLayoutMixin):
    """Экран инвентаря."""

    def _setup_elements(self) -> None:
        """Настройка элементов экрана."""
        # УБИРАЕМ старый заголовок и разделитель
        self.elements = [
            # Предметы инвентаря (смещаем Y на +2)
            Text("• Меч (+10 ATK)", 2, 2, color=Color.WHITE),           # Смещаем Y
            Text("• Зелье лечения", 2, 3, color=Color.GREEN, dim=True), # Смещаем Y
            Text("• Ключ от сундука", 2, 4, color=Color.CYAN, dim=True), # Смещаем Y
            Text("• Свиток телепортации", 2, 5, color=Color.MAGENTA, dim=True), # Смещаем Y
            # Separator(7, "-", 40, Color.WHITE, dim=True), # Убираем старый разделитель
            # Статистика (смещаем Y)
            Text("Всего предметов: 4", 2, 7, dim=True), # Смещаем Y
            Text("Занято: 4/20", 2, 8, dim=True),       # Смещаем Y
            # Separator(10, color=Color.YELLOW), # Убираем старый разделитель
        ]

    def _setup_commands(self) -> None:
        """Настройка дополнительных команд экрана."""
        # Команды из реестра добавятся автоматически!
        # Здесь можно добавить специфичные для этого экрана команды
        pass

    # --- ОБНОВЛЯЕМ МЕТОД render ---
    def render(self, stdscr: curses.window) -> None:
        """Отрисовка экрана."""
        self.renderer.clear()
        
        # Отрисовка стандартного макета
        self.render_standard_layout("=== ИНВЕНТАРЬ ===")
        
        # Отрисовка основных элементов
        for element in self.elements:
            element.render(self.renderer)
            
        self.renderer.refresh() # Не забываем refresh

    def _handle_unregistered_key(self, key: int) -> None:
        """Обработка незарегистрированных клавиш."""
        pass

================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/mixins.py
# game/ui/mixins.py
"""
Миксины для повторно используемой функциональности экранов.
"""
from typing import TYPE_CHECKING, Protocol

from game.ui.rendering.renderable import Text, Separator
from game.ui.rendering.color_manager import Color
from game.ui.command_system import CommandRenderer

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen
    from game.ui.rendering.renderer import Renderer
    from game.ui.command_system.command import CommandRegistry

# Протокол, описывающий интерфейс для классов, использующих миксины
class LayoutProtocol(Protocol):
    """Протокол для классов с методами отрисовки шапки и подвала."""
    renderer: 'Renderer' # type: ignore # Будет определен в BaseScreen
    command_registry: 'CommandRegistry' # type: ignore # Будет определен в BaseScreen

    def render_header(self, title: str) -> None: ...
    def render_footer(self) -> None: ...



class HeaderMixin:
    """Миксин для отрисовки стандартной шапки экрана."""
    
    def render_header(self: LayoutProtocol, title: str) -> None:
        """
        Отрисовка стандартной шапки экрана.
        Args:
            title: Текст заголовка.
        """
        # Центрируем заголовок
        # Используем getattr для доступа к атрибутам через протокол
        renderer = getattr(self, 'renderer')
        title_x = max(0, (renderer.width - len(title)) // 2)
        header_text = Text(title, title_x, 0, bold=True, color=Color.CYAN)
        header_text.render(renderer)

        # Рисуем разделитель под заголовком
        header_separator = Separator(1, color=Color.DEFAULT)
        header_separator.render(renderer)


class FooterMixin:
    """Миксин для отрисовки стандартного подвала экрана."""
    
    def render_footer(self: LayoutProtocol) -> None:
        """
        Отрисовка стандартного подвала экрана.
        Получает команды из command_registry и отрисовывает их.
        """
        # Получаем команды для отрисовки
        command_registry = getattr(self, 'command_registry')
        renderer = getattr(self, 'renderer')
        commands = command_registry.get_all_commands()

        # Рассчитываем позиции подвала
        footer_separator_y = max(0, renderer.height - 2)
        commands_y = max(0, renderer.height - 1)
        
        # Отрисовка разделителя подвала
        footer_separator = Separator(footer_separator_y, color=Color.GRAY)
        footer_separator.render(renderer)

        # Отрисовка команд в последней строке
        footer_command_renderer = CommandRenderer(y=commands_y)
        command_elements = footer_command_renderer.render_commands(commands)
        for element in command_elements:
            element.render(renderer)


# Можно также создать комбинированный миксин для удобства
class StandardLayoutMixin(HeaderMixin, FooterMixin):
    """Миксин, объединяющий стандартную шапку и подвал."""
    
    def render_standard_layout(self: LayoutProtocol, title: str) -> None:
        """
        Отрисовка стандартного макета экрана (шапка + подвал).
        Args:
            title: Текст заголовка.
        """
        # Теперь mypy знает, что у self есть эти методы благодаря LayoutProtocol
        self.render_header(title)
        self.render_footer()

================================================================================

/home/zumik/Documents/Battler_0.3/game/entities/character.py
# game/entities/character.py
"""Базовый класс персонажа в игре."""

from typing import List, Dict, Any, Optional, Callable
from game.protocols import (
    Stats, 
    Attributes,
    AbilityManagerProtocol, 
    StatusEffectManagerProtocol,
    Ability,
    StatusEffect
)

# --- Базовые реализации для примера ---
# В реальном проекте они будут в отдельных файлах

class SimpleStats:
    """Простая реализация базовых характеристик."""
    def __init__(self, strength: int = 10, agility: int = 10, intelligence: int = 10, vitality: int = 10):
        self.strength = strength
        self.agility = agility
        self.intelligence = intelligence
        self.vitality = vitality

class SimpleAttributes:
    """Простая реализация атрибутов персонажа."""
    def __init__(self, base_stats: Stats, level: int = 1):
        # Простое вычисление на основе базовых характеристик и уровня
        self.max_hp = base_stats.vitality * 10 + (level - 1) * 5
        self.max_energy = (base_stats.strength + base_stats.agility) * 2 + (level - 1) * 3
        self.attack_power = base_stats.strength * 2 + (level - 1) * 1
        self.defense = base_stats.agility + (level - 1) * 1

# --- Основной класс персонажа ---

class Character:
    """Базовый класс, представляющий персонажа в игре."""

    def __init__(
        self, 
        name: str, 
        role: str, 
        level: int = 1,
        is_player: bool = False,
        # Внедрение зависимостей через конструктор
        stats_factory: Callable[[], Stats] = lambda: SimpleStats(), 
        attributes_factory: Callable[['Character'], Attributes] = lambda char: SimpleAttributes(char.stats, char.level),
        ability_manager_factory: Callable[['Character'], AbilityManagerProtocol] = None,
        status_effect_manager_factory: Callable[['Character'], StatusEffectManagerProtocol] = None,
    ):
        self.name = name
        self.role = role
        self.is_player = is_player
        self.level = level
        self.alive = True
        
        # Создаем объекты характеристик
        self.stats = stats_factory()
        self.attributes = attributes_factory(self)
        
        # Инициализируем hp и энергию
        self.hp = self.attributes.max_hp
        self.energy = self.attributes.max_energy
        
        # Менеджеры (внедрение зависимостей)
        self._ability_manager: Optional[AbilityManagerProtocol] = None
        if ability_manager_factory:
            self._ability_manager = ability_manager_factory(self)
            
        self._status_manager: Optional[StatusEffectManagerProtocol] = None
        if status_effect_manager_factory:
            self._status_manager = status_effect_manager_factory(self)

    def _scale_stats_to_level(self) -> None:
        """
        Масштабирует характеристики персонажа в соответствии с текущим уровнем.
        Пересоздает stats и attributes с учетом уровня.
        """
        # Если у персонажа есть фабрики, используем их для пересоздания характеристик
        # В противном случае полагаемся на стандартные реализации
        
        # Пересоздаем stats (если используется SimpleStats, то значения остаются теми же)
        # В реальной системе здесь могла бы быть логика масштабирования базовых характеристик
        if hasattr(self, '_stats_factory') and self._stats_factory:
            self.stats = self._stats_factory()
        # Если фабрика не задана, оставляем текущие stats как есть
        
        # Пересоздаем attributes с учетом текущего уровня
        if hasattr(self, '_attributes_factory') and self._attributes_factory:
            self.attributes = self._attributes_factory(self)
        else:
            # Если фабрика не задана, создаем стандартные атрибуты
            self.attributes = SimpleAttributes(self.stats, self.level)
        
        # Обновляем hp и энергию в соответствии с новыми атрибутами
        # Сохраняем процент текущего HP и энергии, если персонаж жив
        if self.alive:
            if hasattr(self, '_old_hp_ratio'):
                # Восстанавливаем HP по старому проценту
                self.hp = max(1, int(self.attributes.max_hp * self._old_hp_ratio))
            else:
                # Если это первая инициализация, устанавливаем HP на максимум
                self.hp = self.attributes.max_hp
                
            if hasattr(self, '_old_energy_ratio'):
                # Восстанавливаем энергию по старому проценту
                self.energy = int(self.attributes.max_energy * self._old_energy_ratio)
            else:
                # Если это первая инициализация, устанавливаем энергию на максимум
                self.energy = self.attributes.max_energy
        else:
            # Если персонаж мертв, HP и энергия остаются 0
            self.hp = 0
            self.energy = 0

    # ==================== Свойства ====================
    @property
    def ability_manager(self) -> Optional[AbilityManagerProtocol]:
        """Получение менеджера способностей."""
        return self._ability_manager

    @property
    def status_manager(self) -> Optional[StatusEffectManagerProtocol]:
        """Получение менеджера статус-эффектов."""
        return self._status_manager

    # ==================== Основные методы персонажа ====================
    def is_alive(self) -> bool:
        """Проверяет, жив ли персонаж."""
        return self.alive

    def get_level(self) -> int:
        """Возвращает уровень персонажа."""
        return self.level

    def on_death(self) -> List[Dict[str, Any]]:
        """
        Вызывается при смерти персонажа. 
        Возвращает список сообщений/результатов вместо прямого вывода.
        """
        results = []
        
        # Очищаем все активные статус-эффекты
        if self._status_manager is not None:
            clear_results = self.status_manager.clear_all_effects()
            results.extend(clear_results)
        
        # Добавляем сообщение о смерти
        results.append({"type": "death", "message": f"{self.name} погибает!"})
        return results

    # ==================== Боевые методы ====================
    def take_damage(self, damage: int) -> List[Dict[str, Any]]:
        """
        Наносит урон персонажу, учитывая защиту.
        Возвращает список сообщений/результатов.
        """
        results = []
        # TODO: Учесть защиту из attributes.defense
        actual_damage = max(0, damage) # Пока без учета защиты
        
        self.hp -= actual_damage
        results.append({
            "type": "damage_taken", 
            "target": self.name, 
            "damage": actual_damage,
            "hp_left": self.hp
        })
        
        if self.hp <= 0:
            self.hp = 0
            if self.alive: # Проверяем, чтобы не вызывать on_death дважды
                self.alive = False
                death_results = self.on_death()
                results.extend(death_results)
                
        return results

    def take_heal(self, heal_amount: int) -> List[Dict[str, Any]]:
        """
        Исцеляет персонажа и возвращает список сообщений/результатов.
        """
        results = []
        old_hp = self.hp
        self.hp = min(self.attributes.max_hp, self.hp + heal_amount)
        actual_heal = self.hp - old_hp
        results.append({
            "type": "healed", 
            "target": self.name, 
            "heal_amount": actual_heal,
            "hp_now": self.hp
        })
        return results

    # ==================== Энергия ====================
    def restore_energy(self, amount: Optional[int] = None, percentage: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Восстанавливает энергию персонажа.
        :param amount: конкретное количество энергии для восстановления
        :param percentage: процент от максимальной энергии для восстановления
        Возвращает список сообщений/результатов.
        """
        results = []
        old_energy = self.energy
        
        if percentage is not None:
            restore_amount = int(self.attributes.max_energy * (percentage / 100))
            self.energy = min(self.attributes.max_energy, self.energy + restore_amount)
        elif amount is not None:
            self.energy = min(self.attributes.max_energy, self.energy + amount)
        else:
            self.energy = self.attributes.max_energy # Полное восстановление
            
        actual_restore = self.energy - old_energy
        if actual_restore > 0:
            results.append({
                "type": "energy_restored", 
                "target": self.name, 
                "amount": actual_restore,
                "energy_now": self.energy
            })
            
        return results

    def spend_energy(self, amount: int) -> bool:
        """
        Тратит энергию персонажа.
        Возвращает True, если энергия была потрачена, иначе False.
        """
        if self.energy >= amount:
            self.energy -= amount
            return True
        return False

    # ==================== Способности ====================
    def add_ability(self, name: str, ability: Ability) -> None:
        """Добавляет способность персонажу."""
        if self._ability_manager:
            self.ability_manager.add_ability(name, ability)

    def get_available_abilities(self) -> List[str]:
        """Получает список доступных способностей."""
        if self._ability_manager:
            return self.ability_manager.get_available_abilities(self)
        return []

    def use_ability(self, name: str, targets: List['Character'], **kwargs) -> List[Dict[str, Any]]:
        """
        Использует способность по имени.
        Возвращает список сообщений/результатов от способности и менеджера.
        """
        results = []
        if self._ability_manager:
            ability_result = self.ability_manager.use_ability(name, self, targets, **kwargs)
            if ability_result:
                if isinstance(ability_result, list):
                    results.extend(ability_result)
                else:
                    results.append(ability_result)
        return results

    def update_ability_cooldowns(self) -> None:
        """Обновляет кулдауны способностей в конце раунда."""
        if self._ability_manager:
            self.ability_manager.update_cooldowns()

    # ==================== Статус-эффекты ====================
    def add_status_effect(self, effect: StatusEffect) -> List[Dict[str, Any]]:
        """Добавляет статус-эффект персонажу. Возвращает результат от менеджера."""
        if self._status_manager:
            return [self.status_manager.add_effect(effect)]
        return []

    def remove_status_effect(self, effect_name: str) -> List[Dict[str, Any]]:
        """Удаляет статус-эффект по имени. Возвращает результат."""
        results = []
        if self._status_manager:
            success = self.status_manager.remove_effect(effect_name)
            if success:
                results.append({"type": "effect_removed", "effect": effect_name, "target": self.name})
            else:
                results.append({"type": "error", "message": f"Эффект {effect_name} не найден у {self.name}"})
        return results

    def update_status_effects(self) -> List[Dict[str, Any]]:
        """Обновляет все активные статус-эффекты. Возвращает список результатов."""
        if self._status_manager:
            return self.status_manager.update_effects()
        return []

    def has_status_effect(self, effect_name: str) -> bool:
        """Проверяет, есть ли у персонажа определенный статус-эффект."""
        if self._status_manager:
            return self.status_manager.has_effect(effect_name)
        return False

    def get_active_status_effects(self) -> List[StatusEffect]:
        """Возвращает список всех активных статус-эффектов."""
        if self._status_manager:
            return self.status_manager.get_all_effects()
        return []
================================================================================

/home/zumik/Documents/Battler_0.3/game/entities/player.py
# game/entities/player.py
"""Класс игрока (персонажа, управляемого игроком)."""
from typing import List, Dict, Any, Optional, Callable, TYPE_CHECKING
from game.entities.character import Character
from game.protocols import (
    Stats,
    Attributes,
    AbilityManagerProtocol,
    StatusEffectManagerProtocol,
    ExperienceCalculatorProtocol,
    LevelUpHandlerProtocol
)

# Используем TYPE_CHECKING для аннотаций без циклического импорта
if TYPE_CHECKING:
    from game.entities.ability import Ability
    from game.entities.status_effect import StatusEffect

# - Фабричная функция для создания игрока из JSON -
def create_player_from_data(
    name: str,
    role: str,
    level: int = 1,
    data_directory: str = "game/data/characters/player_classes"
) -> Optional['Player']:
    """
    Создает объект Player на основе данных из JSON файла.

    Args:
        name: Имя персонажа.
        role: Внутренний идентификатор класса (должен совпадать с именем .json файла).
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.

    Returns:
        Объект Player или None, если данные не могут быть загружены.
    """
    # Отложенная загрузка модуля character_loader внутри функции
    try:
        from game.data.character_loader import load_player_class_data
    except ImportError as e:
        print(f"Ошибка импорта character_loader внутри create_player_from_data: {e}")
        return None

    data = load_player_class_data(role, data_directory)
    if not data:
        print(f"Не удалось загрузить данные для класса '{role}'")
        return None

    try:
        # Создаем экземпляр Player, передавая ему загруженные данные
        player = Player(
            name=name,
            role=data['role'],  # Используем роль из файла данных
            base_stats_dict=data['base_stats'],
            growth_rates_dict=data['growth_rates'],
            class_icon=data.get('class_icon', '?'),
            class_icon_color=data.get('class_icon_color'),
            level=level,
            # ... другие параметры, если потребуются, можно установить в значения по умолчанию
            # или также загрузить из JSON ...
        )
        # Здесь также можно обработать starting_abilities, если они есть в данных
        # и система способностей уже реализована
        return player
    except Exception as e:
        print(f"Ошибка создания персонажа {name} класса {role}: {e}")
        import traceback
        traceback.print_exc()  # Для отладки
        return None

# - Класс игрока -
class Player(Character):
    """Класс для всех игроков (персонажей, управляемых игроком)."""

    def __init__(
        self,
        name: str,
        role: str,
        # Параметры для системы уровней/опыта
        base_stats_dict: Dict[str, int],  # Базовые характеристики из JSON/конфига
        growth_rates_dict: Dict[str, float],  # Темпы роста из JSON/конфига
        class_icon: str = "?",
        class_icon_color: Optional[int] = None,
        level: int = 1,
        # Внедрение зависимостей
        stats_factory: Optional[Callable[[], Stats]] = None,
        attributes_factory: Optional[Callable[['Character'], Attributes]] = None,
        ability_manager_factory: Optional[Callable[[], AbilityManagerProtocol]] = None,
        status_effect_manager_factory: Optional[Callable[[], StatusEffectManagerProtocol]] = None,
        exp_calculator: Optional[ExperienceCalculatorProtocol] = None,
        level_up_handler: Optional[LevelUpHandlerProtocol] = None,
        is_player: bool = True,
    ):
        # Инициализируем базовые атрибуты
        self.name = name
        self.role = role
        # self.level = 1  # <-- УДАЛЯЕМ ИНИЦИАЛИЗАЦИЮ ЗДЕСЬ
        self.level = level  # <-- И УСТАНАВЛИВАЕМ ЗНАЧЕНИЕ ИЗ ПАРАМЕТРА
        self.is_player = is_player
        self.class_icon = class_icon
        self.class_icon_color = class_icon_color if class_icon_color is not None else 0  # Устанавливаем значение по умолчанию, если None

        # Инициализируем менеджеры (ленивая инициализация)
        self._stats_factory = stats_factory
        self._attributes_factory = attributes_factory
        self._ability_manager_factory = ability_manager_factory
        self._status_effect_manager_factory = status_effect_manager_factory
        self._stats: Optional[Stats] = None
        self._attributes: Optional[Attributes] = None
        self._ability_manager: Optional[AbilityManagerProtocol] = None
        self._status_effects: Optional[StatusEffectManagerProtocol] = None

        # Инициализируем характеристики и статы
        # Для простоты предполагаем, что фабрики принимают self как аргумент
        # и используют self.level внутри себя.
        self.base_stats_dict = base_stats_dict
        self.growth_rates_dict = growth_rates_dict

        # Инициализируем фабрики характеристик и атрибутов по умолчанию
        if self._stats_factory is None:
            self._stats_factory = lambda: SimpleStats()
        if self._attributes_factory is None:
            self._attributes_factory = lambda char: SimpleAttributes(
                char, self._stats_factory()
            )

        # Создаем менеджеры способностей и эффектов, если фабрики предоставлены
        if self._ability_manager_factory:
            self._ability_manager = self._ability_manager_factory()
        if self._status_effect_manager_factory:
            self._status_effects = self._status_effect_manager_factory()

        # Инициализируем систему опыта
        self.exp_calculator = exp_calculator if exp_calculator else SimpleExperienceCalculator()
        self.level_up_handler = level_up_handler if level_up_handler else SimpleLevelUpHandler()
        # Устанавливаем начальный опыт
        self.exp = 0
        # self.exp_to_next_level = 0 # <-- УДАЛЯЕМ ИНИЦИАЛИЗАЦИЮ ЗДЕСЬ
        # self.calculate_exp_for_next_level() # <-- УДАЛЯЕМ ВЫЗОВ ЗДЕСЬ

        # После инициализации Character, обновляем характеристики
        # в соответствии с уровнем и базовыми параметрами
        # ПОСЛЕ ВСЕЙ ИНИЦИАЛИЗАЦИИ ВЫЗЫВАЕМ _scale_stats_to_level
        # Теперь self.level и фабрики точно установлены
        self._scale_stats_to_level() # <-- ПЕРЕМЕЩАЕМ СЮДА

        # ПОСЛЕ _scale_stats_to_level ВЫЗЫВАЕМ calculate_exp_for_next_level
        # Теперь self.level и stats/attributes точно установлены
        self.calculate_exp_for_next_level()  # <-- ПЕРЕМЕЩАЕМ СЮДА

    # Метод _scale_stats_to_level должен быть определен в Player, если он вызывается оттуда
    # или должен корректно наследоваться от Character.
    # Если он есть в Character, то его можно не переопределять.
    # Но если тесты падают, возможно, его нужно переопределить или убедиться в правильном наследовании.
    # Добавим базовую реализацию, если она отсутствует или не работает как ожидается.
    # def _scale_stats_to_level(self) -> None:
    #     """Масштабирует характеристики в соответствии с уровнем."""
    #     # Простая реализация: создаем stats и attributes с использованием фабрик
    #     # и учитываем уровень. В реальности логика будет сложнее.
    #     if self._stats is None and self._stats_factory:
    #         self._stats = self._stats_factory()
    #         # Здесь должна быть логика масштабирования stats по уровню
    #         # Пока просто устанавливаем базовые значения
    #         if hasattr(self._stats, 'strength'):
    #             self._stats.strength = self.base_stats_dict.get('strength', 0)
    #         if hasattr(self._stats, 'agility'):
    #             self._stats.agility = self.base_stats_dict.get('agility', 0)
    #         if hasattr(self._stats, 'intelligence'):
    #             self._stats.intelligence = self.base_stats_dict.get('intelligence', 0)
    #         if hasattr(self._stats, 'vitality'):
    #             self._stats.vitality = self.base_stats_dict.get('vitality', 0)
    #     
    #     if self._attributes is None and self._attributes_factory:
    #         # Атрибуты зависят от stats, которые должны быть уже созданы
    #         self._attributes = self._attributes_factory(self)
    #     
    #     # Инициализируем HP и энергию после создания атрибутов
    #     if self._attributes:
    #         self.hp = self._attributes.max_hp
    #         self.energy = self._attributes.max_energy
    #     else:
    #         self.hp = 100 # Значение по умолчанию
    #         self.energy = 50 # Значение по умолчанию

    def calculate_exp_for_next_level(self) -> None:
        """
        Рассчитывает количество опыта, необходимого для следующего уровня.
        """
        # Проверяем, существует ли self.level перед использованием
        # Хотя теперь это должно быть гарантировано, проверка не повредит
        if not hasattr(self, 'level'):
            # Это может произойти, если метод вызван слишком рано.
            # В текущей логике этого быть не должно после исправления.
            # Можно установить значение по умолчанию или вызвать исключение.
            print("Предупреждение: calculate_exp_for_next_level вызван до установки self.level")
            self.exp_to_next_level = 10  # Значение по умолчанию или raise ValueError
            return

        self.exp_to_next_level = self.exp_calculator.calculate_exp_for_next_level(self.level)

# - Базовые реализации для примера -
# В реальном проекте они будут в отдельных файлах

class SimpleStats:
    """Простая реализация базовых характеристик."""
    def __init__(self):
        self.strength = 0
        self.agility = 0
        self.intelligence = 0
        self.vitality = 0

class SimpleAttributes:
    """Простая реализация производных атрибутов."""
    def __init__(self, character: Character, stats: Stats):
        self.character = character
        self.stats = stats
        # Пример расчета производных атрибутов
        self.max_hp = 50 + (stats.vitality * 5)
        self.max_energy = 20 + (stats.intelligence * 3)
        self.attack_power = stats.strength * 2
        self.defense = stats.agility * 1.5

class SimpleExperienceCalculator:
    """Простой калькулятор опыта для следующего уровня."""
    def calculate_exp_for_next_level(self, current_level: int) -> int:
        """Рассчитывает опыт, необходимый для достижения следующего уровня."""
        # Простая формула: 100 * (уровень)^1.5
        return int(100 * (current_level ** 1.5))

class SimpleLevelUpHandler:
    """Простой обработчик повышения уровня."""
    def handle_level_up(self, character: Character) -> List[Dict[str, Any]]:
        """Обработать повышение уровня и вернуть список результатов."""
        results = []
        # Пример: восстановление HP и MP при повышении уровня
        old_hp = character.hp
        character.hp = character.attributes.max_hp
        hp_restored = character.hp - old_hp
        
        old_energy = character.energy
        character.energy = character.attributes.max_energy
        energy_restored = character.energy - old_energy
        
        results.append({
            "type": "level_up_heal",
            "character": character.name,
            "hp_restored": hp_restored,
            "energy_restored": energy_restored
        })
        
        return results
================================================================================

/home/zumik/Documents/Battler_0.3/game/data/character_loader.py
# game/data/character_loader.py
"""
Загрузчик данных персонажей из JSON файлов.
"""

import json
import os
from typing import Dict, Any, Optional, TYPE_CHECKING

# Используем TYPE_CHECKING для аннотаций без циклического импорта на уровне модуля
if TYPE_CHECKING:
    from game.entities.player import Player

def load_player_class_data(
    role: str, 
    data_directory: str = "game/data/characters/player_classes"
) -> Optional[Dict[str, Any]]:
    """
    Загружает данные класса игрока из JSON файла.
    
    Args:
        role: Внутренний идентификатор класса (например, "berserker").
        data_directory: Путь к директории с JSON файлами.
        
    Returns:
        Словарь с данными класса или None, если файл не найден.
    """
    filename = f"{role}.json"
    filepath = os.path.join(data_directory, filename)
    
    # Проверяем, существует ли файл
    if not os.path.exists(filepath):
        # Пробуем относительный путь от корня проекта, если предыдущий не сработал
        # Это может помочь, если скрипт запускается не из корня проекта
        try:
            # Получаем путь к корню проекта (предполагаем, что loader.py находится в game/data/)
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
            filepath = os.path.join(project_root, data_directory, filename)
            if not os.path.exists(filepath):
                print(f"Файл данных для класса '{role}' не найден: {filepath}")
                return None
        except Exception as e:
            print(f"Ошибка при определении пути к файлу {filename}: {e}")
            return None
        
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return data
    except json.JSONDecodeError as e:
        print(f"Ошибка декодирования JSON в файле {filepath}: {e}")
        return None
    except Exception as e:
        print(f"Неизвестная ошибка при загрузке {filepath}: {e}")
        return None

def create_player(
    name: str, 
    role: str, 
    level: int = 1,
    data_directory: str = "game/data/characters/player_classes"
) -> Optional['Player']:
    """
    Создает объект Player на основе данных из JSON файла.
    Упрощенный интерфейс для game.entities.player.create_player_from_data.
    
    Args:
        name: Имя персонажа.
        role: Внутренний идентификатор класса.
        level: Начальный уровень.
        data_directory: Путь к директории с JSON файлами.
        
    Returns:
        Объект Player или None, если данные не могут быть загружены.
    """
    # Отложенная загрузка, чтобы избежать циклического импорта на уровне модуля
    try:
        # Импортируем внутри функции
        from game.entities.player import create_player_from_data as _internal_create
        return _internal_create(name, role, level, data_directory)
    except ImportError as e:
        print(f"Ошибка импорта при создании игрока: {e}")
        return None
    except Exception as e:
        print(f"Неожиданная ошибка при создании игрока {name} класса {role}: {e}")
        import traceback
        traceback.print_exc()
        return None

================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/rendering/__init__.py
# Game/UI/Rendering/__init__.py
"""
Модуль рендеринга пользовательского интерфейса.

Содержит компоненты для отрисовки текста, шаблонов, кнопок и других элементов
интерфейса с поддержкой цветов, форматирования и шаблонов.
"""

from .renderer import Renderer
from .renderable import Renderable, Text, TemplateText, Button, Separator
from .color_manager import Color, ColorManager
from .template_renderer import TemplatePart, TemplateRenderer

__all__ = [
    'Renderer',
    'Renderable', 'Text', 'TemplateText', 'Button', 'Separator',
    'Color', 'ColorManager',
    'TemplatePart', 'TemplateRenderer'
]
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/rendering/renderer.py
# Game/UI/Rendering/renderer.py
"""
Рендерер для отрисовки элементов пользовательского интерфейса.

Предоставляет абстракцию над библиотекой curses для упрощения отрисовки
текста, шаблонов и других элементов интерфейса.
"""

import curses
from typing import Dict, Tuple
from game.ui.rendering.color_manager import Color
from game.ui.rendering.template_renderer import TemplateRenderer


class Renderer:
    """Рендерер для отрисовки элементов на экране."""

    def __init__(self, stdscr: curses.window, color_manager):
        """
        Инициализация рендерера.
        
        Args:
            stdscr: Окно curses для отрисовки
            color_manager: Менеджер цветов
        """
        self.stdscr = stdscr
        self.color_manager = color_manager
        self.template_renderer = TemplateRenderer(color_manager)
        self.height, self.width = stdscr.getmaxyx()

    def clear(self) -> None:
        """Очистка экрана."""
        self.stdscr.clear()

    def draw_text(self, text: str, x: int, y: int, 
                  bold: bool = False, dim: bool = False, color: Color = Color.DEFAULT) -> None:
        """
        Отрисовка текста на экране.
        
        Args:
            text: Текст для отрисовки
            x: Координата X
            y: Координата Y
            bold: Жирный шрифт
            dim: Тусклый шрифт
            color: Цвет текста
        """
        try:
            # Проверяем границы экрана
            if y >= self.height or x >= self.width or y < 0 or x < 0:
                return
                
            # Получаем атрибуты
            attr = self.color_manager.get_color_pair(color)
            if bold:
                attr |= curses.A_BOLD
            if dim:
                attr |= curses.A_DIM
                
            self.stdscr.addstr(y, x, text, attr)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass

    def draw_template(self, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]], 
                      x: int, y: int) -> None:
        """
        Отрисовка шаблонного текста.
        
        Args:
            template: Шаблон текста с плейсхолдерами %1, %2 и т.д.
            replacements: Словарь замен {номер: (текст, цвет, жирный, тусклый)}
            x: Координата X
            y: Координата Y
        """
        try:
            # Проверяем границы экрана
            if y < 0 or x < 0 or y >= self.height:
                return
                
            self.template_renderer.draw_template(self.stdscr, template, replacements, x, y)
        except curses.error:
            pass

    def draw_box(self, x: int, y: int, width: int, height: int) -> None:
        """
        Отрисовка прямоугольника.
        
        Args:
            x: Координата X левого верхнего угла
            y: Координата Y левого верхнего угла
            width: Ширина прямоугольника
            height: Высота прямоугольника
        """
        try:
            # Верхняя и нижняя границы
            if y < self.height and y + height - 1 < self.height:
                self.stdscr.addstr(y, x, "+" + "-" * (width - 2) + "+")
                self.stdscr.addstr(y + height - 1, x, "+" + "-" * (width - 2) + "+")
            
            # Боковые границы
            for i in range(1, min(height - 1, self.height - y)):
                if y + i < self.height:
                    self.stdscr.addstr(y + i, x, "|")
                    if x + width - 1 < self.width:
                        self.stdscr.addstr(y + i, x + width - 1, "|")
        except curses.error:
            pass

    def refresh(self) -> None:
        """Обновление экрана."""
        self.stdscr.refresh()
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/rendering/renderable.py
# game/ui/rendering/renderable.py
"""
Базовые элементы пользовательского интерфейса.

Содержит абстрактные и конкретные классы для отображаемых элементов
интерфейса: текст, кнопки, разделители и т.д.
"""

from abc import ABC, abstractmethod
from typing import Dict, Tuple, Optional
from game.ui.rendering.color_manager import Color
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.rendering.renderer import Renderer

class Renderable(ABC):
    """Абстрактный базовый класс для всех отображаемых элементов."""

    def __init__(self, x: int = 0, y: int = 0):
        """
        Инициализация отображаемого элемента.
        
        Args:
            x: Координата X
            y: Координата Y
        """
        self.x = x
        self.y = y

    @abstractmethod
    def render(self, renderer: 'Renderer') -> None:
        """
        Отрисовка элемента.
        
        Args:
            renderer: Рендерер для отрисовки
        """
        pass


class Text(Renderable):
    """Текстовый элемент."""

    def __init__(self, text: str, x: int = 0, y: int = 0, 
                 bold: bool = False, dim: bool = False, color: Color = Color.DEFAULT):
        """
        Инициализация текстового элемента.
        
        Args:
            text: Отображаемый текст
            x: Координата X
            y: Координата Y
            bold: Жирный шрифт
            dim: Тусклый шрифт
            color: Цвет текста
        """
        super().__init__(x, y)
        self.text = text
        self.bold = bold
        self.dim = dim
        self.color = color

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка текста."""
        renderer.draw_text(self.text, self.x, self.y, self.bold, self.dim, self.color)


class TemplateText(Renderable):
    """Текст с шаблонами и цветами."""

    def __init__(self, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]], 
                 x: int = 0, y: int = 0):
        """
        Инициализация шаблонного текста.
        
        Args:
            template: Шаблон текста с плейсхолдерами %1, %2 и т.д.
            replacements: Словарь замен {номер: (текст, цвет, жирный, тусклый)}
            x: Координата X
            y: Координата Y
        """
        super().__init__(x, y)
        self.template = template
        self.replacements = replacements

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка шаблонного текста."""
        renderer.draw_template(self.template, self.replacements, self.x, self.y)


class Button(Renderable):
    """Кнопка."""

    def __init__(self, text: str, x: int = 0, y: int = 0, 
                 key: str = "", color: Color = Color.DEFAULT, bold: bool = False, dim: bool = False):
        """
        Инициализация кнопки.
        
        Args:
            text: Текст кнопки
            x: Координата X
            y: Координата Y
            key: Клавиша для активации
            color: Цвет текста
            bold: Жирный шрифт
            dim: Тусклый шрифт
        """
        super().__init__(x, y)
        self.text = text
        self.key = key
        self.color = color
        self.bold = bold
        self.dim = dim

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка кнопки."""
        display_text = f"[{self.key}] {self.text}" if self.key else self.text
        renderer.draw_text(display_text, self.x, self.y, self.bold, self.dim, self.color)


class Separator(Renderable):
    """Разделительная линия."""

    def __init__(self, y: int, char: str = "─", length: Optional[int] = None, 
                 color: Color = Color.RED, bold: bool = False, dim: bool = True):
        """
        Инициализация разделителя.
        
        Args:
            y: Координата Y
            char: Символ для линии
            length: Длина линии (None для автоматической)
            color: Цвет линии
            bold: Жирный шрифт
            dim: Тусклый шрифт
        """
        super().__init__(0, y)
        self.char = char
        self.length = length
        self.color = color
        self.bold = bold
        self.dim = dim

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка разделителя."""
        line_length = self.length or renderer.width
        line = self.char * (line_length - 1)
        renderer.draw_text(line, self.x, self.y, self.bold, self.dim, self.color)
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/rendering/color_manager.py
# Game/UI/Rendering/color_manager.py
"""
Управление цветами для пользовательского интерфейса.

Предоставляет систему цветов и управление цветовыми парами для curses.
"""

import curses
from enum import Enum


class Color(Enum):
    """Перечисление доступных цветов."""
    DEFAULT = 0
    RED = 1
    GREEN = 2
    YELLOW = 3
    BLUE = 4
    MAGENTA = 5
    CYAN = 6
    WHITE = 7
    GRAY = 8


class ColorManager:
    """Управление цветами для curses."""

    def __init__(self):
        """Инициализация менеджера цветов."""
        self.color_pairs = {}
        self._initialized = False

    def initialize(self, stdscr) -> None:
        """
        Инициализация цветов.
        
        Args:
            stdscr: Окно curses для инициализации цветов
        """
        if not self._initialized and curses.has_colors():
            curses.start_color()
            curses.use_default_colors()
            
            # Определяем цветовые пары
            curses.init_pair(Color.RED.value, curses.COLOR_RED, -1)
            curses.init_pair(Color.GREEN.value, curses.COLOR_GREEN, -1)
            curses.init_pair(Color.YELLOW.value, curses.COLOR_YELLOW, -1)
            curses.init_pair(Color.BLUE.value, curses.COLOR_BLUE, -1)
            curses.init_pair(Color.MAGENTA.value, curses.COLOR_MAGENTA, -1)
            curses.init_pair(Color.CYAN.value, curses.COLOR_CYAN, -1)
            curses.init_pair(Color.WHITE.value, curses.COLOR_WHITE, -1)
            curses.init_pair(Color.GRAY.value, 8, -1)
            
            self._initialized = True

    def get_color_pair(self, color: Color) -> int:
        """
        Получение цветовой пары.
        
        Args:
            color: Цвет из перечисления Color
            
        Returns:
            Цветовая пара для curses
        """
        if not self._initialized:
            return curses.A_NORMAL
        return curses.color_pair(color.value)
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/rendering/template_renderer.py
# Game/UI/Rendering/template_renderer.py
"""
Рендерер для работы с шаблонами текста.

Позволяет создавать форматированный текст с плейсхолдерами и различными
стилями для каждой части текста.
"""

import re
from typing import Dict, List, Tuple
import curses
from game.ui.rendering.color_manager import Color


class TemplatePart:
    """Часть шаблона с форматированием."""
    
    def __init__(self, text: str, color: Color = Color.DEFAULT, bold: bool = False, dim: bool = False):
        """
        Инициализация части шаблона.
        
        Args:
            text: Текст части
            color: Цвет текста
            bold: Жирный шрифт
            dim: Тусклый шрифт
        """
        self.text = text
        self.color = color
        self.bold = bold
        self.dim = dim


class TemplateRenderer:
    """Рендерер для работы с шаблонами текста."""
    
    def __init__(self, color_manager):
        """
        Инициализация рендерера шаблонов.
        
        Args:
            color_manager: Менеджер цветов для применения стилей
        """
        self.color_manager = color_manager
        # Регулярное выражение для поиска плейсхолдеров типа %1, %2 и т.д.
        self.placeholder_pattern = re.compile(r'%(\d+)')
    
    def render_template(self, template: str, 
                       replacements: Dict[str, Tuple[str, Color, bool, bool]]) -> List[TemplatePart]:
        """
        Рендер шаблона с заменами.
        
        Args:
            template: Шаблон текста, например "%1 ударяет %2"
            replacements: Словарь {номер: (текст, цвет, жирный, тусклый)}, например {"1": ("Игрок", Color.GREEN, True, False)}
            
        Returns:
            Список частей текста с форматированием
        """
        parts = []
        last_end = 0
        
        # Находим все плейсхолдеры
        for match in self.placeholder_pattern.finditer(template):
            start, end = match.span()
            placeholder_num = match.group(1)
            
            # Добавляем текст до плейсхолдера
            if start > last_end:
                parts.append(TemplatePart(template[last_end:start]))
            
            # Добавляем замену для плейсхолдера
            if placeholder_num in replacements:
                text, color, bold, dim = replacements[placeholder_num]
                parts.append(TemplatePart(text, color, bold, dim))
            else:
                # Если нет замены, оставляем плейсхолдер как есть
                parts.append(TemplatePart(match.group(0)))
            
            last_end = end
        
        # Добавляем оставшийся текст
        if last_end < len(template):
            parts.append(TemplatePart(template[last_end:]))
        
        return parts
    
    def draw_template(self, stdscr, template: str, replacements: Dict[str, Tuple[str, Color, bool, bool]], 
                     x: int, y: int) -> None:
        """
        Отрисовка шаблона на экране.
        
        Args:
            stdscr: Окно curses для отрисовки
            template: Шаблон текста
            replacements: Словарь замен
            x: Координата X
            y: Координата Y
        """
        try:
            parts = self.render_template(template, replacements)
            current_x = x
            
            for part in parts:
                if y >= 0 and current_x >= 0:
                    attr = self.color_manager.get_color_pair(part.color)
                    if part.bold:
                        attr |= curses.A_BOLD
                    if part.dim:
                        attr |= curses.A_DIM
                    
                    stdscr.addstr(y, current_x, part.text, attr)
                    current_x += len(part.text)
        except curses.error:
            # Игнорируем ошибки выхода за границы экрана
            pass
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/command_system/screen_command_registry.py
# game/ui/command_system/screen_command_registry.py
"""
Реестр команд для экранов.

Реализует паттерн Реестр для хранения связей между экранами и их командами.
"""

from typing import Dict, List, Type, TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen
    from game.ui.command_system.command import Command

# Глобальный реестр: КлассЭкрана -> СписокКоманд
SCREEN_COMMANDS: Dict[Type['BaseScreen'], List['Command']] = {}


def register_screen_commands(screen_class: Type['BaseScreen'], commands: List['Command']) -> None:
    """
    Регистрация команд для конкретного экрана.
    
    Args:
        screen_class: Класс экрана
        commands: Список команд для этого экрана
    """
    SCREEN_COMMANDS[screen_class] = commands


def get_screen_commands(screen_class: Type['BaseScreen']) -> List['Command']:
    """
    Получение команд для конкретного экрана.
    
    Args:
        screen_class: Класс экрана
        
    Returns:
        Список команд для экрана (пустой список если нет команд)
    """
    return SCREEN_COMMANDS.get(screen_class, [])


def get_all_registered_screens() -> List[Type['BaseScreen']]:
    """
    Получение всех экранов с зарегистрированными командами.
    
    Returns:
        Список классов экранов
    """
    return list(SCREEN_COMMANDS.keys())


def clear_registry() -> None:
    """Очистка реестра (для тестирования)."""
    SCREEN_COMMANDS.clear()
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/command_system/command.py
# game/ui/command_system/command.py
"""
Базовые классы для системы команд.

Реализует паттерн Команда для обработки пользовательского ввода.
"""

from abc import ABC, abstractmethod
import curses
from turtle import st
from typing import List, Set, Optional, Any, Union

# Отложенная аннотация для избежания циклического импорта
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.base_screen import BaseScreen


class Command(ABC):
    """Абстрактная команда."""

    def __init__(self, name: str, description: str, keys: List[Union[str, int]], display_key: str = ""):
        """
        Инициализация команды.
        
        Args:
            name: Название команды
            description: Описание команды
            keys: Список клавиш, на которые назначена команда (например, ['q', 'ESC'])
        """
        self.name = name
        self.description = description
        self.keys = keys  # Список символов, например ['q', 'ESC']
        self.display_key = display_key

    def get_key_codes(self) -> Set[int]:
        """
        Получение кодов клавиш для регистрации.
        
        Returns:
            Множество кодов клавиш
        """
        key_codes = set()
        for key in self.keys:
            if isinstance(key, int):
                key_codes.add(key)
            else:
                key_codes.add(ord(str(key)))
            # Можно добавить другие специальные клавиши
        return key_codes

    @abstractmethod
    def execute(self, context: Optional[Any] = None) -> None:
        """
        Выполнение команды.
        
        Args:
            context: Контекст выполнения (обычно экран)
        """
        pass


class CommandRegistry:
    """Реестр команд для экрана."""

    def __init__(self) -> None:
        self._commands: List[Command] = []
        self._key_to_command: dict = {}  # key_code -> command

    def register_command(self, command: Command) -> None:
        """
        Регистрация команды.
        
        Args:
            command: Команда для регистрации
        """
        self._commands.append(command)
        # Регистрируем все клавиши команды
        for key_code in command.get_key_codes():
            self._key_to_command[key_code] = command

    def execute_command(self, key_code: int, context: Optional[Any] = None) -> bool:
        """
        Выполнение команды по коду клавиши.
        
        Args:
            key_code: Код нажатой клавиши
            context: Контекст выполнения
            
        Returns:
            True если команда найдена и выполнена, False если нет
        """
        if key_code in self._key_to_command:
            self._key_to_command[key_code].execute(context)
            return True
        return False

    def get_all_commands(self) -> List[Command]:
        """Получение всех зарегистрированных команд."""
        return self._commands.copy()

    def get_command_by_key(self, key_code: int) -> Optional[Command]:
        """Получение команды по коду клавиши."""
        return self._key_to_command.get(key_code)
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/command_system/__init__.py
# game/ui/command_system/__init__.py
"""
Система команд пользовательского интерфейса.

Содержит самодостаточные команды и систему их регистрации.
"""

from .command import Command, CommandRegistry
from .screen_command_registry import (
    register_screen_commands,
    get_screen_commands,
    get_all_registered_screens,
    clear_registry
)
from .command_renderer import CommandRenderer  # ДОБАВИЛИ!

__all__ = [
    'Command',
    'CommandRegistry',
    'CommandRenderer',  # ДОБАВИЛИ!
    'register_screen_commands',
    'get_screen_commands',
    'get_all_registered_screens',
    'clear_registry'
]
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/command_system/command_renderer.py
# game/ui/command_system/command_renderer.py
"""
Отрисовка команд пользовательского интерфейса.

Отдельный класс для отображения информации о доступных командах.
"""

from typing import List, TYPE_CHECKING
from game.ui.rendering.color_manager import Color
from game.ui.rendering.renderable import Text

if TYPE_CHECKING:
    from game.ui.command_system.command import Command


class CommandRenderer:
    """Отрисовщик команд."""

    def __init__(self, x: int = 0, y: int = 15, max_width: int = 70):
        """
        Инициализация отрисовщика команд.
        
        Args:
            x: Начальная координата X
            y: Начальная координата Y
            max_width: Максимальная ширина строки команд
        """
        self.x = x
        self.y = y
        self.max_width = max_width

    def render_commands(self, commands: List['Command']) -> List[Text]:
        """
        Создание элементов отрисовки для команд в одной строке.
        Команды отображаются в формате "key : описание", разделенные " | ".
        Все элементы - тускло серые.

        Args:
            commands: Список команд для отрисовки

        Returns:
            Список текстовых элементов для отрисовки
        """
        if not commands:
            return []

        # Создаем список строк для каждой команды
        command_strings: List[str] = []
        for command in commands:
            command_strings.append(f"{command.display_key} : {command.name}") # Формат: "key : описание"

        # Объединяем их с разделителем " | " и создаем один элемент Text
        full_line = " | ".join(command_strings)
        
        # Возвращаем один текстовый элемент, весь текст будет тускло серым
        return [Text(full_line, self.x, self.y, dim=True, color=Color.GRAY)]
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/commands/__init__.py
# game/ui/commands/__init__.py
"""
Пакет конкретных команд для разных экранов.

Содержит реализации команд для конкретных экранов игры.
"""

# ВАЖНО: Импортируем все команды, чтобы они зарегистрировались
import game.ui.commands.common_commands
import game.ui.commands.inventory_commands
import game.ui.commands.battle_commands
import game.ui.commands.main_screen_commands

# Экспортируем основные классы команд для удобства использования
# Общие команды
from .common_commands import (
    GoBackCommand,
    OpenInventoryCommand,
    HelpCommand,
    ExitCommand
)

# Специфические команды инвентаря
from .inventory_commands import (
    UseItemCommand,
    DropItemCommand
)

# Специфические команды боя
from .battle_commands import (
    AttackCommand,
    DefendCommand,
    MagicCommand as BattleMagicCommand
)

# Специфические команды главного экрана
from .main_screen_commands import (
    StartBattleCommand,
    OpenSettingsCommand
)

__all__ = [
    # Общие команды
    'GoBackCommand',
    'OpenInventoryCommand',
    'HelpCommand',
    'ExitCommand',
    
    # Команды инвентаря
    'UseItemCommand',
    'DropItemCommand',
    
    # Команды боя
    'AttackCommand',
    'DefendCommand',
    'BattleMagicCommand',
    
    # Команды главного экрана
    'StartBattleCommand',
    'OpenSettingsCommand'
]
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/commands/inventory_commands.py
# game/ui/commands/inventory_commands.py
"""
Специфические команды для экрана инвентаря.
"""

from curses import KEY_ENTER
from game.ui.command_system.command import Command
from game.ui.inventory_screen import InventoryScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class UseItemCommand(Command):
    """Команда использования предмета."""

    def __init__(self):
        super().__init__(
            name="Использовать",
            description="Использовать выбранный предмет",
            keys=['u', KEY_ENTER],
            display_key="u/Enter"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды использования предмета."""
        if context:
            print("Предмет использован")


class DropItemCommand(Command):
    """Команда выбрасывания предмета."""

    def __init__(self):
        super().__init__(
            name="Выбросить",
            description="Выбросить выбранный предмет",
            keys=['d'],
            display_key="d"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды выбрасывания предмета."""
        if context:
            print("Предмет выброшен")


# Импортируем общие команды
from game.ui.commands.common_commands import GoBackCommand

# Регистрируем команды для экрана инвентаря
register_screen_commands(InventoryScreen, [
    UseItemCommand(),
    DropItemCommand(),
    GoBackCommand()  # Переиспользуем общую команду
])
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/commands/battle_commands.py
# game/ui/commands/battle_commands.py
"""
Специфические команды для экрана боя.
"""

from game.ui.command_system.command import Command
from game.ui.battle_screen import BattleScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class AttackCommand(Command):
    """Команда атаки."""

    def __init__(self):
        super().__init__(
            name="Атака",
            description="Атаковать противника",
            keys=['a', 'A'],
            display_key="A/a"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды атаки."""
        if context:
            print("Атака!")


class DefendCommand(Command):
    """Команда защиты."""

    def __init__(self):
        super().__init__(
            name="Защита",
            description="Защититься от атаки",
            keys=['d'],
            display_key="d"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды защиты."""
        if context:
            print("Защита!")


class MagicCommand(Command):
    """Команда использования магии."""

    def __init__(self):
        super().__init__(
            name="Магия",
            description="Использовать магическое заклинание",
            keys=['m'],
            display_key="m"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды магии."""
        if context:
            print("Магия!")


# Импортируем общие команды
from game.ui.commands.common_commands import GoBackCommand, OpenInventoryCommand

# Регистрируем команды для экрана боя
register_screen_commands(BattleScreen, [
    AttackCommand(),
    DefendCommand(),
    MagicCommand(),
    OpenInventoryCommand(),  # Переиспользуем общую команду
    GoBackCommand()          # Переиспользуем общую команду
])
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/commands/main_screen_commands.py
# game/ui/commands/main_screen_commands.py
"""
Специфические команды для главного экрана.
"""

from game.ui.command_system.command import Command
from game.ui.main_screen import MainScreen
from game.ui.command_system.screen_command_registry import register_screen_commands
from typing import Optional, Any


class StartBattleCommand(Command):
    """Команда начала боя."""

    def __init__(self):
        super().__init__(
            name="Бой",
            description="Начать бой",
            keys=[10],
            display_key="Enter"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды начала боя."""
        if context and hasattr(context, 'manager'):
            context.manager.change_screen("battle")


class OpenSettingsCommand(Command):
    """Команда открытия настроек."""

    def __init__(self):
        super().__init__(
            name="Настройки",
            description="Открыть настройки",
            keys=['3'],
            display_key="3"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды открытия настроек."""
        if context:
            print("Открытие настроек")


# Импортируем общие команды
from game.ui.commands.common_commands import OpenInventoryCommand, ExitCommand

# Регистрируем команды для главного экрана
register_screen_commands(MainScreen, [
    StartBattleCommand(),
    OpenInventoryCommand(),  # Переиспользуем общую команду
    OpenSettingsCommand(),
    ExitCommand()            # Переиспользуем общую команду
])
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/commands/common_commands.py
# game/ui/commands/common_commands.py
"""
Общие команды, которые могут использоваться в нескольких экранах.
"""

from game.ui.command_system.command import Command
from typing import TYPE_CHECKING, Optional, Any



class GoBackCommand(Command):
    """Общая команда возврата назад."""

    def __init__(self):
        super().__init__(
            name="Назад",
            description="Вернуться к предыдущему экрану",
            keys=['q'],
            display_key="q"

        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды возврата."""
        if context and hasattr(context, 'manager'):
            context.manager.go_back()


class OpenInventoryCommand(Command):
    """Общая команда открытия инвентаря."""

    def __init__(self):
        super().__init__(
            name="Инвентарь",
            description="Открыть инвентарь",
            keys=['i'],
            display_key="i"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды открытия инвентаря."""
        if context and hasattr(context, 'manager'):
            context.manager.change_screen("inventory")


class HelpCommand(Command):
    """Общая команда помощи."""

    def __init__(self):
        super().__init__(
            name="Помощь",
            description="Показать помощь",
            keys=['h', '?'],
            display_key="h/?"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды помощи."""
        if context:
            print("Помощь по экрану:", context.__class__.__name__ if context else "Неизвестный экран")


class ExitCommand(Command):
    """Общая команда выхода из игры."""

    def __init__(self):
        super().__init__(
            name="Выход",
            description="Выйти из игры",
            keys=['q'],  # Только q, не ESC чтобы избежать конфликтов
            display_key="q"
        )

    def execute(self, context: Optional[Any] = None) -> None:
        """Выполнение команды выхода."""
        exit()
================================================================================

/home/zumik/Documents/Battler_0.3/game/ui/components/battle_components.py
# game/ui/components/battle_components.py
"""
Компоненты для экрана боя.
Содержит визуальные элементы для отображения игроков, врагов и лога боя.
"""

from game.ui.rendering.renderable import Renderable
from game.ui.rendering.color_manager import Color
from typing import List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from game.ui.rendering.renderer import Renderer


class UnitPanel(Renderable):
    """Базовая панель для отображения одного юнита (игрок или монстр). Высота 1 строка."""
    
    def __init__(self, x: int, y: int, width: int, name: str, hp: int, max_hp: int, 
                 mp: int = 0, max_mp: int = 0, is_player: bool = True):
        super().__init__(x, y)
        self.width = width
        self.name = name
        self.hp = hp
        self.max_hp = max_hp
        self.mp = mp
        self.max_mp = max_mp
        self.is_player = is_player
        # Заглушка для баффов/дебаффов
        self.status_effects: List[str] = [] # Например: ["Poison", "Shield"]

    def update_position(self, x: int, y: int) -> None:
        """Обновление позиции панели."""
        self.x = x
        self.y = y

    def update_stats(self, hp: int, max_hp: int, mp: int = 0, max_mp: int = 0) -> None:
        """Обновление статистики юнита."""
        self.hp = hp
        self.max_hp = max_hp
        self.mp = mp
        self.max_mp = max_mp

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка панели юнита в одну строку."""
        # Формат: [Имя] [HP Bar] [MP Bar] [Статусы]
        # Пример: Hero [#####.....] [***......] Poison
        try:
            # Рассчитываем доступную ширину
            available_width = self.width
            
            # Имя (минимум 8 символов)
            name_width = min(12, max(8, len(self.name)))
            name_part = self.name[:name_width].ljust(name_width)
            
            # Статусы (минимум 6 символов, максимум 15)
            status_str = " ".join(self.status_effects[:3]) # Показываем максимум 3 эффекта
            status_width = min(15, max(6, len(status_str)))
            status_part = status_str[:status_width].ljust(status_width)
            
            # Оставшаяся ширина для полосок HP и MP
            bars_width = available_width - name_width - status_width - 3 # 3 пробела
            
            # Если места мало, упрощаем
            if bars_width < 10:
                # Показываем только имя и HP в виде текста
                hp_text = f"{self.hp}/{self.max_hp}"
                simple_display = f"{name_part} {hp_text}".ljust(self.width)[:self.width]
                renderer.draw_text(
                    simple_display, 
                    self.x, 
                    self.y, 
                    color=Color.GREEN if self.is_player else Color.RED
                )
                return

            # Делим оставшуюся ширину между HP и MP
            hp_bar_width = max(5, bars_width // 2)
            mp_bar_width = max(5, bars_width - hp_bar_width - 1) # -1 для пробела
            
            # HP Bar
            hp_fill = int((self.hp / self.max_hp) * hp_bar_width) if self.max_hp > 0 else 0
            hp_bar = "#" * hp_fill + "." * (hp_bar_width - hp_fill)
            
            # MP Bar (если есть MP)
            mp_bar = ""
            if self.max_mp > 0:
                mp_fill = int((self.mp / self.max_mp) * mp_bar_width) if self.max_mp > 0 else 0
                mp_bar = " " + "*" * mp_fill + "." * (mp_bar_width - mp_fill)
            
            # Собираем строку
            display_line = f"{name_part} [{hp_bar}] [{mp_bar}] {status_part}".rstrip()
            # Обрезаем, если вышло за границы
            display_line = display_line[:self.width]
            
            # Определяем цвет
            color = Color.GREEN if self.is_player else Color.RED
            
            renderer.draw_text(display_line, self.x, self.y, color=color)
            
        except Exception as e:
            # В случае ошибки рисуем простую заглушку
            renderer.draw_text(
                f"{self.name} HP:{self.hp}/{self.max_hp}".ljust(self.width)[:self.width], 
                self.x, 
                self.y, 
                color=Color.WHITE
            )


class PlayerUnitPanel(UnitPanel):
    """Панель для отображения одного игрока."""
    def __init__(self, x: int, y: int, width: int, name: str, hp: int, max_hp: int, 
                 mp: int = 0, max_mp: int = 0):
        super().__init__(x, y, width, name, hp, max_hp, mp, max_mp, is_player=True)


class EnemyUnitPanel(UnitPanel):
    """Панель для отображения одного врага."""
    def __init__(self, x: int, y: int, width: int, name: str, hp: int, max_hp: int):
        # У врагов обычно нет MP
        super().__init__(x, y, width, name, hp, max_hp, 0, 0, is_player=False)


class GroupPanel(Renderable):
    """Панель для отображения группы юнитов (игроков или врагов)."""
    
    def __init__(self, x: int, y: int, width: int, height: int, title: str = ""):
        super().__init__(x, y)
        self.width = width
        self.height = height
        self.title = title
        self.unit_panels: List[UnitPanel] = []

    def add_unit_panel(self, unit_panel: UnitPanel) -> None:
        """Добавление панели юнита в группу."""
        self.unit_panels.append(unit_panel)

    def clear_unit_panels(self) -> None:
        """Очистка списка панелей юнитов."""
        self.unit_panels.clear()

    def update_size(self, total_width: int, total_height: int) -> None:
        """Обновление размеров группы."""
        # Размеры могут быть скорректированы внешним кодом
        pass

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка группы панелей."""
        # Рисуем рамку вокруг группы
        renderer.draw_box(self.x, self.y, self.width, self.height)
        
        # Рисуем заголовок, если он есть
        if self.title:
            title_x = self.x + max(0, (self.width - len(self.title)) // 2)
            renderer.draw_text(self.title, title_x, self.y, bold=True, 
                             color=Color.CYAN if "Игроки" in self.title else Color.MAGENTA)

        # Отрисовываем панели юнитов
        for i, unit_panel in enumerate(self.unit_panels):
            if i >= self.height - 2:  # -2 для рамки и заголовка
                break  # Не помещаемся
            unit_panel.update_position(self.x + 1, self.y + 1 + i)
            unit_panel.render(renderer)


class BattleLog(Renderable):
    """Лог боя в нижней части экрана с прокруткой."""
    
    def __init__(self, x: int, y: int, width: int, height: int):
        super().__init__(x, y)
        self.width = width
        self.height = height
        # TODO: Получать реальные сообщения из игровой логики
        self.messages: List[str] = [
            "Битва начинается!",
            "Герой вступает в бой с Драконом.",
            "Дракон издает грозный рык.",
            "Герой атакует Дракона!",
            "Дракон получает 25 урона.",
            "Дракон атакует Героя!",
            "Герой получает 15 урона.",
            "Герой использует зелье лечения.",
            "Герой восстанавливает 30 HP.",
            "Дракон готовится к мощной атаке!",
            "Герой защищается.",
            "Мощная атака Дракона отражена!",
        ]
        self.scroll_offset = 0 # Смещение прокрутки (0 = последние сообщения внизу)

    def add_message(self, message: str) -> None:
        """Добавление сообщения в лог."""
        self.messages.append(message)
        # При добавлении нового сообщения сбрасываем прокрутку вниз
        self.scroll_offset = 0

    def scroll_up(self) -> None:
        """Прокрутка лога вверх."""
        # Максимальное смещение - это количество строк, которые не помещаются
        max_offset = max(0, len(self.messages) - (self.height - 2))
        self.scroll_offset = min(max_offset, self.scroll_offset + 1)

    def scroll_down(self) -> None:
        """Прокрутка лога вниз."""
        self.scroll_offset = max(0, self.scroll_offset - 1)

    def update_size(self, total_width: int, total_height: int) -> None:
        """Обновление размеров лога."""
        # Занимает всю ширину экрана
        self.width = max(10, total_width - 2) # -2 для отступов
        # Высота динамическая, занимает всё оставшееся пространство
        # Предполагаем, что панели сверху занимают часть высоты
        # Этот расчет должен быть скорректирован в BattleScreen
        pass

    def render(self, renderer: 'Renderer') -> None:
        """Отрисовка лога боя."""
        # Рисуем рамку
        renderer.draw_box(self.x, self.y, self.width, self.height)
        
        # Заголовок лога
        log_title = "=== ЛОГ ==="
        title_x = self.x + max(0, (self.width - len(log_title)) // 2)
        renderer.draw_text(log_title, title_x, self.y, bold=True, color=Color.CYAN)
        
        # Отображаем сообщения с учетом прокрутки
        # Рассчитываем, сколько строк помещается (вычитаем 2 для рамки и заголовка)
        available_lines = self.height - 2 
        # Начальный индекс с учетом прокрутки
        start_index = max(0, len(self.messages) - available_lines - self.scroll_offset)
        end_index = min(len(self.messages), start_index + available_lines)
        
        for i, message in enumerate(self.messages[start_index:end_index]):
            # Обрезаем сообщение, если оно длиннее области
            display_message = message[:self.width - 3] # -3 для рамки и запаса
            renderer.draw_text(display_message, self.x + 1, self.y + 1 + i, dim=True)

================================================================================

